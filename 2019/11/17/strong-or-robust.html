<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Strong or Robust? | systems++</title>
<meta name=keywords content="Software Engineering">
<meta name=description content="Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called &ldquo;strong-typing&rdquo; advocating new API designs. In this post, I go a little into the debate and discuss its consequences.
What does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn&rsquo;t want their software to be robust?">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2019/11/17/strong-or-robust.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Strong or Robust?">
<meta property="og:description" content="Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called &ldquo;strong-typing&rdquo; advocating new API designs. In this post, I go a little into the debate and discuss its consequences.
What does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn&rsquo;t want their software to be robust?">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2019/11/17/strong-or-robust.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-11-17T08:00:00-05:00">
<meta property="article:modified_time" content="2019-11-17T08:00:00-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Strong or Robust?">
<meta name=twitter:description content="Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called &ldquo;strong-typing&rdquo; advocating new API designs. In this post, I go a little into the debate and discuss its consequences.
What does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn&rsquo;t want their software to be robust?">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Strong or Robust?","item":"http://robertu94.github.io/2019/11/17/strong-or-robust.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Strong or Robust?","name":"Strong or Robust?","description":"Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called \u0026ldquo;strong-typing\u0026rdquo; advocating new API designs. In this post, I go a little into the debate and discuss its consequences.\nWhat does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn\u0026rsquo;t want their software to be robust?","keywords":["Software Engineering"],"articleBody":"Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called “strong-typing” advocating new API designs. In this post, I go a little into the debate and discuss its consequences.\nWhat does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn’t want their software to be robust? However, robust to what? And more importantly, at what costs?\nOne of the most lasting definitions of robustness comes from Jon Postel – one of the early architects of the Internet.\n Be liberal in what you accept, and conservative in what you send\n By this he argued, that systems should accept a wide array of types and formats as input, while sending out a highly specified return value. Now Postel meant this in terms of the design of inter-networked systems such as the Internet; However, the same principles apply to API design. What is an API except a means by which we accept input from others and return to them a response or do some work on their behalf.\nHowever this comes at a cost. Network programming has bedeviled many a computer science undergraduate and later engineers as they attempt to cope with the proliferation of implementations on the Internet. In some senses, these systems are not easy to use.\nIn a different domain, developers and teachers such as Jonathan Bocara have been advocating for so-called “strong types”. Bocara describes strong types this way:\n A strong type is a type used in place of another type to carry specific meaning through its name\n At first this might not make a ton of sense so consider this example which is slightly different than the one Bocara uses:\ntemplate class Type, class Tag struct NamedType { Type value; templateclass... Args explicit NamedType(Args\u0026\u0026... value_args): value(std::forwardArgs(value_args)...) {} operator Type() { return value; } }; using NumThreads = NamedTypeunsigned int, struct threads; This allows instances of NumThreads to be used as an unsigned int but instances of unsigned int cannot be used as NumThreads without explicitly converting it to a NumThreads first. Likewise, each class instantiated from, NamedType is incompatible with each other. That means if we made another type called NumProcesses from NamedType it would also be incompatible. You can only use NumThreads for NumThreads and NumProcesses for NumProcesses\nBocara and others argue that this design makes it easier to use APIs that use types like this. Specifically, it helps with the wrong argument order problem and the problems associated with not understanding what a argument means from a call site. To use the example above, if all you have is 4 at the call sight, you have no idea what 4 means, but if you see NumThreads(4) you can be reasonably sure that the function will use 4 threads.\nWhat are the trade-offs? I see there are two major areas of trade-offs between strong and robust types.\nFirst is the tradeoff between ease of implementation and ease of use and flexibility. Strong Types are self-evidently easier to implement and use. They are self-documenting at the call site, and they are trival to write with helpers such as NamedType above. Additionally, since strong types can only be used in one way, they require less effort to implement.\nStrong types are less flexible. Consider a concurrency library that allows tasks to be executed in parallel. At first, this library could be implemented using operating system threads. This library could have a type called NumThreads which determines the number of threads that are to be used. However, an enterprising developer could add another back-end that uses operating system processes instead. At this point, the developer could use NumThreads for both and the name would be misleading, he could could create a new type called NumProcesses, or he could rename NumThreads to a new name which implies some other other concurrency model that users have to learn and understand while breaking the API for all downstream users who have NumThreads in their code. The second choice is even more insidious because it now makes it harder from some down-stream user to have a generic parallel solution that works regardless of what kind of parallelism the user wants to employ because they now need to introspect the task queue to determine which argument it needs to have passed.\nSecond is modifiability. For either, contracting the API – i.e. allowing fewer inputs than previously allowed – is a breaking change to users of the API. This is illustrated by Hyrum’s law:\n With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody. ~ Hyrum’s Law\n For strong types, expanding the API is typically not a breaking change unless users are doing something unusual (i.e. making a function pointer from your API, need ABI compatibility for an API with default arguments, etc) and requires only an additional overload. For robust APIs, they necessarily allow expansion by definition, but then require a substantially more robust design to accept a wider possible array of input types.\nHow can we do implement these principles? Every language has different capabilities to implement these design patterns. I take a few case studies from a few languages that I have used: Java, C++, and Python.\nStatically typed languages such as Java and C++ have the ability to implement something like a strong type. Where they differ is their ability to implement robust types.\nJava which prides itself as a language for software engineers and architects has a wide array of options for complementing robust types. It has interfaces, bounded generics and unbounded generics. Using these facilities is straight forward.\nC++ has fewer but arguably more powerful options with template and SFINAE. Since C++ templates are turning complete, it is possible to implement very sophisticated code generation facilities in templates if you don’t care about compile times. However unlike Java, these changes are typical not trivial. To implement constrained templates uses will take advantage of SFINAE and built-in classes such as std::enable_if and std::void_t to enable and disable functionality. In C++20, C++ gained concepts which allow an easier way to specify this kind of functionality, but these are as of writing not yet widely available.\nDynamically typed languages such as Python have very little ability to implement strong types without going against the principles of the language. In recent versions, python has gained a facility called Type Hints which can provide some additional information to API users, but it isn’t widely used, and isn’t as complete a full type system in a language such as C++ or Java.\nWhy does it matter? So why do these design choices matter? They matter because they change the quality attributes of our designs. As we chose between strong types and robust types, we make decisions that impact the maintainability, usability, and modifiability of our designs. Thinking carefully through these trade-offs will improve our designs.\nHope this helps!\n","wordCount":"1183","inLanguage":"en","datePublished":"2019-11-17T08:00:00-05:00","dateModified":"2019-11-17T08:00:00-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2019/11/17/strong-or-robust.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Strong or Robust?
</h1>
<div class=post-meta><span title="2019-11-17 08:00:00 -0500 -0500">November 17, 2019</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1183 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#what-does-it-mean-to-be-strong-vs-robust>What does it mean to be strong vs robust?</a></li>
<li><a href=#what-are-the-trade-offs>What are the trade-offs?</a></li>
<li><a href=#how-can-we-do-implement-these-principles>How can we do implement these principles?</a></li>
<li><a href=#why-does-it-matter>Why does it matter?</a></li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>Should a software design be strong or robust?
This is a debate that seems to have been developing in recent years with the recent proponents so-called &ldquo;strong-typing&rdquo; advocating new API designs.
In this post, I go a little into the debate and discuss its consequences.</p>
<h1 id=what-does-it-mean-to-be-strong-vs-robust>What does it mean to be strong vs robust?<a hidden class=anchor aria-hidden=true href=#what-does-it-mean-to-be-strong-vs-robust>#</a></h1>
<p>Robustness in software engineering is not a new concept, and intuitively a attractive one.
Who doesn&rsquo;t want their software to be robust?
However, robust to what?
And more importantly, at what costs?</p>
<p>One of the <a href=https://tools.ietf.org/html/rfc1122>most lasting definitions of robustness comes</a> from Jon Postel &ndash; one of the early architects of the Internet.</p>
<blockquote>
<p>Be liberal in what you accept, and conservative in what you send</p>
</blockquote>
<p>By this he argued, that systems should accept a wide array of types and formats as input, while sending out a highly specified return value.
Now Postel meant this in terms of the design of inter-networked systems such as the Internet;
However, the same principles apply to API design.
What is an API except a means by which we accept input from others and return to them a response or do some work on their behalf.</p>
<p>However this comes at a cost.
Network programming has bedeviled many a computer science undergraduate and later engineers as they attempt to cope with the proliferation of implementations on the Internet.
In some senses, these systems are not easy to use.</p>
<p>In a different domain, developers and teachers such as Jonathan Bocara have been <a href=https://www.fluentcpp.com/2016/12/08/strong-types-for-strong-interfaces/>advocating for so-called &ldquo;strong types&rdquo;.</a>
Bocara describes strong types this way:</p>
<blockquote>
<p>A strong type is a type used in place of another type to carry specific meaning through its name</p>
</blockquote>
<p>At first this might not make a ton of sense so consider this example which is slightly different than the one Bocara uses:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Type</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Tag</span><span class=o>&gt;</span> 
<span class=k>struct</span> <span class=nc>NamedType</span> <span class=p>{</span>
  <span class=n>Type</span> <span class=n>value</span><span class=p>;</span>
  <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
  <span class=k>explicit</span> <span class=n>NamedType</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>value_args</span><span class=p>)</span><span class=o>:</span> <span class=n>value</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>value_args</span><span class=p>)...)</span> <span class=p>{}</span>
  <span class=k>operator</span> <span class=nf>Type</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span><span class=p>;</span> <span class=p>}</span>
<span class=p>};</span>
<span class=k>using</span> <span class=n>NumThreads</span> <span class=o>=</span> <span class=n>NamedType</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>threads</span><span class=o>&gt;</span><span class=p>;</span>
</code></pre></div><p>This allows instances of <code>NumThreads</code> to be used as an <code>unsigned int</code> but instances of <code>unsigned int</code> cannot be used as <code>NumThreads</code> without explicitly converting it to a <code>NumThreads</code> first.
Likewise, each class instantiated from, NamedType is incompatible with each other.
That means if we made another type called <code>NumProcesses</code> from <code>NamedType</code> it would also be incompatible.
You can only use <code>NumThreads</code> for <code>NumThreads</code> and <code>NumProcesses</code> for <code>NumProcesses</code></p>
<p>Bocara and others argue that this design makes it easier to use APIs that use types like this.
Specifically, it helps with the wrong argument order problem and the problems associated with not understanding what a argument means from a call site.
To use the example above, if all you have is <code>4</code> at the call sight, you have no idea what <code>4</code> means, but if you see <code>NumThreads(4)</code> you can be reasonably sure that the function will use <code>4</code> threads.</p>
<h1 id=what-are-the-trade-offs>What are the trade-offs?<a hidden class=anchor aria-hidden=true href=#what-are-the-trade-offs>#</a></h1>
<p>I see there are two major areas of trade-offs between strong and robust types.</p>
<p>First is the tradeoff between ease of implementation and ease of use and flexibility.
Strong Types are self-evidently easier to implement and use.
They are self-documenting at the call site, and they are trival to write with helpers such as <code>NamedType</code> above.
Additionally, since strong types can only be used in one way, they require less effort to implement.</p>
<p>Strong types are less flexible.
Consider a concurrency library that allows tasks to be executed in parallel.
At first, this library could be implemented using operating system threads.
This library could have a type called <code>NumThreads</code> which determines the number of threads that are to be used.
However, an enterprising developer could add another back-end that uses operating system processes instead.
At this point, the developer could use <code>NumThreads</code> for both and the name would be misleading, he could could create a new type called <code>NumProcesses</code>, or he could rename <code>NumThreads</code> to a new name which implies some other other concurrency model that users have to learn and understand while breaking the API for all downstream users who have <code>NumThreads</code> in their code.
The second choice is even more insidious because it now makes it harder from some down-stream user to have a generic parallel solution that works regardless of what kind of parallelism the user wants to employ because they now need to introspect the task queue to determine which argument it needs to have passed.</p>
<p>Second is modifiability.
For either, contracting the API &ndash; i.e. allowing fewer inputs than previously allowed &ndash; is a breaking change to users of the API.
This is illustrated by Hyrum&rsquo;s law:</p>
<blockquote>
<p>With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody. ~ <a href=https://www.hyrumslaw.com/>Hyrum&rsquo;s Law</a></p>
</blockquote>
<p>For strong types, expanding the API is typically not a breaking change unless users are doing something unusual (i.e. making a function pointer from your API, need ABI compatibility for an API with default arguments, etc) and requires only an additional overload.
For robust APIs, they necessarily allow expansion by definition, but then require a substantially more robust design to accept a wider possible array of input types.</p>
<h1 id=how-can-we-do-implement-these-principles>How can we do implement these principles?<a hidden class=anchor aria-hidden=true href=#how-can-we-do-implement-these-principles>#</a></h1>
<p>Every language has different capabilities to implement these design patterns.
I take a few case studies from a few languages that I have used: Java, C++, and Python.</p>
<p><img loading=lazy src=%7b%7bsite.url%7d%7d/static/posts/strongtypes/StrongTypesRobust.png alt="Strong Types Vs Robust Designs">
</p>
<p>Statically typed languages such as Java and C++ have the ability to implement something like a strong type.
Where they differ is their ability to implement robust types.</p>
<p>Java which prides itself as a language for software engineers and architects has a wide array of options for complementing robust types.
It has interfaces, bounded generics and unbounded generics.
Using these facilities is straight forward.</p>
<p>C++ has fewer but arguably more powerful options with template and SFINAE.
Since C++ templates are turning complete, it is possible to implement very sophisticated code generation facilities in templates if you don&rsquo;t care about compile times.
However unlike Java, these changes are typical not trivial.
To implement constrained templates uses will take advantage of SFINAE and built-in classes such as <code>std::enable_if</code> and <code>std::void_t</code> to enable and disable functionality.
In C++20, C++ gained concepts which allow an easier way to specify this kind of functionality, but these are as of writing not yet widely available.</p>
<p>Dynamically typed languages such as Python have very little ability to implement strong types without going against the principles of the language.
In recent versions, python has gained a facility called Type Hints which can provide some additional information to API users, but it isn&rsquo;t widely used, and isn&rsquo;t as complete a full type system in a language such as C++ or Java.</p>
<h1 id=why-does-it-matter>Why does it matter?<a hidden class=anchor aria-hidden=true href=#why-does-it-matter>#</a></h1>
<p>So why do these design choices matter?
They matter because they change the quality attributes of our designs.
As we chose between strong types and robust types, we make decisions that impact the maintainability, usability, and modifiability of our designs.
Thinking carefully through these trade-offs will improve our designs.</p>
<p>Hope this helps!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/software-engineering.html>Software Engineering</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html>
<span class=title>« Prev</span>
<br>
<span>Spack: a Truly Useful Package Manager</span>
</a>
<a class=next href=http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html>
<span class=title>Next »</span>
<br>
<span>Julia: Could There be One Language?</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>