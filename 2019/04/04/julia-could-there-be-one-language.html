<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Julia: Could There be One Language? | systems++</title>
<meta name=keywords content="Julia,programming">
<meta name=description content="There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn&rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn&rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn&rsquo;t always Generic in the sense that Python is.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Julia: Could There be One Language?">
<meta property="og:description" content="There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn&rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn&rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn&rsquo;t always Generic in the sense that Python is.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-04-04T09:00:00-05:00">
<meta property="article:modified_time" content="2019-04-04T09:00:00-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Julia: Could There be One Language?">
<meta name=twitter:description content="There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn&rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn&rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn&rsquo;t always Generic in the sense that Python is.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Julia: Could There be One Language?","item":"http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Julia: Could There be One Language?","name":"Julia: Could There be One Language?","description":"There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn\u0026rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn\u0026rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn\u0026rsquo;t always Generic in the sense that Python is.","keywords":["Julia","programming"],"articleBody":"There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn’t exactly easy to write. Code that is Generic and easy to write like Python isn’t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn’t always Generic in the sense that Python is. There is a new language on the block – Julia – which strives to challenge these assumptions. In the remainder of this post, I highlight what I like about it and describe my experience using it over the last semester.\nThe Good Complexity when you want it, but fast by default A friend of mine recently wanted to write this python, but was surprised when it was slow:\nfrom collections import defaultdict import numpy as np import timeit data = (np.random.rand(1000000, 40) * 100).astype(np.int) rows,cols = data.shape def locs(data): locs = defaultdict(list) for row in range(rows): for col in range(cols): locs[data[row,col]].append((row,col)) return locs print(timeit.timeit('locs(data)', globals=globals(), number=1), \"seconds\") I thought to myself, I could make that run faster in c++:\n#include #include #include #include #include  class Matrix{ public: Matrix(int x, int y): values(x*y), shape(std::make_pair(x,y)) {} int get(int x, int y) const {return values.at(x + shape.first*y);} void set(int x, int y, int value) { values.at(x + shape.first*y) = value;} std::pairint,int size() const {return shape;} private: std::vectorint values; const std::pairint,int shape; }; std::unordered_mapint, std::vectorstd::pairint,int locs(Matrix const\u0026 data) { std::unordered_mapint, std::vectorstd::pairint,int locs; auto shape = data.size(); for (int i = 0; i  shape.first; ++i) { for (int j = 0; j  shape.second; ++j) { auto value = data.get(i,j); locs[value].emplace_back(i,j); } } return locs; } int main(int argc, char *argv[]) { Matrix data(1000000, 40); std::default_random_engine eng; std::uniform_int_distributionint dist{1,100}; auto rand = [\u0026]{ return dist(eng); }; auto shape = data.size(); for (int i = 0; i  shape.first; ++i) { for (int j = 0; j  shape.second; ++j) { data.set(i,j, rand()); } } auto begin = std::chrono::high_resolution_clock::now(); locs(data); auto end = std::chrono::high_resolution_clock::now(); std::cout  std::chrono::duration_caststd::chrono::milliseconds(end-begin).count()/1000.0  std::endl; return 0; } But as you can see this isn’t the most readable code, and I’ve had to re-implement a 2D Matrix class to make the code as readable as this is. My friend who knows python probably wouldn’t have been able to write this.\nSo I decided to explore Julia as an option:\nmodule Locs import DataStructures #slowest function find_locs_generic(A) locs = DataStructures.DefaultDict(() - Vector()) rows, cols = size(A) for i = 1:rows for j = 1:cols push!(locs[A[i,j]], (i,j)) end end locs end #faster function find_locs_partial(A::AbstractArray{T,2}) where {T} locs = DataStructures.DefaultDict(() - Vector{Tuple{Int,Int}}()) rows, cols = size(A) for i = 1:rows for j = 1:cols push!(locs[A[i,j]], (i,j)) end end locs end #fastest function find_locs_full(A::AbstractArray{T,2}) where {T} locs = DataStructures.DefaultDict{T, Vector{Tuple{Int, Int}}}( () - Vector{Tuple{Int,Int}}() ) rows, cols = size(A) for i = 1:rows for j = 1:cols push!(locs[A[i,j]], (i,j)) end end locs end data = rand(1:100, 1000000, 40) macro benchmark(exp) quote println($exp) local val = @time $(esc(exp))(data) val end end @benchmark find_locs_generic @benchmark find_locs_partial @benchmark find_locs_full end So how does Julia stack up? I’m pretty sure my friend could have written the slowest version fairly quickly. I could have helped them add the type annotations in a few minutes to get it to the last version.\nI ran some quick benchmark numbers on my machine:\n#python (9 lines of code) 14.683772362000127 seconds #julia (10 lines of code) Main.Locs.find_locs_generic 6.856236 seconds (80.11 M allocations: 2.282 GiB, 48.27% gc time) Main.Locs.find_locs_partial 2.661613 seconds (80.10 M allocations: 1.989 GiB, 12.73% gc time) Main.Locs.find_locs_full 1.364066 seconds (40.26 M allocations: 823.874 MiB, 11.68% gc time) #C++ (26 lines of code, algorithm 13) 0.548 seconds As you can tell, even the slowest version of julia is twice as fast as Python. Yes, we probably could have gotten the python faster using something like numbra, but that’s not what they are familiar with and wasn’t packaged for their distribution. There looks like there is still some room for C++ for the absolutely performance critical applications, but Julia strikes a remarkable balance between being fast and easy to write.\nPowerful features Julia has a few very powerful features that make it a true developer’s language.\nThe first is static multiple dispatch. Multiple dispatch allows a function call to dispatch based on all types in the function signature. This might seem like a small feature, but it allows for a incredibly robust programming model. It completely obviates the need for object oriented programming while also eliminating the need for some of the more complicated object oriented patterns such as visitor pattern.\nadd(x::Integer, y::Integer) = println(\"int int \", x+y) add(x::Integer, y::AbstractFloat) = println(\"int float \", x+y) add(x::AbstractFloat, y::AbstractFloat) = println(\"float float \", x+y) add(x::AbstractFloat, y::Integer) = println(\"float int \", x+y) The second is functions as a first class citizens in the type system. This allows a robust functional style programing style when it makes sense such as for data oriented processing code. Combined with multiple dispatch and by-default generic typing, this almost completely eliminates the need for many of the traditional gang of four patterns making it a surprisingly productive language.\nfunction mymap(func, list) results = [] for i in list push!(results, func(i)) end results end The third is Julia’s sophisticated user-defined type promotion system. This allows the user to quickly make adaptations when a type does not conform to the interfaces provided by some library author. It also means that any type can utilize the rich promotion facilities allowed by the language and standard library so even a average developer can modify core classes if needed. Look at the promotion.jl file to see how this works.\nMacros are the final and perhaps most power feature that I’ll highlight. These are not textual macros in the style of C, but rather object oriented macros in the style of Lisp. This allows the average developer to make extensions to the compiler or add feature to the language. The developers often brag that these features allow them to implement most of Julia in Julia itself with a concise syntax. There is (admittedly simple) example of this above that does the benchmarking of the julia code printing out the method name of the method passed in.\nPackaging System Julia’s packaging system takes the best from modern package managers like golang and rust. It accomplishes this with a few neat tricks:\n It uses git as a package manager like golang. This makes distributing julia packages really easy. This particular features is a blessing and a curse; there is a lot of garbage out there. But it also means that its pretty simple to get started which encourages future developments as people scratch their own itches. It internally stores a commit hash for every library that is installed in the current environment so it is trivial to reproduce a package set installed on someone else’s computer making reproducing bugs easy. Unlike python and ruby it only stores exactly one copy of each version of each library that you have installed. This makes it easy to have different versions where it is needed, but save space where it is possible.  Best in Class Packages Julia has a number of excellent packages that I would say challenge the packages that I use on a regular basis. For example, Plots.jl is what I wanted Matplotlib to be. More builtin types just work with plot and the names of arguments are in my opinion easier to remember and use. Other great packages include OnlineStats and JuliaDB which allow for distributed massive statistics applications. It also has great packages for machine learning such as Flux and differential equations DifferentialEquations.\nReally Good Interoperability with Other Languages Julia has more interop packages than any other language that I’ve ever used. Several of them are quite good including PyCall, RCall, JavaCall. This allows you to use packages that you know and are familiar with without having to learn something new right away or if it doesn’t exist.\nThe Bad Matlabisms Julia does have a number of matlabisms the most annoying of which is that container indexes begin at 1. This also shows itself in the name of several function names, the use of ^ for exponentiation rather than **, and the whitespace is used to separate array literals. None of these Matlabisms disqualify it in my opinion, but explain some of the more annoying syntactical quirks of the language.\nRelative Maturity of Packages Julia is a new language, and that means that the libraries that support it are also immature. For example the Cxx package for c++ foreign function calls still doesn’t compile on the stable release of the language. Other examples include the Clustering library which uses rows for features rather than columns unlike almost every other machine learning library I’ve ever used. I’m confident that both of these will be fixed soon. There are GitHub issues open about both of these problems which are actively worked on.\nThis is largely ameliorated by the vast array of high quality interop packages that allow you to pull libraries from other languages while they are being ported to Julia natively.\nThe Ugly The absolute worst aspect of Julia is the ability to discover packages.\nRight now – just after the 1.0 release – there are a number of packages that are broadly recommended (including at time of writing Cxx an amazing best in class C++ wrapper) but no longer compile on the latest release. Allegedly, this should get better now that Julia has made a stable release. However, only will time will tell on this issue.\nIts also not clear to determine what package to use at any given time. The Julia Observatory is a graveyard to packages that were highly used on previous releases, but have been abandoned since the 1.0 or even in some cases 0.6 release in favor of newer less discoverable packages. A clear example of that of this would be the Debuggger. Now there is a great package called Debugger that works super well, but if you search for debuggers you will find Gallium or ASTInterpreter2 which don’t really work for the 1.0 release.\nThere is a similar problem with determining which function to use. Let’s say you want to generate interpreter-like printing output of some datatype. So you search for print in the help menu and you find the builtin function, but it’s not clear which print you are looking for. You can find it if you follow the hint that print calls show. show has two overloads, one that takes a mime-type and one that doesn’t, but even it doesn’t print exactly like the repl. What does that is repr, but only if the MIME type passed in is text/plain which is documented only in the repr help page. This is further confused by the difference between show(stdout, \"text/plain\", [1 2; 3 4]) and show(stdout, [1 2; 3 4]) which is supposed to use a default argument of text/plain according to the docs. These kinds of bumps appear in a surprising number of places in the language. Again, this is not to say that these bumps won’t be ironed out, but they do exist.\nConclusion So could there only be one? Maybe. Julia is the first language that I’ve encountered in a while that I’ve decided to learn in my own time. With recent developments like a full featured Debugger, it has me interested enough to keep using it. Hope this helps!\nHappy Programming!\n","wordCount":"1922","inLanguage":"en","datePublished":"2019-04-04T09:00:00-05:00","dateModified":"2019-04-04T09:00:00-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Julia: Could There be One Language?
</h1>
<div class=post-meta><span title="2019-04-04 09:00:00 -0500 -0500">April 4, 2019</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1922 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#the-good>The Good</a>
<ul>
<li><a href=#complexity-when-you-want-it-but-fast-by-default>Complexity when you want it, but fast by default</a></li>
<li><a href=#powerful-features>Powerful features</a></li>
<li><a href=#packaging-system>Packaging System</a></li>
<li><a href=#best-in-class-packages>Best in Class Packages</a></li>
<li><a href=#really-good-interoperability-with-other-languages>Really Good Interoperability with Other Languages</a></li>
</ul>
</li>
<li><a href=#the-bad>The Bad</a>
<ul>
<li><a href=#matlabisms>Matlabisms</a></li>
<li><a href=#relative-maturity-of-packages>Relative Maturity of Packages</a></li>
</ul>
</li>
<li><a href=#the-ugly>The Ugly</a></li>
<li><a href=#conclusion>Conclusion</a></li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>There is a constant problem with programming language design: fast, generic, easy to write; pick two.
The principle is that programming languages cannot be all three at once.
Code that is Fast and Generic like C++ isn&rsquo;t exactly easy to write.
Code that is Generic and easy to write like Python isn&rsquo;t always fast in the sense that C/C++ programmers mean it.
Code that is Fast and Easy to Write isn&rsquo;t always Generic in the sense that Python is.
There is a new language on the block &ndash; Julia &ndash; which strives to challenge these assumptions.
In the remainder of this post, I highlight what I like about it and describe my experience using it over the last semester.</p>
<h1 id=the-good>The Good<a hidden class=anchor aria-hidden=true href=#the-good>#</a></h1>
<h2 id=complexity-when-you-want-it-but-fast-by-default>Complexity when you want it, but fast by default<a hidden class=anchor aria-hidden=true href=#complexity-when-you-want-it-but-fast-by-default>#</a></h2>
<p>A friend of mine recently wanted to write this python, but was surprised when it was slow:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
<span class=kn>import</span> <span class=nn>timeit</span>

<span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>rand</span><span class=p>(</span><span class=mi>1000000</span><span class=p>,</span> <span class=mi>40</span><span class=p>)</span> <span class=o>*</span> <span class=mi>100</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>int</span><span class=p>)</span>
<span class=n>rows</span><span class=p>,</span><span class=n>cols</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>shape</span>

<span class=k>def</span> <span class=nf>locs</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
    <span class=n>locs</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>rows</span><span class=p>):</span>
        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>cols</span><span class=p>):</span>
            <span class=n>locs</span><span class=p>[</span><span class=n>data</span><span class=p>[</span><span class=n>row</span><span class=p>,</span><span class=n>col</span><span class=p>]]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>row</span><span class=p>,</span><span class=n>col</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>locs</span>

<span class=nb>print</span><span class=p>(</span><span class=n>timeit</span><span class=o>.</span><span class=n>timeit</span><span class=p>(</span><span class=s1>&#39;locs(data)&#39;</span><span class=p>,</span> <span class=nb>globals</span><span class=o>=</span><span class=nb>globals</span><span class=p>(),</span> <span class=n>number</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span> <span class=s2>&#34;seconds&#34;</span><span class=p>)</span>
</code></pre></div><p>I thought to myself, I could make that run faster in c++:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;random&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unordered_map&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;chrono&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=k>class</span> <span class=nc>Matrix</span><span class=p>{</span>
  <span class=k>public</span><span class=o>:</span>
  <span class=n>Matrix</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span> <span class=n>values</span><span class=p>(</span><span class=n>x</span><span class=o>*</span><span class=n>y</span><span class=p>),</span> <span class=n>shape</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>))</span> <span class=p>{}</span>
  <span class=kt>int</span> <span class=nf>get</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>values</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>shape</span><span class=p>.</span><span class=n>first</span><span class=o>*</span><span class=n>y</span><span class=p>);}</span>
  <span class=kt>void</span> <span class=nf>set</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=n>values</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>shape</span><span class=p>.</span><span class=n>first</span><span class=o>*</span><span class=n>y</span><span class=p>)</span> <span class=o>=</span> <span class=n>value</span><span class=p>;}</span>
  <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span><span class=k>return</span> <span class=n>shape</span><span class=p>;}</span>

  <span class=k>private</span><span class=o>:</span>
  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>values</span><span class=p>;</span>
  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>shape</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;&gt;&gt;</span>
<span class=n>locs</span><span class=p>(</span><span class=n>Matrix</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>)</span>
<span class=p>{</span>
  <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;&gt;&gt;</span> <span class=n>locs</span><span class=p>;</span>
  <span class=k>auto</span> <span class=n>shape</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>shape</span><span class=p>.</span><span class=n>first</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>shape</span><span class=p>.</span><span class=n>second</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
      <span class=n>locs</span><span class=p>[</span><span class=n>value</span><span class=p>].</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=n>locs</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
<span class=p>{</span>
  <span class=n>Matrix</span> <span class=n>data</span><span class=p>(</span><span class=mi>1000000</span><span class=p>,</span> <span class=mi>40</span><span class=p>);</span>
  <span class=n>std</span><span class=o>::</span><span class=n>default_random_engine</span> <span class=n>eng</span><span class=p>;</span>
  <span class=n>std</span><span class=o>::</span><span class=n>uniform_int_distribution</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dist</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>100</span><span class=p>};</span>
  <span class=k>auto</span> <span class=n>rand</span> <span class=o>=</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>]{</span> <span class=k>return</span> <span class=n>dist</span><span class=p>(</span><span class=n>eng</span><span class=p>);</span> <span class=p>};</span>

  <span class=k>auto</span> <span class=n>shape</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>shape</span><span class=p>.</span><span class=n>first</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>shape</span><span class=p>.</span><span class=n>second</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>data</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>,</span> <span class=n>rand</span><span class=p>());</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>auto</span> <span class=n>begin</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>high_resolution_clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>
  <span class=n>locs</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>end</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>high_resolution_clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>

  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>duration_cast</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=n>milliseconds</span><span class=o>&gt;</span><span class=p>(</span><span class=n>end</span><span class=o>-</span><span class=n>begin</span><span class=p>).</span><span class=n>count</span><span class=p>()</span><span class=o>/</span><span class=mf>1000.0</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>But as you can see this isn&rsquo;t the most readable code, and I&rsquo;ve had to re-implement a 2D Matrix class to make the code as readable as this is. My friend who knows python probably wouldn&rsquo;t have been able to write this.</p>
<p>So I decided to explore Julia as an option:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=k>module</span> <span class=n>Locs</span>

<span class=k>import</span> <span class=n>DataStructures</span>
<span class=c>#slowest</span>
<span class=k>function</span> <span class=n>find_locs_generic</span><span class=p>(</span><span class=n>A</span><span class=p>)</span>
  <span class=n>locs</span> <span class=o>=</span> <span class=n>DataStructures</span><span class=o>.</span><span class=n>DefaultDict</span><span class=p>(()</span> <span class=o>-&gt;</span> <span class=kt>Vector</span><span class=p>())</span>
  <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span> <span class=o>=</span> <span class=n>size</span><span class=p>(</span><span class=n>A</span><span class=p>)</span>
  <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>:</span><span class=n>rows</span>
    <span class=k>for</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=o>:</span><span class=n>cols</span>
      <span class=n>push!</span><span class=p>(</span><span class=n>locs</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]],</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>))</span>
    <span class=k>end</span>
  <span class=k>end</span>
  <span class=n>locs</span>
<span class=k>end</span>


<span class=c>#faster</span>
<span class=k>function</span> <span class=n>find_locs_partial</span><span class=p>(</span><span class=n>A</span><span class=o>::</span><span class=kt>AbstractArray</span><span class=p>{</span><span class=kt>T</span><span class=p>,</span><span class=mi>2</span><span class=p>})</span> <span class=k>where</span> <span class=p>{</span><span class=kt>T</span><span class=p>}</span>
  <span class=n>locs</span> <span class=o>=</span> <span class=n>DataStructures</span><span class=o>.</span><span class=n>DefaultDict</span><span class=p>(()</span> <span class=o>-&gt;</span> <span class=kt>Vector</span><span class=p>{</span><span class=kt>Tuple</span><span class=p>{</span><span class=kt>Int</span><span class=p>,</span><span class=kt>Int</span><span class=p>}}())</span>
  <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span> <span class=o>=</span> <span class=n>size</span><span class=p>(</span><span class=n>A</span><span class=p>)</span>
  <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>:</span><span class=n>rows</span>
    <span class=k>for</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=o>:</span><span class=n>cols</span>
      <span class=n>push!</span><span class=p>(</span><span class=n>locs</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]],</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>))</span>
    <span class=k>end</span>
  <span class=k>end</span>
  <span class=n>locs</span>
<span class=k>end</span>

<span class=c>#fastest</span>
<span class=k>function</span> <span class=n>find_locs_full</span><span class=p>(</span><span class=n>A</span><span class=o>::</span><span class=kt>AbstractArray</span><span class=p>{</span><span class=kt>T</span><span class=p>,</span><span class=mi>2</span><span class=p>})</span> <span class=k>where</span> <span class=p>{</span><span class=kt>T</span><span class=p>}</span>
  <span class=n>locs</span> <span class=o>=</span> <span class=n>DataStructures</span><span class=o>.</span><span class=kt>DefaultDict</span><span class=p>{</span><span class=kt>T</span><span class=p>,</span> <span class=kt>Vector</span><span class=p>{</span><span class=kt>Tuple</span><span class=p>{</span><span class=kt>Int</span><span class=p>,</span> <span class=kt>Int</span><span class=p>}}}(</span>
    <span class=p>()</span> <span class=o>-&gt;</span> <span class=kt>Vector</span><span class=p>{</span><span class=kt>Tuple</span><span class=p>{</span><span class=kt>Int</span><span class=p>,</span><span class=kt>Int</span><span class=p>}}()</span>
  <span class=p>)</span>
  <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span> <span class=o>=</span> <span class=n>size</span><span class=p>(</span><span class=n>A</span><span class=p>)</span>
  <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>:</span><span class=n>rows</span>
    <span class=k>for</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=o>:</span><span class=n>cols</span>
      <span class=n>push!</span><span class=p>(</span><span class=n>locs</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]],</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>))</span>
    <span class=k>end</span>
  <span class=k>end</span>
  <span class=n>locs</span>
<span class=k>end</span>


<span class=n>data</span> <span class=o>=</span> <span class=n>rand</span><span class=p>(</span><span class=mi>1</span><span class=o>:</span><span class=mi>100</span><span class=p>,</span> <span class=mi>1000000</span><span class=p>,</span> <span class=mi>40</span><span class=p>)</span>

<span class=k>macro</span> <span class=n>benchmark</span><span class=p>(</span><span class=n>exp</span><span class=p>)</span>
  <span class=k>quote</span>
    <span class=n>println</span><span class=p>(</span><span class=o>$</span><span class=n>exp</span><span class=p>)</span>
    <span class=k>local</span> <span class=n>val</span> <span class=o>=</span> <span class=nd>@time</span> <span class=o>$</span><span class=p>(</span><span class=n>esc</span><span class=p>(</span><span class=n>exp</span><span class=p>))(</span><span class=n>data</span><span class=p>)</span>
    <span class=n>val</span>
  <span class=k>end</span>
<span class=k>end</span>

<span class=nd>@benchmark</span> <span class=n>find_locs_generic</span>
<span class=nd>@benchmark</span> <span class=n>find_locs_partial</span>
<span class=nd>@benchmark</span> <span class=n>find_locs_full</span>
<span class=k>end</span>
</code></pre></div><p>So how does Julia stack up? I&rsquo;m pretty sure my friend could have written the slowest version fairly quickly. I could have helped them add the type annotations in a few minutes to get it to the last version.</p>
<p>I ran some quick benchmark numbers on my machine:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>#python (9 lines of code)
14.683772362000127 seconds

#julia (10 lines of code)
Main.Locs.find_locs_generic
  6.856236 seconds (80.11 M allocations: 2.282 GiB, 48.27% gc time)
Main.Locs.find_locs_partial
  2.661613 seconds (80.10 M allocations: 1.989 GiB, 12.73% gc time)
Main.Locs.find_locs_full
  1.364066 seconds (40.26 M allocations: 823.874 MiB, 11.68% gc time)

#C++ (26 lines of code, algorithm 13)
	0.548 seconds

</code></pre></div><p>As you can tell, even the slowest version of julia is twice as fast as Python. Yes, we probably could have gotten the python faster using something like numbra, but that&rsquo;s not what they are familiar with and wasn&rsquo;t packaged for their distribution. There looks like there is still some room for C++ for the absolutely performance critical applications, but Julia strikes a remarkable balance between being fast and easy to write.</p>
<h2 id=powerful-features>Powerful features<a hidden class=anchor aria-hidden=true href=#powerful-features>#</a></h2>
<p>Julia has a few very powerful features that make it a true developer&rsquo;s language.</p>
<p>The first is static multiple dispatch. Multiple dispatch allows a function call to dispatch based on all types in the function signature. This might seem like a small feature, but it allows for a incredibly robust programming model. It completely obviates the need for object oriented programming while also eliminating the need for some of the more complicated object oriented patterns such as visitor pattern.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>add(x::Integer, y::Integer) = println(&#34;int int &#34;, x+y)
add(x::Integer, y::AbstractFloat) = println(&#34;int float &#34;, x+y)
add(x::AbstractFloat, y::AbstractFloat) = println(&#34;float float &#34;, x+y)
add(x::AbstractFloat, y::Integer) = println(&#34;float int &#34;, x+y)
</code></pre></div><p>The second is functions as a first class citizens in the type system. This allows a robust functional style programing style when it makes sense such as for data oriented processing code. Combined with multiple dispatch and by-default generic typing, this almost completely eliminates the need for many of the traditional gang of four patterns making it a surprisingly productive language.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-julia data-lang=julia><span class=k>function</span> <span class=n>mymap</span><span class=p>(</span><span class=n>func</span><span class=p>,</span> <span class=n>list</span><span class=p>)</span>
  <span class=n>results</span> <span class=o>=</span> <span class=p>[]</span>
  <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=n>list</span>
    <span class=n>push!</span><span class=p>(</span><span class=n>results</span><span class=p>,</span> <span class=n>func</span><span class=p>(</span><span class=n>i</span><span class=p>))</span>
  <span class=k>end</span>
  <span class=n>results</span>
<span class=k>end</span>
</code></pre></div><p>The third is Julia&rsquo;s sophisticated user-defined type promotion system. This allows the user to quickly make adaptations when a type does not conform to the interfaces provided by some library author. It also means that any type can utilize the rich promotion facilities allowed by the language and standard library so even a average developer can modify core classes if needed. Look at the promotion.jl file to see how this works.</p>
<p>Macros are the final and perhaps most power feature that I&rsquo;ll highlight. These are not textual macros in the style of C, but rather object oriented macros in the style of Lisp. This allows the average developer to make extensions to the compiler or add feature to the language. The developers often brag that these features allow them to implement most of Julia in Julia itself with a concise syntax. There is (admittedly simple) example of this above that does the benchmarking of the julia code printing out the method name of the method passed in.</p>
<h2 id=packaging-system>Packaging System<a hidden class=anchor aria-hidden=true href=#packaging-system>#</a></h2>
<p>Julia&rsquo;s packaging system takes the best from modern package managers like golang and rust. It accomplishes this with a few neat tricks:</p>
<ol>
<li>It uses git as a package manager like golang. This makes distributing julia packages really easy. This particular features is a blessing and a curse; there is a lot of garbage out there. But it also means that its pretty simple to get started which encourages future developments as people scratch their own itches.</li>
<li>It internally stores a commit hash for every library that is installed in the current environment so it is trivial to reproduce a package set installed on someone else&rsquo;s computer making reproducing bugs easy.</li>
<li>Unlike python and ruby it only stores exactly one copy of each version of each library that you have installed. This makes it easy to have different versions where it is needed, but save space where it is possible.</li>
</ol>
<h2 id=best-in-class-packages>Best in Class Packages<a hidden class=anchor aria-hidden=true href=#best-in-class-packages>#</a></h2>
<p>Julia has a number of excellent packages that I would say challenge the packages that I use on a regular basis.
For example, <code>Plots.jl</code> is what I wanted Matplotlib to be. More builtin types just work with <code>plot</code> and the names of arguments are in my opinion easier to remember and use.
Other great packages include <code>OnlineStats</code> and <code>JuliaDB</code> which allow for distributed massive statistics applications.
It also has great packages for machine learning such as <code>Flux</code> and differential equations <code>DifferentialEquations</code>.</p>
<h2 id=really-good-interoperability-with-other-languages>Really Good Interoperability with Other Languages<a hidden class=anchor aria-hidden=true href=#really-good-interoperability-with-other-languages>#</a></h2>
<p>Julia has more interop packages than any other language that I&rsquo;ve ever used. Several of them are quite good including <code>PyCall</code>, <code>RCall</code>, <code>JavaCall</code>.
This allows you to use packages that you know and are familiar with without having to learn something new right away or if it doesn&rsquo;t exist.</p>
<h1 id=the-bad>The Bad<a hidden class=anchor aria-hidden=true href=#the-bad>#</a></h1>
<h2 id=matlabisms>Matlabisms<a hidden class=anchor aria-hidden=true href=#matlabisms>#</a></h2>
<p>Julia does have a number of matlabisms the most annoying of which is that container indexes begin at 1. This also shows itself in the name of several function names, the use of <code>^</code> for exponentiation rather than <code>**</code>, and the whitespace is used to separate array literals. None of these Matlabisms disqualify it in my opinion, but explain some of the more annoying syntactical quirks of the language.</p>
<h2 id=relative-maturity-of-packages>Relative Maturity of Packages<a hidden class=anchor aria-hidden=true href=#relative-maturity-of-packages>#</a></h2>
<p>Julia is a new language, and that means that the libraries that support it are also immature. For example the Cxx package for c++ foreign function calls still doesn&rsquo;t compile on the stable release of the language. Other examples include the <code>Clustering</code> library which uses rows for features rather than columns unlike almost every other machine learning library I&rsquo;ve ever used. I&rsquo;m confident that both of these will be fixed soon. There are GitHub issues open about both of these problems which are actively worked on.</p>
<p>This is largely ameliorated by the vast array of high quality interop packages that allow you to pull libraries from other languages while they are being ported to Julia natively.</p>
<h1 id=the-ugly>The Ugly<a hidden class=anchor aria-hidden=true href=#the-ugly>#</a></h1>
<p>The absolute worst aspect of Julia is the ability to discover packages.</p>
<p>Right now &ndash; just after the 1.0 release &ndash; there are a number of packages that are broadly recommended (including at time of writing <code>Cxx</code> an amazing best in class C++ wrapper) but no longer compile on the latest release.
Allegedly, this should get better now that Julia has made a stable release.
However, only will time will tell on this issue.</p>
<p>Its also not clear to determine what package to use at any given time.
The Julia Observatory is a graveyard to packages that were highly used on previous releases, but have been abandoned since the 1.0 or even in some cases 0.6 release in favor of newer less discoverable packages.
A clear example of that of this would be the Debuggger. Now there is a great package called <code>Debugger</code> that works super well, but if you search for debuggers you will find <code>Gallium</code> or <code>ASTInterpreter2</code> which don&rsquo;t really work for the 1.0 release.</p>
<p>There is a similar problem with determining which function to use.
Let&rsquo;s say you want to generate interpreter-like printing output of some datatype.
So you search for <code>print</code> in the help menu and you find the builtin function, but it&rsquo;s not clear which <code>print</code> you are looking for. You can find it if you follow the hint that <code>print</code> calls <code>show</code>. <code>show</code> has two overloads, one that takes a mime-type and one that doesn&rsquo;t, but even it doesn&rsquo;t print exactly like the repl. What does that is <code>repr</code>, but only if the MIME type passed in is <code>text/plain</code> which is documented only in the <code>repr</code> help page. This is further confused by the difference between <code>show(stdout, "text/plain", [1 2; 3 4])</code> and <code>show(stdout, [1 2; 3 4])</code> which is supposed to use a default argument of <code>text/plain</code> according to the docs.
These kinds of bumps appear in a surprising number of places in the language.
Again, this is not to say that these bumps won&rsquo;t be ironed out, but they do exist.</p>
<h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1>
<p>So could there only be one? Maybe. Julia is the first language that I&rsquo;ve encountered in a while that I&rsquo;ve decided to learn in my own time. With recent developments like a full featured Debugger, it has me interested enough to keep using it. Hope this helps!</p>
<p>Happy Programming!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/julia.html>Julia</a></li>
<li><a href=http://robertu94.github.io/tags/programming.html>Programming</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2019/11/17/strong-or-robust.html>
<span class=title>« Prev</span>
<br>
<span>Strong or Robust?</span>
</a>
<a class=next href=http://robertu94.github.io/2018/07/31/configuration-management-common-pitfalls.html>
<span class=title>Next »</span>
<br>
<span>Configuration Management: Common Pitfalls</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>