<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>systems++</title><link>http://robertu94.github.io/</link><description>Recent content on systems++</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 12 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://robertu94.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>What to support if you are supporting</title><link>http://robertu94.github.io/guides/dependencies.html</link><pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/dependencies.html</guid><description>Dependencies matter a lot in terms of who can easily install and use your software. However there are trade-offs in what features are provided by each version and the availability of these versions. This presents an opinionated take on what these trade-offs are so one can know what can be widely supported.
Last update: 2023-09-12
Major Linux Distros Distro Standard EoL CentOS-7 compatible July 2024 CentOS-8 compatible December 2021* CentOS-8 stream May 2024 CentOS-9 stream May 2027* Ubuntu 16.</description></item><item><title>Dethroning LaTeX: What Would It Take?</title><link>http://robertu94.github.io/2023/07/02/dethroning-latex-what-would-it-take.html</link><pubDate>Sun, 02 Jul 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/07/02/dethroning-latex-what-would-it-take.html</guid><description>As an academic, you write a lot of papers. If you contribute to the disciplines of Math, Computer Science, or some domains of physical sciences, you&amp;rsquo;ve probably used LaTeX &amp;ndash; a typesetting language &amp;ndash; through a tool like Overleaf. What&amp;rsquo;s nice about LaTeX is that it attempts to separate concerns: Authors with minimal effort can port the text and structure of a document from one style to another. It generally produces much more ascetically pleasing output by default than what most authors would do on their own.</description></item><item><title>Spack on Ubuntu 20.04</title><link>http://robertu94.github.io/guides/ubuntu.html</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/ubuntu.html</guid><description>Spack installations can be really slow on some platforms, however, there are pre-built packages for ubuntu 20.04
sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt update apt install gcc-11 spack mirror add spack-build-cache-develop https://binaries.spack.io/develop spack buildcache keys --install --trust And now you have spack pre-compiled goodness for your packages!
You can see the spack cache index for details for what packages are pre-built for which platforms.</description></item><item><title>How I Work: Killer Libraries</title><link>http://robertu94.github.io/2023/04/24/how-i-work-killer-libraries.html</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/04/24/how-i-work-killer-libraries.html</guid><description>Most successful langauges have a &amp;ldquo;killer&amp;rdquo; features that motivates
In my previous post, I commented on the tools that I use for software development, but I didn&amp;rsquo;t talk about either the process of choosing a language or the libraries within a language that I use most frequently. This post expands on how I work within a language and specific &amp;ldquo;killer&amp;rdquo; libraries that I use most and how they compare to facililties that I know from other languages.</description></item><item><title>Refactoring CI/CD for a Moderately Large C++ Code Base</title><link>http://robertu94.github.io/2023/04/24/refactoring-ci/cd-for-a-moderately-large-c-code-base.html</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/04/24/refactoring-ci/cd-for-a-moderately-large-c-code-base.html</guid><description>CI/CD is a critical, but difficult to get right part of software engineering. You often want to test multiple distributions, multiple compilers on each commit, and you want that to be as fast as reasonably possible. This gets more complicated when you have large dependency trees that you want to remain consistent. Recently, I adapted the CI/CD system for a project that I maintain LibPressio to use Dagger &amp;ndash; a programmatic way to do CI/CD portable-ally across runner environments which made it easier to run our tests and verify correctness.</description></item><item><title>How I work: The Tools I Use</title><link>http://robertu94.github.io/2023/03/14/how-i-work-the-tools-i-use.html</link><pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/03/14/how-i-work-the-tools-i-use.html</guid><description>From time to time I get a question of what tools I use for what jobs. Here the tools I use to get things done:
Language Specific Purpose C++ Python Julia Rust Compiler/Interpeter gcc/clang python:quick,ipython:long julia rustc,cargo Profiler perf/FlameGraphs + perftrace cprofile:function, line_profiler:line BenchmarkTools.jl cargo Debugger GDB + mpigdb *c++, pdb *c++ Debugger.jl:default,Cathulu.jl:metaprogramming *c++ rust-gdb Build System CMake,(meson, bazel) + m ?</description></item><item><title>External Clang-Tidy Modules! C++ Refactoring for the Common Project</title><link>http://robertu94.github.io/2023/03/10/external-clang-tidy-modules-c-refactoring-for-the-common-project.html</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/03/10/external-clang-tidy-modules-c-refactoring-for-the-common-project.html</guid><description>Clang style refactoring has been something I&amp;rsquo;ve been admiring from afar for quite a while now. However for a user to actually use it, it has previously required forking llvm to be able to use it in a reasonable fashion because of things like the hack in clang used to locate the resource directory or other fragile hacks like LD_PRELOAD.
Recently, the Clang/LLVM developers vastly improved the situation by allowing loadable clang-tidy modules and by installing all of the headers that you actually need to do something with clang tidy, and they are finally packaged on both Fedora and Ubuntu!</description></item><item><title>Learning to Learn: Software Teams</title><link>http://robertu94.github.io/learning/software_for_teams.html</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/learning/software_for_teams.html</guid><description>Outside of school very seldom in software development will you completely work alone on a project. Leading and being an effective member of a software team will be critical to your success in this field. However each team and project is different. Some projects have a high iteration cost because testing could cause people to die (e.g. bugs in rocket guidance systems in manned space flight), testing could be lengthy (e.</description></item><item><title>Learning to Learn: Software Development on Linux</title><link>http://robertu94.github.io/learning/development.html</link><pubDate>Sun, 22 Jan 2023 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/development.html</guid><description>What is software development? At a most basic level, it is the activity of using a programming language to achieve some set of goals over time. It includes everything from scripts that a graduate student might write to analyze some data to massive systems that control aircraft. As our world continues to progress technically, software development will likely become even more commonplace than it is now. In this post, I aim to provide a comprehensive overview of how one can develop software efficiently using free and open source tools on Linux.</description></item><item><title>Learning to Learn: Task Management, Time Tracking, and Journaling</title><link>http://robertu94.github.io/learning/time.html</link><pubDate>Sun, 22 Jan 2023 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/time.html</guid><description>A few of the key things that you will need as you need as a professional are the ability to manage tasks, understand how you spend your time, and improve your own processes. For me and many others, journaling, task managers, and time trackers help you answer these important questions.
What is Journaling? Journaling is a reflective process which aims to capture tasks, observations, ideas, and lessons in order to be able to recall and learn from them.</description></item><item><title>Refactoring With Clang Query</title><link>http://robertu94.github.io/2022/12/28/refactoring-with-clang-query.html</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/28/refactoring-with-clang-query.html</guid><description>Have you ever wanted to identify a list of files that would need modifications to adopt a new API? Clang-Query can make this much easier. I recently wanted to introduce a set of helper functions to simplfy an aspect of compressor configuation in LibPressio. But first, I needed to know what modules were effected.
Clang-query needs a compilation database which can be produced by tools such as bear (if you have a Autotools or Makefile based project) or more sophisticated build systems such as cmake, meson or bazel.</description></item><item><title>Three Neat Things I Did With Julia</title><link>http://robertu94.github.io/2022/12/15/three-neat-things-i-did-with-julia.html</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/15/three-neat-things-i-did-with-julia.html</guid><description>In the past, I&amp;rsquo;ve written pretty glowingly about Julia. It&amp;rsquo;s been a few years since I first used Julia in 2019, and it hasn&amp;rsquo;t completely replaced Python for me. However, I wanted to share a few neat projects that I&amp;rsquo;ve done using it which would have been much more painful without it, and share what I think now about what I wrote in 2019.
Implementing a Statistical Metric on the GPU Being able to access heterogenous compute is important to be able to make the most of the availible hardware.</description></item><item><title>Debugging Inconsistent Network Performance</title><link>http://robertu94.github.io/2022/12/14/debugging-inconsistent-network-performance.html</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/14/debugging-inconsistent-network-performance.html</guid><description>High-performance network interconnects, such as Infiniband, are common in high performance computing environments. Recently, my colleagues, and I ran a series of experiments on the Cooley system at the Argonne Leadership Computing Facility. For one set of experiments, the network performance was consistent and fast, but for the others we periodically had poor performance. Up until this point in my work, I had not directly used or configured network libraries below this layer.</description></item><item><title>Learning to Learn: CMake</title><link>http://robertu94.github.io/learning/cmake.html</link><pubDate>Tue, 15 Nov 2022 05:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/cmake.html</guid><description>CMake is the de-facto C++ build system used by an overwhelming number of C++ projects. Even if you personally favor more modern alternatives such as Meson, Bazel, or Pants, if you ever pull in a 3rd party dependency, there is a good chance that it uses CMake so knowing enough about CMake to understand it is worth knowing.
How to get started I recommend new users to CMake start with the following resources:</description></item><item><title>Spack on Crusher</title><link>http://robertu94.github.io/guides/crusher.html</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/crusher.html</guid><description>tl;dr Put the following in your .bashrc
use_build() { if hostname | grep summit &amp;amp;&amp;gt;/dev/null; then echo &amp;#34;loading crusher spack&amp;#34; module swap PrgEnv-cray PrgEnv-gnu module load craype-accel-amd-gfx90a module load rocm export clustername=crusher fi #other OLCF Machines export SPACK_USER_CONFIG_PATH=&amp;#34;$HOME/.spack/$clustername&amp;#34; export SPACK_USER_CACHE_PATH=&amp;#34;$SPACK_USER_CONFIG_PATH&amp;#34; source $HOME/git/spack-crusher/share/spack/setup-env.sh source $HOME/git/spack-crusher/share/spack/spack-completion.bash } Then run
mkdir -p ~/git git clone https://github.com/spack/spack git/spack-crusher source ~/.bashrc spack compiler find First create packages.yaml at ~/.spack/crusher/packages.yaml with:
cmake:externals:- spec:cmake@3.17.0prefix:/usrall:providers:mpi:[cray-mpich]hdf5:externals:- spec:hdf5@1.12.2+mpi+shared+hlprefix:/opt/cray/pe/hdf5-parallel/1.12.1.5/gnu/9.1buildable:Falsecray-mpich:externals:- spec:cray-mpich@8.1.16modules:[cray-mpich/8.1.16, libfabric/1.15.0.0, craype-accel-amd-gfx90a, rocm/5.</description></item><item><title>Spack on Summit</title><link>http://robertu94.github.io/guides/summit.html</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/summit.html</guid><description>tl;dr Put the following in your .bashrc
use_build() { if hostname | grep summit &amp;amp;&amp;gt;/dev/null; then echo &amp;#34;loading summit spack&amp;#34; module load gcc/10.2.0 export clustername=summit fi #other OLCF Machines export SPACK_USER_CONFIG_PATH=&amp;#34;$HOME/.spack/$clustername&amp;#34; export SPACK_USER_CACHE_PATH=&amp;#34;$SPACK_USER_CONFIG_PATH&amp;#34; source $HOME/git/spack-summit/share/spack/setup-env.sh source $HOME/git/spack-summit/share/spack/spack-completion.bash } Then run
mkdir -p ~/git git clone https://github.com/spack/spack git/spack-summit source ~/.bashrc spack compiler find First create packages.yaml at ~/.spack/summit/packages.yaml with:
packages:all:providers:mpi:[spectrum-mpi]openssl:externals:- spec:openssl@1.1.1cprefix:/usrbuildable:Falseopenssh:externals:- spec:openssh@8.0p1prefix:/usrbuildable:Falsecuda:externals:- spec:cuda@11.0.221prefix:/sw/summit/cuda/11.0.3buildable:Falsespectrum-mpi:externals:- spec:spectrum-mpi@10.4.0.03rtm4prefix:/sw/summit/spack-envs/base/opt/linux-rhel8-ppc64le/gcc-10.2.0/spectrum-mpi-10.4.0.3-20210112-ht5bw4jruhjujvkzcvpra5lryg5vfhy4buildable:Falsetar:externals:- spec:tar@1.30prefix:/usrcvs:externals:- spec:cvs@1.11.23prefix:/usrdiffutils:externals:- spec:diffutils@3.6prefix:/usrgroff:externals:- spec:groff@1.22.3prefix:/usrbison:externals:- spec:bison@3.0.4prefix:/usrgawk:externals:- spec:gawk@4.2.1prefix:/usrpkgconf:externals:- spec:pkgconf@1.4.2prefix:/usrm4:externals:- spec:m4@1.</description></item><item><title>How to export a C API from a C++ code</title><link>http://robertu94.github.io/guides/exporting_c.html</link><pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/exporting_c.html</guid><description>tl;dr define a version of your API using only C compatible types in a header Do NOT include a C++ header in the transitive set of headers make the header compatible with C and C++ using #ifdef __cplusplus and extern &amp;quot;C&amp;quot; Why is this needed C++ is (mostly) a super set of C. If you want C++ to be callable from C, you need to stick to this subset for the declaring code and mark the functions as having a C ABI.</description></item><item><title>How to add a dependency in CMake</title><link>http://robertu94.github.io/guides/cmake_deps.html</link><pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/cmake_deps.html</guid><description>tl;dr Most of the time simply use find_package, set CMAKE_PREFIX_PATH to include the path specified in CMAKE_INSTALL_PREFIX when the package was installed like so:
find_package(std_compat REQUIRED)target_link_libraries(my_library PUBLIC std_compat::std_compat)Tools like spack will set CMAKE_PREFIX_PATH for you. Otherwise specify it using an envionment variable or with a -D flag to cmake.
How to add the dependency Adding a dependency in CMake is pretty straight forward, but depends on where it is coming from.</description></item><item><title>Suggestions for the Design of Computational Experiments</title><link>http://robertu94.github.io/learning/experiments.html</link><pubDate>Tue, 18 Oct 2022 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/experiments.html</guid><description>So you want to do empirical computer science? Doing good science is difficult. It requires discipline and attention to detail. However there are strategies that can help you focus on answering the questions you can attempt to answer. First you should ask, “is this a scientific question?” Not all questions are scientific questions. Questions about aesthetics, values, ethics are not science questions. “Is A better than B?” is not a scientific question, it’s a question of values.</description></item><item><title>Updating LibPressio with Spack</title><link>http://robertu94.github.io/guides/updating_libpressio_with_spack.html</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/updating_libpressio_with_spack.html</guid><description>#tl;dr
# set NEW_VERSION to the desired version cd $SPACK_ROOT git pull cd $(spack repo list | grep robertu94 | sed -E &amp;#39;s/robertu94[[:space:]]+//&amp;#39;) &amp;amp;&amp;amp; git pull spack install libpressio-tools ^libpressio${NEW_VERSION} spack load libpressio-tools ^libpressio${NEW_VERSION} libpressio is now Mainline LibPressio is now in the mainline version of spack (as of commit da6aeaad44e434da5563d32f2fa9900de362b2ed, October 17, 2022). You no longer need to add robertu94_packages unless you need a development version. You can either spack repo rm robertu94, or the next pull of robertu94_packages will include a dummy package to refer back to the builtin version.</description></item><item><title>Thoughts on Dependencies for Scientific Software</title><link>http://robertu94.github.io/2022/07/20/thoughts-on-dependencies-for-scientific-software.html</link><pubDate>Wed, 20 Jul 2022 00:00:00 -0500</pubDate><guid>http://robertu94.github.io/2022/07/20/thoughts-on-dependencies-for-scientific-software.html</guid><description>Modern software does not exist in a vacuum, developers always rely on other developers or engineers to provide aspects of their systems. Even if you write hello world in your programming language of your choice you likely still depend on the standard library from your language. Even if you were to write hello world in the raw binary format of your assembly language, you still depend on the operating system. Even if you wrote your own uni-kernel to produce hello world on the console, you likely rely on vendor provided firmware to initialize the program or memory.</description></item><item><title>Shortcut Guide for Configuring Spack for a New HPC System</title><link>http://robertu94.github.io/guides/spack.html</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/spack.html</guid><description>Setting up spack The way that I use spack, there are 6 major steps to configuring spack:
Determine what system compiler, python, and MPI you will use Telling spack how to find your compiler Telling spack find major system dependencies such as MPI and OpenSSL as external dependencies Configuring preferred providers for virtual dependencies and target architectures Configuring spack to use a binary cache if it will matter Setting up a shell shortcut for loading spack What system dependencies to use Spack does a pretty good job &amp;ldquo;living off the land&amp;rdquo; using what ever dependencies you may need.</description></item><item><title>Spack on Bebop</title><link>http://robertu94.github.io/guides/bebop.html</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/bebop.html</guid><description>tl;dr Put the following in your .bashrc
use_build() { if hostname | grep bebop &amp;amp;&amp;gt;/dev/null; then echo &amp;#34;loading bebop spack&amp;#34; module load gcc/10.2.0-z53hda3 module load intel-mpi/2019.10.317-qn674hj module load intel-mkl/2020.4.304 source $HOME/git/spack-bebop/share/spack/setup-env.sh source $HOME/git/spack-bebop/share/spack/spack-completion.bash export clustername=bebop fi #other LCRC Machines export SPACK_USER_CONFIG_PATH=&amp;#34;$HOME/.spack/$clustername&amp;#34; export SPACK_USER_CACHE_PATH=&amp;#34;$SPACK_USER_CONFIG_PATH&amp;#34; } Then run
mkdir -p ~/git git clone https://github.com/spack/spack git/spack-bebop git clone https://github.com/robertu94/spack_packages git/robertu94_packages source ~/.bashrc spack compiler find # for extra packages like libpressio spack repo add ~/git/robertu94_packages First create packages.</description></item><item><title>Spack on Cooley</title><link>http://robertu94.github.io/guides/cooley.html</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/cooley.html</guid><description>tl;dr Put the following in your .bashrc
function use_build { # other ALCF machines if hostname | grep cooley &amp;amp;&amp;gt;/dev/null || hostname | grep cc &amp;amp;&amp;gt; /dev/null; then soft add +gcc-8.2.0 soft add +cmake-3.20.4 soft add +cuda-11.0.2 soft add +mvapich2 source ${HOME}/git/spack-cooley/share/spack/setup-env.sh export clustername=cooley fi export SPACK_USER_CONFIG_PATH=&amp;#34;$HOME/.spack/$clustername&amp;#34; export SPACK_USER_CACHE_PATH=&amp;#34;$SPACK_USER_CONFIG_PATH&amp;#34; } Then run
mkdir -p ~/git git clone https://github.com/spack/spack git/spack-cooley git clone https://github.com/robertu94/spack_packages git/robertu94_packages source ~/.bashrc use_build spack compiler find # for extra packages like libpressio spack repo add ~/git/robertu94_packages First create packages.</description></item><item><title>Spack on Polaris</title><link>http://robertu94.github.io/guides/polaris.html</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/polaris.html</guid><description>tl;dr Put the following in your .bashrc
function use_build { # other ALCF machines if hostname -f | grep polaris &amp;amp;&amp;gt;/dev/null; then echo &amp;#34;loading polaris spack&amp;#34; module swap PrgEnv-nvhpc PrgEnv-gnu module load cudatoolkit-standalone source ${HOME}/git/spack-theta/share/spack/setup-env.sh export CRAYPE_LINK_TYPE=dynamic export clustername=polaris fi export SPACK_USER_CONFIG_PATH=&amp;#34;$HOME/.spack/$clustername&amp;#34; export SPACK_USER_CACHE_PATH=&amp;#34;$SPACK_USER_CONFIG_PATH&amp;#34; } Then run
mkdir -p ~/git git clone https://github.com/spack/spack git/spack-polaris git clone https://github.com/robertu94/spack_packages git/robertu94_packages git clone https://github.com/mochi-hpc/mochi-spack-packages git/mochi-spack-packages source ~/.bashrc use_build spack compiler find # for extra packages like libpressio and thallium spack repo add ~/git/robertu94_packages spack repo add ~/git/mochi-spack-packages First create packages.</description></item><item><title>Spack on Theta</title><link>http://robertu94.github.io/guides/theta.html</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/guides/theta.html</guid><description>tl;dr Put the following in your .bashrc
function use_build { # other ALCF machines if hostname | grep theta &amp;amp;&amp;gt;/dev/null; then echo &amp;#34;loading theta spack&amp;#34; module swap PrgEnv-intel PrgEnv-gnu module swap gcc/11.2.0 source ${HOME}/git/spack-theta/share/spack/setup-env.sh export CRAYPE_LINK_TYPE=dynamic export clustername=theta export HTTP_PROXY=http://theta-proxy.tmi.alcf.anl.gov:3128 export HTTPS_PROXY=http://theta-proxy.tmi.alcf.anl.gov:3128 export http_proxy=http://theta-proxy.tmi.alcf.anl.gov:3128 export https_proxy=http://theta-proxy.tmi.alcf.anl.gov:3128 fi export SPACK_USER_CONFIG_PATH=&amp;#34;$HOME/.spack/$clustername&amp;#34; export SPACK_USER_CACHE_PATH=&amp;#34;$SPACK_USER_CONFIG_PATH&amp;#34; } Then run
mkdir -p ~/git git clone https://github.com/spack/spack git/spack-theta git clone https://github.com/robertu94/spack_packages git/robertu94_packages git clone https://github.com/mochi-hpc/mochi-spack-packages git/mochi-spack-packages source ~/.</description></item><item><title>LibPressio</title><link>http://robertu94.github.io/presentations/ecp2021-lossy.html</link><pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/ecp2021-lossy.html</guid><description>This talk was part of a larger session on Error Bounded Lossy Compression. It presents updates on LibPressio since the last annual meeting focusing on the automated configuration work completed as part of FRaZ and LibPressio-Opt as well as interface improvements.</description></item><item><title>Approachable Error Bounded Lossy Compression</title><link>http://robertu94.github.io/presentations/sc2020-doctoral.html</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/sc2020-doctoral.html</guid><description>Compression is commonly used in HPC applications to move and store data. Traditional losslesscompression, however, does not provide adequate compression of floating point data often found inscientific codes. Recently, researchers and scientists have turned to lossy compression techniquesthat approximate the original data rather than reproduce it in order to achieve desired levels ofcompression. Typical lossy compressors do not bound the errors introduced into the data, leading to the development of error bounded lossy compressors (EBLC). These tools provide the desired levelsof compression as mathematical guarantees on the errors introduced. The current state of EBLCleaves much to be desired. The existing EBLC all have different interfaces requiring codes to bechanged to adopt new techniques; EBLC have many more configuration options than theirpredecessors, making them more difficult to use; and EBLC typically bound quantities like pointwise errors rather than higher level metrics such as spectra, p-values, or test statistics thatscientists typically use. My dissertation aims to provide a uniform interface to compression and todevelop tools to allow application scientists to understand and apply EBLC. This canvas presentsthree groups of work: LibPressio, a standard interface for compression and analysis;FRaZ/LibPressio-Opt frameworks for the automated configuration of compressors using LibPressio;and work on tools for analyzing errors in particular domains</description></item><item><title>Lossy Compression for AI</title><link>http://robertu94.github.io/presentations/jlesc2020-lossy.html</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/jlesc2020-lossy.html</guid><description>As time progresses, the volume of data surrounding machine learning and AI methods continues to grow from training, testing, and validation datasets to the models themselves. As the volume grows, there are increasing challenges in transporting and storing the data. Lossy compression techniques present the opportunity to drastically reduce the volume of data while maintaining or even improving upon the quality of the decisions made by AI. This talk presents a survey of novel research examining the effect of lossy compression on AI decision making in a variety of domains including medical data science and physics. We examine the effects of data ordering, error bounds, compression methodologies to make general recommendations from these and other areas regarding how to effectively leverage lossy compression in AI using the common LibPressio interface.</description></item><item><title>Spack: a Truly Useful Package Manager</title><link>http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html</link><pubDate>Thu, 27 Aug 2020 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html</guid><description>So you are developing software, and you need the software to build for multiple difference machines, with different version of a library, or with just different compile time options. You can probably manage this by hand, but it very quickly gets out of hand. Spack is a package manager designed for high performance computing, but I would argue is more broadly useful for five reasons:
It is explicitly designed to run as an unprivileged user.</description></item><item><title>FRaZ: A Generic High-Fidelity Fixed-Ratio Lossy Compression Framework for Floating Point Scientific Data</title><link>http://robertu94.github.io/presentations/ipdps2020-fraz.html</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/ipdps2020-fraz.html</guid><description>With ever-increasing volumes of scientific floating-point data being produced by high-performance computingapplications, significantly reducing scientific floating-point datasize is critical, and error-controlled lossy compressors have beendeveloped for years. None of the existing scientific floating-pointlossy data compressors, however, support effective fixed-ratiolossy compression. Yet fixed-ratio lossy compression for scientificfloating-point data not only compresses to the requested ratio butalso respects a user-specified error bound with higher fidelity. Inthis paper, we present FRaZ: a generic fixed-ratio lossy com-pression framework respecting user-specified error constraints.The contribution is twofold. (1) We develop an efficient iterativeapproach to accurately determine the appropriate error settingsfor different lossy compressors based on target compressionratios. (2) We perform a thorough performance and accuracyevaluation for our proposed fixed-ratio compression frameworkwith multiple state-of-the-art error-controlled lossy compressors,using several real-world scientific floating-point datasets fromdifferent domains. Experiments show that FRaZ effectively iden-tifies the optimum error setting in the entire error setting space ofany given lossy compressor. While fixed-ratio lossy compressionis slower than fixed-error compression, it provides an importantnew lossy compression technique for users of very large scientificfloating-point datasets.</description></item><item><title>LibPressio Tutorial</title><link>http://robertu94.github.io/presentations/libpressio2020-tutorial.html</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/libpressio2020-tutorial.html</guid><description>This video provides a basic tutorial of how to install and use LibPressio &amp;ndash; a generic abstraction for lossless and lossy compression for dense tensors. You can find LibPressio on &lt;a href="https://github.com/codarcode/libpressio">github&lt;/a></description></item><item><title>Approachable Error Bounded Lossy Compression</title><link>http://robertu94.github.io/presentations/argonne2019-aproachable.html</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/argonne2019-aproachable.html</guid><description>Error Bounded Lossy Compression is a powerful technique that combines the power of lossy compression with the strong guarantees for the preservation of the original data. However, using error bounded lossy compression can be challenging. There is a proliferation of interfaces, different semantics, and difficult to understand relationships to user error bounds. This talk presents two tools — LibPressio and FRaZ — that help address these issues. LibPressio provides a usable abstraction across SZ, ZFP, MGARD, as well as traditional image compressors (JPEG, WEBP, PNG, TIFF, etc) and lossless compressors via BLOSC. FRaZ is a tool that uses LibPresssio to compress datasets according to a Fixed Compression Ratio with progress towards supporting arbitrary user error bounds. I present our recent work submitted to IPDPS and current work in progress.</description></item><item><title>Strong or Robust?</title><link>http://robertu94.github.io/2019/11/17/strong-or-robust.html</link><pubDate>Sun, 17 Nov 2019 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2019/11/17/strong-or-robust.html</guid><description>Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called &amp;ldquo;strong-typing&amp;rdquo; advocating new API designs. In this post, I go a little into the debate and discuss its consequences.
What does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn&amp;rsquo;t want their software to be robust?</description></item><item><title>Learning to Learn: High Performance Computing</title><link>http://robertu94.github.io/learning/hpc.html</link><pubDate>Sun, 25 Aug 2019 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/hpc.html</guid><description>There&amp;rsquo;s at least for me an inherent coolness to be able to say that I can run code on a super computer. However, there is often a gap between the kind of programming that you learned in your introductory classes, and what kind of code runs well on a computing cluster. In this post, I try to provide an introduction to high performance computing, and some of the differences between it and personal computing.</description></item><item><title>Learning to Learn: Linux</title><link>http://robertu94.github.io/learning/linux.html</link><pubDate>Sun, 25 Aug 2019 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/linux.html</guid><description>So you want to or have to try this thing called &amp;ldquo;Linux.&amp;rdquo; Just like curry powder isn&amp;rsquo;t just one thing, but a distinct mix of spices that come together into a tasty mixture, Linux is much the same. Also like curry, Linux isn&amp;rsquo;t for everyone. In this post I describe the process of choosing the &amp;ldquo;flavor&amp;rdquo; of Linux that will work best for you, introduce a powerful tool that will help you to make the most of Linux, and describe some first steps to take when things go wrong.</description></item><item><title>Learning to Learn: Writing</title><link>http://robertu94.github.io/learning/writing.html</link><pubDate>Mon, 01 Jul 2019 06:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/writing.html</guid><description>Communication is essential to the enterprise of knowledge. Without communication, we would never be able to build upon the works of others or have them build upon our own. One of the most important &amp;ndash; and challenging &amp;ndash; arts within communication is writing. Writing is unique among commutative forms in its durability and portability. Once written, the words of the author can transcend even their death and travel places they never dreamed to tread.</description></item><item><title>Learning to Learn: Studying New Topics</title><link>http://robertu94.github.io/learning/litrature-review.html</link><pubDate>Fri, 12 Apr 2019 11:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/litrature-review.html</guid><description>Efficient study of a topic is a powerful skill for a wide variety of domains. However &amp;ndash; despite having several classes on writing and research in High School and Undergraduate Studies &amp;ndash; it wasn&amp;rsquo;t something that I truly appreciated and learned how to do well until Graduate School. I think this really boils down to lacking the kind of personal application that makes these efforts meaningful. However now that I have come to appreciate it, I want to highlight how I think how I study new topics, and how this applies to many topics outside of academic research.</description></item><item><title>Julia: Could There be One Language?</title><link>http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html</link><pubDate>Thu, 04 Apr 2019 09:00:00 -0500</pubDate><guid>http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html</guid><description>There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn&amp;rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn&amp;rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn&amp;rsquo;t always Generic in the sense that Python is.</description></item><item><title>Learning to Learn: Python</title><link>http://robertu94.github.io/learning/python.html</link><pubDate>Wed, 23 Jan 2019 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/python.html</guid><description>Python is a relatively simple language compared to others such as C++. Despite its simplicity, Python really shines because of its robust standard library, extensive 3rd party library ecosystem (especially for statistics and data analysis), and intuitiveness. This post tracks my process of learning how to program well in Python.
Order of Topics The listing of topics here is arbitrary and represents the path that I took to learn Python roughly organized by topic.</description></item><item><title>Predicting Optimal Error-Bounded-Lossy-Compression Configuration</title><link>http://robertu94.github.io/presentations/sc2018-predicting.html</link><pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/sc2018-predicting.html</guid><description>Techniques for predicting error bounded lossy compression ratios from data distribution and compressor settings.</description></item><item><title>Learning to Learn: Reading</title><link>http://robertu94.github.io/learning/reading.html</link><pubDate>Wed, 08 Aug 2018 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/reading.html</guid><description>From time to time, I get questions about how I read and retain as much information as I do. While it is never easy &amp;ndash; especially with dry technical documents &amp;ndash; there are a few strategies that I have learned along the what that I find helpful. In this post I provide some general suggestions along with some that are more useful in computer systems research.
Strategies for Reading in General My chemistry and physics teacher &amp;ndash; Dr.</description></item><item><title>Configuration Management: Common Pitfalls</title><link>http://robertu94.github.io/2018/07/31/configuration-management-common-pitfalls.html</link><pubDate>Tue, 31 Jul 2018 10:00:00 -0500</pubDate><guid>http://robertu94.github.io/2018/07/31/configuration-management-common-pitfalls.html</guid><description>So you know you need a configuration management system and you have an idea of which one will work for you. So what should I think about about before deploying one of this systems? In this third and final post in this series, I present some suggestions about using these systems in a way that is flexible and scalable to larger numbers of systems.
Even within an operating system like Linux, there is a lot of variation between Linux distributions.</description></item><item><title>Configuration Management: the Battle Royal</title><link>http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html</link><pubDate>Tue, 31 Jul 2018 09:00:00 -0500</pubDate><guid>http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html</guid><description>So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I&amp;rsquo;ll highlight the strengths of these systems and their respective weaknesses.
Every evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.
Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.</description></item><item><title>Configuration Management: the Related Systems</title><link>http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html</link><pubDate>Tue, 31 Jul 2018 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html</guid><description>Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.</description></item><item><title>Generic Cuda</title><link>http://robertu94.github.io/2018/05/12/generic-cuda.html</link><pubDate>Sat, 12 May 2018 08:00:14 -0500</pubDate><guid>http://robertu94.github.io/2018/05/12/generic-cuda.html</guid><description>GPU programming has the potential to make embarrassingly parallel tasks very quick. But what if you want to perform the same task on a variety of different types? In this post, I walk through a generic testing code that preforms a vector add on GPU and CPU to verify the correctness.
The Test Harness Our main function is pretty simple:
int main(int argc, char* argv[]) { check_type&amp;lt;int&amp;gt;(); check_type&amp;lt;long&amp;gt;(); check_type&amp;lt;double&amp;gt;(); check_type&amp;lt;float&amp;gt;(); return 0; } So how do we write check_type?</description></item><item><title>Learning to Learn: C++</title><link>http://robertu94.github.io/learning/cpp.html</link><pubDate>Fri, 12 Jan 2018 19:00:14 -0500</pubDate><guid>http://robertu94.github.io/learning/cpp.html</guid><description>C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.
Order of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.</description></item><item><title>Learning to Learn: Intake</title><link>http://robertu94.github.io/learning/intake.html</link><pubDate>Mon, 01 Jan 2018 08:00:14 -0500</pubDate><guid>http://robertu94.github.io/learning/intake.html</guid><description>From time to time I get questions about how I stay apprised on all of the topics that I know something about. The short answer is a lot of reading and listening.
I make extensive use of RSS Feeds and Podcasts as part of my information intake process. In this post, I provide the list of principles that I use to manage the list of information sources that I use.</description></item><item><title>Life with Libtooling</title><link>http://robertu94.github.io/2017/12/10/life-with-libtooling.html</link><pubDate>Sun, 10 Dec 2017 11:21:00 -0500</pubDate><guid>http://robertu94.github.io/2017/12/10/life-with-libtooling.html</guid><description>Over the last two months, I spent a significant amount of time using Clang&amp;rsquo;s libtooling. Libtooling is a great way to quickly develop tools to analyze and modify large quantizes of C++. In this article, I share some lessons learned working with libtooling.
Beware the Stability Guarantees. The biggest problem with libtooling is that it has very few if any Stability guarantees. When I was learning libtooling, I watched Peter Goldsborough&amp;rsquo;s video excellent &amp;ldquo;clang-useful: Building useful tools with LLVM and clang for fun and profit&amp;rdquo;.</description></item><item><title>Design of A Matrix loading Library</title><link>http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html</link><pubDate>Sat, 23 Sep 2017 07:00:00 -0500</pubDate><guid>http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html</guid><description>Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.
Design Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:</description></item><item><title>C++ Templates: Starring into the Abyss</title><link>http://robertu94.github.io/presentations/templates.html</link><pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/templates.html</guid><description>C++ templates are one of the most powerful, and probably least understood aspects of C++ programming. Trying to understand error messages from templates code can feel like staring into the abyss. In this talk, I introduce many of the various features and dive into applications of C++ templates that are used in the wild. I will cover several of the common pitfalls and design patterns that result from this feature of C++. I will also stare right into the heart of the abyss and explain why the error messages can be cryptic, why its a good thing, and how to begin to decipher those error messages.</description></item><item><title>Qt is for more than just GUIs</title><link>http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html</link><pubDate>Tue, 23 May 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html</guid><description>When most people think of Qt, I imagine that they think about the Graphical User Interface components. But Qt has a variety of other components beyond just being a GUI framework. In this post, I highlight some of what I find to be the more interesting features.
Object Communication via Signals and Slots One of the coolest features of Qt is its very clean implementation of signals and slots. Signals and slots are a means of communicating information (called signals) between objects via special callbacks (called slots).</description></item><item><title>Pluggable Authentication With PAM</title><link>http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html</link><pubDate>Sun, 14 May 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html</guid><description>Authentication and authorization is one of foundational aspects of any security system. However writing an authentication and authorization system can be anything but: There are complex, ever-changing requirements, not to mention differences for differing interfaces it can quickly become daunting. However, there already exists a system on Linux and Unix that allows for dynamic and complex authentication: PAM.
PAM Modules and Authentication Types Fundamentally, PAM is a collection of modules that provide several methods.</description></item><item><title>Resource Acquisition is Initialization and SDL</title><link>http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html</link><pubDate>Mon, 08 May 2017 05:30:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html</guid><description>Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.</description></item><item><title>Smart Pool</title><link>http://robertu94.github.io/2017/04/30/smart-pool.html</link><pubDate>Sun, 30 Apr 2017 09:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/04/30/smart-pool.html</guid><description>Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.
The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.</description></item><item><title>Surprisingly Functional</title><link>http://robertu94.github.io/2017/02/23/surprisingly-functional.html</link><pubDate>Thu, 23 Feb 2017 08:38:14 -0500</pubDate><guid>http://robertu94.github.io/2017/02/23/surprisingly-functional.html</guid><description>Functional programming is a surprisingly useful programming paradigm. The best aspects of functional programming have this odd habit of showing in places you would never expect.
The Shell and Endomorphisms Arguably one of the most powerful features of the Unix shell is the pipe. It is one of the core building blocks of the Unix philosophy of many small tools working together each doing one thing well. However, long before Unix, the idea of the endomorphisms was developed.</description></item><item><title>Dockerize All the Things!</title><link>http://robertu94.github.io/presentations/docker.html</link><pubDate>Wed, 01 Feb 2017 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/docker.html</guid><description>This talk introduces Docker and why you should care about it. It highlights differences between Docker and VMs while clarifying common misconceptions. I talk about how to create docker containers and containerize applications.</description></item><item><title>Faster than light</title><link>http://robertu94.github.io/2017/01/29/faster-than-light.html</link><pubDate>Sun, 29 Jan 2017 10:06:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/29/faster-than-light.html</guid><description>Ansible is probably my favorite provisioning and configuration management tool. Its syntax is concise, expressive, and elegant. Unlike other tools in its category, it has excellent documentation with working examples and intuitive naming. Learning it use it effectively can help you be a more productive developer.
Speeding Up Ansible Anyone that has used ansible for more than a few hosts with more than a few tasks knows that by default it can be really slow.</description></item><item><title>LLVM Tooling for C++</title><link>http://robertu94.github.io/2017/01/22/llvm-tooling-for-c-.html</link><pubDate>Sun, 22 Jan 2017 18:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/22/llvm-tooling-for-c-.html</guid><description>C++ is a both a fantastic language and a mess. It supports at least 4 programming paradigms (procedural, functional, object-oriented, template meta-programming). In some senses, many languages give you one great way to do things: C++ gives you every way and trusts you to use them well. With this flexibility comes problems that C++ seems to have beyond what other languages experience. Therefore, having effective tooling to develop and use C++ is essential.</description></item><item><title>Interpreters Made Easy</title><link>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</link><pubDate>Sun, 15 Jan 2017 10:14:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</guid><description>The Interpreter pattern from the &amp;ldquo;Design Patterns: Elements of Reusable Object Oriented Software&amp;rdquo; can potentially be a very powerful pattern. It allows you to use a domain specific language to represent a complex computational situation. However, writing interpreters in practice can be tricky and time consuming. It really helps to know something about some fundamental parsing algorithms and techniques.
The most naive approach to writing an interpret involves manually matching each possible next phrase and creating an if else soup to match each possible outcome.</description></item><item><title>Poor Man's Parallelism</title><link>http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html</link><pubDate>Sun, 08 Jan 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html</guid><description>I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can&amp;rsquo;t or don&amp;rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.
You can do this via Unix/shell job control:
cmd=&amp;#34;systemctl enable --now docker.service&amp;#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh &amp;amp; $host $cmd done However from experience, this can be very error prone.</description></item><item><title>Provisioning at the Speed of Thought</title><link>http://robertu94.github.io/presentations/provisioning.html</link><pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/provisioning.html</guid><description>Ever sit down to setup a set of computers and wonder, “why on earth do I have to do this manually on each and every node?” Writing scripts can solve the problem, but handling error is annoying and time consuming. It does not have to be that way. Configuration management tools such as Ansible, SaltStack, and Puppet take the pain out of managing small to large groups of computers. By the end of the presentation, You’ll learn some of the strengths and weaknesses of each so that you can decide which tool will fit your needs.</description></item><item><title>Exploitable 3: Reverse Engineering</title><link>http://robertu94.github.io/presentations/exploitable_3.html</link><pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/exploitable_3.html</guid><description>This seminar provides and overview of reverse engineering and how you might use it as a developer. I overview a variety of tools ranging from binary analysis, ptrace, kernel tracing tools, and kernel hacking and when to use each.</description></item><item><title>Writing Semantic Code: Using Refactoring Patterns for Better Code</title><link>http://robertu94.github.io/presentations/semantic.html</link><pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/semantic.html</guid><description>Spaghetti code is a nightmare. It is hard to read, harder to understand, and harder still to debug and change. In this talk, I introduce the discipline of refactoring which transforms code in a way that maintains its external behavior while improving it&amp;rsquo;s internal structure. I will present several examples of poor design often seen in imperative code, and describe some techniques to refactor this code to easier to understand semantic code from Martin Fowler&amp;rsquo;s book &amp;ldquo;Refactoring: Improving the Design of Existing Software&amp;rdquo;.</description></item><item><title>Automation in the Classroom</title><link>http://robertu94.github.io/presentations/autograding.html</link><pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/autograding.html</guid><description>The purpose of this talk is to introduce how instructors could approach the topic of using automation in the classroom. We will make a case for automation both from a student&amp;rsquo;s and instructor&amp;rsquo;s perspective by showing that automation can save time, encourage test driven development, and improve testing for knowledge. We will also address concerns regarding grading automation including accuracy, confidentiality, and security. Then we will get into detail about techniques and tools that can be used for classroom automation. Finally we will examine case studies of how automation has and can be implemented. We will examine how this has been done technically as well as part of the classroom environment by faculty members at the School of Computing.</description></item><item><title>Exploitable 2</title><link>http://robertu94.github.io/presentations/exploitable_2.html</link><pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/exploitable_2.html</guid><description>This talk introduces Docker and why you should care about it. It highlights differences between Docker and VMs while clarifying common misconceptions. I talk about how to create docker containers and containerize applications.</description></item><item><title>Python: A Parser Tongue Primer</title><link>http://robertu94.github.io/presentations/python.html</link><pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/python.html</guid><description>An introduction to idiomatic python programming for new computer science students.</description></item><item><title>Linux is Scary</title><link>http://robertu94.github.io/presentations/linux.html</link><pubDate>Mon, 01 Feb 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/linux.html</guid><description>Introduction to Linux for new computer science students. Presented multiples times,</description></item><item><title>Think Different</title><link>http://robertu94.github.io/presentations/projects.html</link><pubDate>Mon, 01 Feb 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/projects.html</guid><description>A talk that provides an overview of how to approach computer science projects with less stress and effort. This talk was given multiple times at various Clemson ACM venues. Also titled, &amp;ldquo;Perfecting Your Projects&amp;rdquo;.</description></item><item><title>Thou Shall Not Pass! Introduction to Open Source Firewalls</title><link>http://robertu94.github.io/presentations/firewall.html</link><pubDate>Mon, 01 Feb 2016 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/firewall.html</guid><description>This talks talks about what firewalls are, why you need one, and how to setup a basic firewall using iptables, firewalld, and pf.</description></item><item><title>Exploitable: An Introduction to Ethical Hacking</title><link>http://robertu94.github.io/presentations/exploitable.html</link><pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/exploitable.html</guid><description>This seminar talks about what is ethical hacking, how to learn how to do it, and how to set up a ethical hacking lab using Docker.</description></item><item><title>NMAP</title><link>http://robertu94.github.io/presentations/nmap.html</link><pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/nmap.html</guid><description>This talk overviews NMAP a network mapping tool that is useful for understanding and monitoring your network.</description></item><item><title>Git Well Soon</title><link>http://robertu94.github.io/presentations/git.html</link><pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/git.html</guid><description>This talks overviews the git distributed version control system, what problems it solves, and how to use it. This talk was presented multiple times also under the title &amp;ldquo;Git Thee to a Version Control System&amp;rdquo;</description></item><item><title>N Unix Tools in O(N ) Minutes</title><link>http://robertu94.github.io/presentations/tools.html</link><pubDate>Sun, 01 Mar 2015 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/tools.html</guid><description>Overview of command line tools for POSIX platforms. This talk covers some of the most useful POSIX scripting tools including awk, sed, gdb, find, and more.</description></item><item><title>Intermediate Vim</title><link>http://robertu94.github.io/presentations/vim.html</link><pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/presentations/vim.html</guid><description>An intermediate level talk that aims to showcase neat features of vim above and beyond what is covered in vimtutor.</description></item><item><title>About Me</title><link>http://robertu94.github.io/about.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/about.html</guid><description>I am a Post-Doctoral Appointee at Argonne National Laboratory under Franck Cappello, Sheng Di and Bogdan Nicolae. My particular research interests are lossy compression, distributed systems, and operating systems.
Academics You can find my full CV here.
I earned my PhD at Clemson University studying Computer Science in December 2021. I am previously worked with the Data Intensive Computing Environments (DICE) Lab and Fault Tolerant HPC Lab (FTHPC) studying error bounded lossy compression under my adviors Dr.</description></item><item><title>Learning to Learn: GDB</title><link>http://robertu94.github.io/learning/gdb.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/learning/gdb.html</guid><description>GDB is a powerful tool that is underutilized by most programmers that I&amp;rsquo;ve met. It can tell you the state of one or more running or crashed programs, and even manipulate the memory of a running process. It is an invaluable tool for understanding what is going wrong with your programs.
How to get started To get the most out of GDB you need to compile your program with debug information &amp;ndash; metadata that describes the program source.</description></item><item><title>Learning to Learn: MPI</title><link>http://robertu94.github.io/learning/mpi.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/learning/mpi.html</guid><description>MPI is the de-facto standard way to write distributed programs that run on super computers. Many have tried to replace it, but so far none of them have succeeded. Learning to use it successfully, will enable you to write powerful distributed programs.
Order of Topics MPI has a minimal powerful and useful core, but really tries to completely own it&amp;rsquo;s space.
I strongly reccommend reading &amp;ldquo;Using MPI&amp;rdquo; by Gropp et al.</description></item></channel></rss>