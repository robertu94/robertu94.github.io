<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on systems++</title><link>http://robertu94.github.io/posts.html</link><description>Recent content in Posts on systems++</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://robertu94.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Refactoring CI/CD for a Modernatly Large C++ Code Base</title><link>http://robertu94.github.io/2023/04/24/refactoring-ci/cd-for-a-modernatly-large-c-code-base.html</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/04/24/refactoring-ci/cd-for-a-modernatly-large-c-code-base.html</guid><description>CI/CD is a critical, but difficult to get right part of software engineering. You often want to test multiple distributions, multiple compilers on each commit, and you want that to be as fast as reasonably possible. This gets more complicated when you have large dependency trees that you want to remain consistent. Recently, I adapted the CI/CD system for a project that I maintain LibPressio to use Dagger &amp;ndash; a programmatic way to do CI/CD portable-ally across runner environments which made it easier to run our tests and verify correctness.</description></item><item><title>How I work: The Tools I Use</title><link>http://robertu94.github.io/2023/03/14/how-i-work-the-tools-i-use.html</link><pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/03/14/how-i-work-the-tools-i-use.html</guid><description>From time to time I get a question of what tools I use for what jobs. Here the tools I use to get things done:
Language Specific Purpose C++ Python Julia Rust Compiler/Interpeter gcc/clang python:quick,ipython:long julia rustc,cargo Profiler perf/FlameGraphs + perftrace cprofile:function, line_profiler:line BenchmarkTools.jl cargo Debugger GDB + mpigdb *c++, pdb *c++ Debugger.jl:default,Cathulu.jl:metaprogramming *c++ rust-gdb Build System CMake,(meson, bazel) + m ?</description></item><item><title>External Clang-Tidy Modules! C++ Refactoring for the Common Project</title><link>http://robertu94.github.io/2023/03/10/external-clang-tidy-modules-c-refactoring-for-the-common-project.html</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/03/10/external-clang-tidy-modules-c-refactoring-for-the-common-project.html</guid><description>Clang style refactoring has been something I&amp;rsquo;ve been admiring from afar for quite a while now. However for a user to actually use it, it has previously required forking llvm to be able to use it in a reasonable fashion because of things like the hack in clang used to locate the resource directory or other fragile hacks like LD_PRELOAD.
Recently, the Clang/LLVM developers vastly improved the situation by allowing loadable clang-tidy modules and by installing all of the headers that you actually need to do something with clang tidy, and they are finally packaged on both Fedora and Ubuntu!</description></item><item><title>Refactoring With Clang Query</title><link>http://robertu94.github.io/2022/12/28/refactoring-with-clang-query.html</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/28/refactoring-with-clang-query.html</guid><description>Have you ever wanted to identify a list of files that would need modifications to adopt a new API? Clang-Query can make this much easier. I recently wanted to introduce a set of helper functions to simplfy an aspect of compressor configuation in LibPressio. But first, I needed to know what modules were effected.
Clang-query needs a compilation database which can be produced by tools such as bear (if you have a Autotools or Makefile based project) or more sophisticated build systems such as cmake, meson or bazel.</description></item><item><title>Three Neat Things I Did With Julia</title><link>http://robertu94.github.io/2022/12/15/three-neat-things-i-did-with-julia.html</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/15/three-neat-things-i-did-with-julia.html</guid><description>In the past, I&amp;rsquo;ve written pretty glowingly about Julia. It&amp;rsquo;s been a few years since I first used Julia in 2019, and it hasn&amp;rsquo;t completely replaced Python for me. However, I wanted to share a few neat projects that I&amp;rsquo;ve done using it which would have been much more painful without it, and share what I think now about what I wrote in 2019.
Implementing a Statistical Metric on the GPU Being able to access heterogenous compute is important to be able to make the most of the availible hardware.</description></item><item><title>Debugging Inconsistent Network Performance</title><link>http://robertu94.github.io/2022/12/14/debugging-inconsistent-network-performance.html</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/14/debugging-inconsistent-network-performance.html</guid><description>High-performance network interconnects, such as Infiniband, are common in high performance computing environments. Recently, my colleagues, and I ran a series of experiments on the Cooley system at the Argonne Leadership Computing Facility. For one set of experiments, the network performance was consistent and fast, but for the others we periodically had poor performance. Up until this point in my work, I had not directly used or configured network libraries below this layer.</description></item><item><title>Thoughts on Dependencies for Scientific Software</title><link>http://robertu94.github.io/2022/07/20/thoughts-on-dependencies-for-scientific-software.html</link><pubDate>Wed, 20 Jul 2022 00:00:00 -0500</pubDate><guid>http://robertu94.github.io/2022/07/20/thoughts-on-dependencies-for-scientific-software.html</guid><description>Modern software does not exist in a vacuum, developers always rely on other developers or engineers to provide aspects of their systems. Even if you write hello world in your programming language of your choice you likely still depend on the standard library from your language. Even if you were to write hello world in the raw binary format of your assembly language, you still depend on the operating system. Even if you wrote your own uni-kernel to produce hello world on the console, you likely rely on vendor provided firmware to initialize the program or memory.</description></item><item><title>Spack: a Truly Useful Package Manager</title><link>http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html</link><pubDate>Thu, 27 Aug 2020 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html</guid><description>So you are developing software, and you need the software to build for multiple difference machines, with different version of a library, or with just different compile time options. You can probably manage this by hand, but it very quickly gets out of hand. Spack is a package manager designed for high performance computing, but I would argue is more broadly useful for five reasons:
It is explicitly designed to run as an unprivileged user.</description></item><item><title>Strong or Robust?</title><link>http://robertu94.github.io/2019/11/17/strong-or-robust.html</link><pubDate>Sun, 17 Nov 2019 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2019/11/17/strong-or-robust.html</guid><description>Should a software design be strong or robust? This is a debate that seems to have been developing in recent years with the recent proponents so-called &amp;ldquo;strong-typing&amp;rdquo; advocating new API designs. In this post, I go a little into the debate and discuss its consequences.
What does it mean to be strong vs robust? Robustness in software engineering is not a new concept, and intuitively a attractive one. Who doesn&amp;rsquo;t want their software to be robust?</description></item><item><title>Julia: Could There be One Language?</title><link>http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html</link><pubDate>Thu, 04 Apr 2019 09:00:00 -0500</pubDate><guid>http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html</guid><description>There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn&amp;rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn&amp;rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn&amp;rsquo;t always Generic in the sense that Python is.</description></item><item><title>Configuration Management: Common Pitfalls</title><link>http://robertu94.github.io/2018/07/31/configuration-management-common-pitfalls.html</link><pubDate>Tue, 31 Jul 2018 10:00:00 -0500</pubDate><guid>http://robertu94.github.io/2018/07/31/configuration-management-common-pitfalls.html</guid><description>So you know you need a configuration management system and you have an idea of which one will work for you. So what should I think about about before deploying one of this systems? In this third and final post in this series, I present some suggestions about using these systems in a way that is flexible and scalable to larger numbers of systems.
Even within an operating system like Linux, there is a lot of variation between Linux distributions.</description></item><item><title>Configuration Management: the Battle Royal</title><link>http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html</link><pubDate>Tue, 31 Jul 2018 09:00:00 -0500</pubDate><guid>http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html</guid><description>So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I&amp;rsquo;ll highlight the strengths of these systems and their respective weaknesses.
Every evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.
Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.</description></item><item><title>Configuration Management: the Related Systems</title><link>http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html</link><pubDate>Tue, 31 Jul 2018 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html</guid><description>Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.</description></item><item><title>Generic Cuda</title><link>http://robertu94.github.io/2018/05/12/generic-cuda.html</link><pubDate>Sat, 12 May 2018 08:00:14 -0500</pubDate><guid>http://robertu94.github.io/2018/05/12/generic-cuda.html</guid><description>GPU programming has the potential to make embarrassingly parallel tasks very quick. But what if you want to perform the same task on a variety of different types? In this post, I walk through a generic testing code that preforms a vector add on GPU and CPU to verify the correctness.
The Test Harness Our main function is pretty simple:
int main(int argc, char* argv[]) { check_type&amp;lt;int&amp;gt;(); check_type&amp;lt;long&amp;gt;(); check_type&amp;lt;double&amp;gt;(); check_type&amp;lt;float&amp;gt;(); return 0; } So how do we write check_type?</description></item><item><title>Life with Libtooling</title><link>http://robertu94.github.io/2017/12/10/life-with-libtooling.html</link><pubDate>Sun, 10 Dec 2017 11:21:00 -0500</pubDate><guid>http://robertu94.github.io/2017/12/10/life-with-libtooling.html</guid><description>Over the last two months, I spent a significant amount of time using Clang&amp;rsquo;s libtooling. Libtooling is a great way to quickly develop tools to analyze and modify large quantizes of C++. In this article, I share some lessons learned working with libtooling.
Beware the Stability Guarantees. The biggest problem with libtooling is that it has very few if any Stability guarantees. When I was learning libtooling, I watched Peter Goldsborough&amp;rsquo;s video excellent &amp;ldquo;clang-useful: Building useful tools with LLVM and clang for fun and profit&amp;rdquo;.</description></item><item><title>Design of A Matrix loading Library</title><link>http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html</link><pubDate>Sat, 23 Sep 2017 07:00:00 -0500</pubDate><guid>http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html</guid><description>Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.
Design Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:</description></item><item><title>Qt is for more than just GUIs</title><link>http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html</link><pubDate>Tue, 23 May 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html</guid><description>When most people think of Qt, I imagine that they think about the Graphical User Interface components. But Qt has a variety of other components beyond just being a GUI framework. In this post, I highlight some of what I find to be the more interesting features.
Object Communication via Signals and Slots One of the coolest features of Qt is its very clean implementation of signals and slots. Signals and slots are a means of communicating information (called signals) between objects via special callbacks (called slots).</description></item><item><title>Pluggable Authentication With PAM</title><link>http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html</link><pubDate>Sun, 14 May 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html</guid><description>Authentication and authorization is one of foundational aspects of any security system. However writing an authentication and authorization system can be anything but: There are complex, ever-changing requirements, not to mention differences for differing interfaces it can quickly become daunting. However, there already exists a system on Linux and Unix that allows for dynamic and complex authentication: PAM.
PAM Modules and Authentication Types Fundamentally, PAM is a collection of modules that provide several methods.</description></item><item><title>Resource Acquisition is Initialization and SDL</title><link>http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html</link><pubDate>Mon, 08 May 2017 05:30:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html</guid><description>Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.</description></item><item><title>Smart Pool</title><link>http://robertu94.github.io/2017/04/30/smart-pool.html</link><pubDate>Sun, 30 Apr 2017 09:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/04/30/smart-pool.html</guid><description>Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.
The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.</description></item><item><title>Surprisingly Functional</title><link>http://robertu94.github.io/2017/02/23/surprisingly-functional.html</link><pubDate>Thu, 23 Feb 2017 08:38:14 -0500</pubDate><guid>http://robertu94.github.io/2017/02/23/surprisingly-functional.html</guid><description>Functional programming is a surprisingly useful programming paradigm. The best aspects of functional programming have this odd habit of showing in places you would never expect.
The Shell and Endomorphisms Arguably one of the most powerful features of the Unix shell is the pipe. It is one of the core building blocks of the Unix philosophy of many small tools working together each doing one thing well. However, long before Unix, the idea of the endomorphisms was developed.</description></item><item><title>Faster than light</title><link>http://robertu94.github.io/2017/01/29/faster-than-light.html</link><pubDate>Sun, 29 Jan 2017 10:06:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/29/faster-than-light.html</guid><description>Ansible is probably my favorite provisioning and configuration management tool. Its syntax is concise, expressive, and elegant. Unlike other tools in its category, it has excellent documentation with working examples and intuitive naming. Learning it use it effectively can help you be a more productive developer.
Speeding Up Ansible Anyone that has used ansible for more than a few hosts with more than a few tasks knows that by default it can be really slow.</description></item><item><title>LLVM Tooling for C++</title><link>http://robertu94.github.io/2017/01/22/llvm-tooling-for-c-.html</link><pubDate>Sun, 22 Jan 2017 18:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/22/llvm-tooling-for-c-.html</guid><description>C++ is a both a fantastic language and a mess. It supports at least 4 programming paradigms (procedural, functional, object-oriented, template meta-programming). In some senses, many languages give you one great way to do things: C++ gives you every way and trusts you to use them well. With this flexibility comes problems that C++ seems to have beyond what other languages experience. Therefore, having effective tooling to develop and use C++ is essential.</description></item><item><title>Interpreters Made Easy</title><link>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</link><pubDate>Sun, 15 Jan 2017 10:14:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</guid><description>The Interpreter pattern from the &amp;ldquo;Design Patterns: Elements of Reusable Object Oriented Software&amp;rdquo; can potentially be a very powerful pattern. It allows you to use a domain specific language to represent a complex computational situation. However, writing interpreters in practice can be tricky and time consuming. It really helps to know something about some fundamental parsing algorithms and techniques.
The most naive approach to writing an interpret involves manually matching each possible next phrase and creating an if else soup to match each possible outcome.</description></item><item><title>Poor Man's Parallelism</title><link>http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html</link><pubDate>Sun, 08 Jan 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html</guid><description>I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can&amp;rsquo;t or don&amp;rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.
You can do this via Unix/shell job control:
cmd=&amp;#34;systemctl enable --now docker.service&amp;#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh &amp;amp; $host $cmd done However from experience, this can be very error prone.</description></item></channel></rss>