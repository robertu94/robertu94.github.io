<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Systems++</title><link>https://robertu94.github.io/posts/</link><description>Recent content in Posts on Systems++</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 23 Nov 2023 12:17:00 -0500</lastBuildDate><atom:link href="https://robertu94.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Installing My Server Fully Remotely</title><link>https://robertu94.github.io/posts/2023-11-23-ipmi-install/</link><pubDate>Thu, 23 Nov 2023 12:17:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2023-11-23-ipmi-install/</guid><description>&lt;p>I run a small tower server in my house to provide services that I use for
software development, recently CentOS-8-Stream reached end of life.
Since this server distribution doesn&amp;rsquo;t support in-place updates, updating
requires reinstalling with a new version of the CentOS-9-Stream. This post
documents the challenges that I hit along the way.&lt;/p></description></item><item><title>Dethroning LaTeX: What Would It Take?</title><link>https://robertu94.github.io/posts/2023-07-02-dethrone-latex/</link><pubDate>Sun, 02 Jul 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2023-07-02-dethrone-latex/</guid><description>&lt;p>As an academic, you write a lot of papers. If you contribute to the disciplines of Math, Computer Science, or some domains of physical sciences, you&amp;rsquo;ve probably used LaTeX &amp;ndash; a typesetting language &amp;ndash; through a tool like &lt;a href="https://overleaf.com/" target="_blank" rel="noreferrer">Overleaf&lt;/a>. What&amp;rsquo;s nice about LaTeX is that it attempts to separate concerns: Authors with minimal effort can port the text and structure of a document from one style to another. It generally produces much more ascetically pleasing output by default than what most authors would do on their own. It handles formatting of three things that generally are extremely frustrating in other tools: citations/bibliography, cross-references, footnotes/endnotes, equations, and embedded code listings. When used with a source control like Git it provides one of the best change review and tracking mechanisms of any document platform.&lt;/p></description></item><item><title>How I Work: Killer Libraries</title><link>https://robertu94.github.io/posts/2023-06-03-languages/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2023-06-03-languages/</guid><description>&lt;p>Most successful langauges have a &amp;ldquo;killer&amp;rdquo; features that motivates&lt;/p>
&lt;p>In my previous post, I commented on the tools that I use for software development, but I didn&amp;rsquo;t talk about either the process of choosing a language or the libraries within a language that I use most frequently. This post expands on how I work within a language and specific &amp;ldquo;killer&amp;rdquo; libraries that I use most and how they compare to facililties that I know from other languages.&lt;/p></description></item><item><title>Refactoring CI/CD for a Moderately Large C++ Code Base</title><link>https://robertu94.github.io/posts/2023-03-29-dagger/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2023-03-29-dagger/</guid><description>&lt;p>CI/CD is a critical, but difficult to get right part of software engineering.
You often want to test multiple distributions, multiple compilers on each commit, and you want that to be as fast as reasonably possible.
This gets more complicated when you have large dependency trees that you want to remain consistent.
Recently, I adapted the CI/CD system for a project that I maintain LibPressio to use Dagger &amp;ndash; a programmatic way to do CI/CD portable-ally across runner environments which made it easier to run our tests and verify correctness.&lt;/p></description></item><item><title>How I work: The Tools I Use</title><link>https://robertu94.github.io/posts/2023-03-14-how-i-work/</link><pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2023-03-14-how-i-work/</guid><description>&lt;p>From time to time I get a question of what tools I use for what jobs. Here the tools I use to get things done:&lt;/p></description></item><item><title>External Clang-Tidy Modules! C++ Refactoring for the Common Project</title><link>https://robertu94.github.io/posts/2023-03-10-clang-tidy/</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2023-03-10-clang-tidy/</guid><description>&lt;p>Clang style refactoring has been something I&amp;rsquo;ve been admiring from afar for
quite a while now. However for a user to actually use it, it has previously
required forking llvm to be able to use it in a reasonable fashion because of
things like the hack in clang used to locate the resource directory or other
fragile hacks like &lt;code>LD_PRELOAD&lt;/code>.&lt;/p></description></item><item><title>Refactoring With Clang Query</title><link>https://robertu94.github.io/posts/2022-12-28-refactoring-with-clang-query/</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2022-12-28-refactoring-with-clang-query/</guid><description>&lt;p>Have you ever wanted to identify a list of files that would need modifications to adopt a new API?
Clang-Query can make this much easier.
I recently wanted to introduce a set of helper functions to simplfy an aspect of compressor configuation in LibPressio.
But first, I needed to know what modules were effected.&lt;/p></description></item><item><title>Three Neat Things I Did With Julia</title><link>https://robertu94.github.io/posts/2022-12-15-three-neat-things-with-julia/</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2022-12-15-three-neat-things-with-julia/</guid><description>&lt;p>In the past, I&amp;rsquo;ve &lt;a href="https://robertu94.github.io/posts/2019-03-21-julia-could-there-be-one/">written pretty glowingly about Julia&lt;/a>. It&amp;rsquo;s been a few years
since I first used Julia in 2019, and it hasn&amp;rsquo;t completely replaced Python for
me. However, I wanted to share a few neat projects that I&amp;rsquo;ve done using it
which would have been much more painful without it, and share what I think now
about what I wrote in 2019.&lt;/p></description></item><item><title>Debugging Inconsistent Network Performance</title><link>https://robertu94.github.io/posts/2022-12-14-debugging-libfabric/</link><pubDate>Wed, 14 Dec 2022 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2022-12-14-debugging-libfabric/</guid><description>&lt;p>High-performance network interconnects, such as Infiniband, are common in high performance computing environments. Recently, my colleagues, and I ran a series of experiments on the Cooley system at the Argonne Leadership Computing Facility. For one set of experiments, the network performance was consistent and fast, but for the others we periodically had poor performance. Up until this point in my work, I had not directly used or configured network libraries below this layer. This post summarizes the steps we took to investigate the performance.&lt;/p></description></item><item><title>Thoughts on Dependencies for Scientific Software</title><link>https://robertu94.github.io/posts/2022-05-05-dependencies/</link><pubDate>Wed, 20 Jul 2022 00:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2022-05-05-dependencies/</guid><description>&lt;p>Modern software does not exist in a vacuum, developers always rely on other developers or engineers to provide aspects of their systems.
Even if you write hello world in your programming language of your choice you likely still depend on the standard library from your language.
Even if you were to write hello world in the raw binary format of your assembly language, you still depend on the operating system.
Even if you wrote your own uni-kernel to produce hello world on the console, you likely rely on vendor provided firmware to initialize the program or memory.
And if you are one of the blessed few who can completely fabricate your own hardware and don&amp;rsquo;t need to rely on vendor provided firmware, you likely don&amp;rsquo;t have time or expertise to write efficient higher level systems and need others to provide software to run on your hardware.
Therefore the question is not will you use dependencies, but how will you use them responsibly.&lt;/p></description></item><item><title>Spack: a Truly Useful Package Manager</title><link>https://robertu94.github.io/posts/2020-08-27-spack/</link><pubDate>Thu, 27 Aug 2020 08:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2020-08-27-spack/</guid><description>&lt;p>So you are developing software, and you need the software to build for multiple difference machines, with different version of a library, or with just different compile time options.
You can probably manage this by hand, but it very quickly gets out of hand.
Spack is a package manager designed for high performance computing, but I would argue is more broadly useful for five reasons:&lt;/p></description></item><item><title>Strong or Robust?</title><link>https://robertu94.github.io/posts/2019-11-17-strong-or-robust/</link><pubDate>Sun, 17 Nov 2019 08:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2019-11-17-strong-or-robust/</guid><description>&lt;p>Should a software design be strong or robust?
This is a debate that seems to have been developing in recent years with the recent proponents so-called &amp;ldquo;strong-typing&amp;rdquo; advocating new API designs.
In this post, I go a little into the debate and discuss its consequences.&lt;/p></description></item><item><title>Julia: Could There be One Language?</title><link>https://robertu94.github.io/posts/2019-03-21-julia-could-there-be-one/</link><pubDate>Thu, 04 Apr 2019 09:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2019-03-21-julia-could-there-be-one/</guid><description>&lt;p>There is a constant problem with programming language design: fast, generic, easy to write; pick two.
The principle is that programming languages cannot be all three at once.
Code that is Fast and Generic like C++ isn&amp;rsquo;t exactly easy to write.
Code that is Generic and easy to write like Python isn&amp;rsquo;t always fast in the sense that C/C++ programmers mean it.
Code that is Fast and Easy to Write isn&amp;rsquo;t always Generic in the sense that Python is.
There is a new language on the block &amp;ndash; Julia &amp;ndash; which strives to challenge these assumptions.
In the remainder of this post, I highlight what I like about it and describe my experience using it over the last semester.&lt;/p></description></item><item><title>Configuration Management: Common Pitfalls</title><link>https://robertu94.github.io/posts/2018-07-31-configuration-management-pitfalls/</link><pubDate>Tue, 31 Jul 2018 10:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2018-07-31-configuration-management-pitfalls/</guid><description>&lt;p>So you know you need a configuration management system and you have an idea of which one will work for you.
So what should I think about about before deploying one of this systems?
In this third and final post in this series, I present some suggestions about using these systems in a way that is flexible and scalable to larger numbers of systems.&lt;/p></description></item><item><title>Configuration Management: the Battle Royal</title><link>https://robertu94.github.io/posts/2018-07-31-configuration-management-comparison/</link><pubDate>Tue, 31 Jul 2018 09:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2018-07-31-configuration-management-comparison/</guid><description>&lt;p>So, you need a Configuration Management System, so which one do you choose?
This post is the second in a three part series on configuration management.
In this post, I&amp;rsquo;ll highlight the strengths of these systems and their respective weaknesses.&lt;/p></description></item><item><title>Configuration Management: the Related Systems</title><link>https://robertu94.github.io/posts/2018-07-31-configuration-management-related-systems/</link><pubDate>Tue, 31 Jul 2018 08:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2018-07-31-configuration-management-related-systems/</guid><description>&lt;p>Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines.
But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started?
This post is the first in a series of posts that will attempt to answer these questions.&lt;/p></description></item><item><title>Generic Cuda</title><link>https://robertu94.github.io/posts/2018-05-12-generic-cuda/</link><pubDate>Sat, 12 May 2018 08:00:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2018-05-12-generic-cuda/</guid><description>&lt;p>GPU programming has the potential to make embarrassingly parallel tasks very quick.
But what if you want to perform the same task on a variety of different types?
In this post, I walk through a generic testing code that preforms a vector add on GPU and CPU to verify the correctness.&lt;/p></description></item><item><title>Life with Libtooling</title><link>https://robertu94.github.io/posts/2017-12-10-life-with-libtooling/</link><pubDate>Sun, 10 Dec 2017 11:21:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-12-10-life-with-libtooling/</guid><description>&lt;p>Over the last two months, I spent a significant amount of time using Clang&amp;rsquo;s libtooling.
Libtooling is a great way to quickly develop tools to analyze and modify large quantizes of C++.
In this article, I share some lessons learned working with libtooling.&lt;/p></description></item><item><title>Design of A Matrix loading Library</title><link>https://robertu94.github.io/posts/2017-09-23-matrixloading-library/</link><pubDate>Sat, 23 Sep 2017 07:00:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-09-23-matrixloading-library/</guid><description>&lt;p>Ever notice that every matrix and graph library seems to have a different interface for constructing matrices?
Also notice that each only only supports some subset of common matrix formats?
With a little help from the Adapter and Builder design patterns we can actually solve this problem.&lt;/p></description></item><item><title>Qt is for more than just GUIs</title><link>https://robertu94.github.io/posts/2017-05-23-qt-as-library/</link><pubDate>Tue, 23 May 2017 10:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-05-23-qt-as-library/</guid><description>&lt;p>When most people think of Qt, I imagine that they think about the Graphical User Interface components.
But Qt has a variety of other components beyond just being a GUI framework.
In this post, I highlight some of what I find to be the more interesting features.&lt;/p></description></item><item><title>Pluggable Authentication With PAM</title><link>https://robertu94.github.io/posts/2017-05-14-pluggable-authentication/</link><pubDate>Sun, 14 May 2017 10:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-05-14-pluggable-authentication/</guid><description>&lt;p>Authentication and authorization is one of foundational aspects of any security system.
However writing an authentication and authorization system can be anything but:
There are complex, ever-changing requirements, not to mention differences for differing interfaces it can quickly become daunting.
However, there already exists a system on Linux and Unix that allows for dynamic and complex authentication: PAM.&lt;/p></description></item><item><title>Resource Acquisition is Initialization and SDL</title><link>https://robertu94.github.io/posts/2017-05-08-sdl-raii/</link><pubDate>Mon, 08 May 2017 05:30:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-05-08-sdl-raii/</guid><description>&lt;p>Recently, I was working on a project for &lt;a href="brianmalloy.com">2D Game Development&lt;/a> where I had to use SDL 2.0.
SDL 2.0 is a family of media libraries designed for writing cross platform games in C.
However it can be difficult to remember where various resources are allocated and deallocated.
Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem.
So I wrote a series of wrappers for SDL 2.0 that use RAII and various other improvements.&lt;/p></description></item><item><title>Smart Pool</title><link>https://robertu94.github.io/posts/2017-04-29-smart-pool/</link><pubDate>Sun, 30 Apr 2017 09:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-04-29-smart-pool/</guid><description>&lt;p>Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development.
However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool.
In this article, I layout a class that I recently used to automatically manage memory from a pool.&lt;/p></description></item><item><title>Surprisingly Functional</title><link>https://robertu94.github.io/posts/2017-02-17-suprisingly-funtional/</link><pubDate>Thu, 23 Feb 2017 08:38:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-02-17-suprisingly-funtional/</guid><description>&lt;p>Functional programming is a surprisingly useful programming paradigm.
The best aspects of functional programming have this odd habit of showing in places you would never expect.&lt;/p></description></item><item><title>Faster than light</title><link>https://robertu94.github.io/posts/2017-01-29-faster-than-light/</link><pubDate>Sun, 29 Jan 2017 10:06:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-01-29-faster-than-light/</guid><description>&lt;p>&lt;a href="https://docs.ansible.com" target="_blank" rel="noreferrer">Ansible&lt;/a> is probably my favorite provisioning and configuration management tool.
Its syntax is concise, expressive, and elegant.
Unlike other tools in its category, it has &lt;a href="https://docs.ansible.com/ansible/playbooks_best_practices.html" target="_blank" rel="noreferrer">excellent documentation&lt;/a> with working examples and intuitive naming.
Learning it use it effectively can help you be a more productive developer.&lt;/p></description></item><item><title>LLVM Tooling for C++</title><link>https://robertu94.github.io/posts/2017-01-22-llvm-tooling/</link><pubDate>Sun, 22 Jan 2017 18:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-01-22-llvm-tooling/</guid><description>&lt;p>C++ is a both a fantastic language and a mess.
It supports at least 4 programming paradigms (procedural, functional, object-oriented, template meta-programming).
In some senses, many languages give you one great way to do things: C++ gives you every way and trusts you to use them well.
With this flexibility comes problems that C++ seems to have beyond what other languages experience.
Therefore, having effective tooling to develop and use C++ is essential.&lt;/p></description></item><item><title>Interpreters Made Easy</title><link>https://robertu94.github.io/posts/2017-01-15-interpretors-made-easy/</link><pubDate>Sun, 15 Jan 2017 10:14:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-01-15-interpretors-made-easy/</guid><description>&lt;p>The Interpreter pattern from the &lt;a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noreferrer">&amp;ldquo;Design Patterns: Elements of Reusable Object Oriented Software&amp;rdquo;&lt;/a> can potentially be a very powerful pattern.
It allows you to use a domain specific language to represent a complex computational situation.
However, writing interpreters in practice can be tricky and time consuming.
It really helps to know something about some fundamental parsing algorithms and techniques.&lt;/p></description></item><item><title>Poor Man's Parallelism</title><link>https://robertu94.github.io/posts/2017-01-08-poor-mans-parallelism/</link><pubDate>Sun, 08 Jan 2017 10:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-01-08-poor-mans-parallelism/</guid><description>&lt;p>I really like orchestration tools such as &lt;a href="https://docs.ansible.com" target="_blank" rel="noreferrer">Ansible&lt;/a> or &lt;a href="https://docs.saltstack.com" target="_blank" rel="noreferrer">SaltStack&lt;/a>.
They can make running tasks on a group of machines a breeze.
But sometimes you can&amp;rsquo;t or don&amp;rsquo;t want to install these tools on a machine.
In cases like these, it is helpful to know how to parallelize some tasks in the shell.&lt;/p></description></item></channel></rss>