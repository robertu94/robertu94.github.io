<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Learning to Learn: C++ | systems++</title>
<meta name=keywords content="Learning to Learn,Programming,C++">
<meta name=description content="C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.
Order of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/learning/cpp.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Learning to Learn: C++">
<meta property="og:description" content="C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.
Order of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/learning/cpp.html"><meta property="article:section" content="learning">
<meta property="article:published_time" content="2018-01-12T19:00:14-05:00">
<meta property="article:modified_time" content="2018-01-12T19:00:14-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Learning to Learn: C++">
<meta name=twitter:description content="C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.
Order of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Learning to Learn: C++","item":"http://robertu94.github.io/learning/cpp.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Learning to Learn: C++","name":"Learning to Learn: C\u002b\u002b","description":"C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.\nOrder of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.","keywords":["Learning to Learn","Programming","C++"],"articleBody":"C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.\nOrder of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.\nBeginning C++ Everyone needs to start somewhere, for C++ I would start here.\nFor this section, I would read at least Effective C++ and Effective Modern C++, and then I would skim the C++ Core Guidelines. Together these will give you a broad basis to learn more about C++. The other references are still useful, but maybe not as pressing.\n Effective C++ by Scott Meyers - still the best beginners book for C++ and overviews common design concerns in C++. While it focuses on C++98, much of this book still applies. Effective STL C++ by Scott Meyers - Overview the standard template libary (set of containers and algorithms included in the standard libary) and how to use the common parts effectively. More Effective C++ by Scott Meyers - Extensions to “Effective C++” but more special purpose than the base book. While it focuses on C++98, much of this book still applies. Modern Effective C++ by Scott Meyers - How to effectively use new features in C++11 which radically modernized the language. C++ Core Guidelines - How to effectively use newer parts of the language.  Standard Library It almost goes without saying that the C++ Standard library is incredibly useful, and you should almost always start here. Its not as complete as say Python’s standard library, but its far more flexible. I would use cppreference.com or devdoc.io to read documentation on the standard library.\nI would at least know about the following core objects in the standard library ordered by how roughly important I find them.\n   Name Use      generally useful functions   unique_ptr pointers that are the only reference to an object in memory   shared_ptr pointers that automatically count references   format a typesafe printf-like alterative to iostreams   array a statically allocated array with handy bindings   vector a dynamically resizing array   map key value store, often implemented as a red-black tree   unordered_map key value store, often implemented as a hash table   set key store, often implemented as a red-black tree   unordered_set key store, often implemented as a hash table   Iterator Concepts/Ranges simplifies accessing members of a collection   string dynamically resizing character data   span a nonowning view into an existing container   string_view a non-owning reference to character data   tuple a generic version of a struct useful for generic programming   list a doublely linked list   ostream output to file, string, or stdout   istream input from file, string, stdin   exception indicates extra-ordinary circumstances    Build Systems and the C++ Ecosystem Tools are important to getting actual work done while programming. Because of the nature of C++ I find that it has and need more types of tools than you may have used in other languages. I target this section to Linux/Unix platforms because it is what I use most often. When I list multiple tools, you generally only need one, and I list them in order of personal preference.\nFor this section, read what each class of tool does; then use it as a reference when you need an instance of that kind of tool. By no means is this a comprehensive list.\n   Purpose Tool Why     Backend Builder Ninja Much faster than Make   Backend Builder Make Incredibly common on Unix platforms   Backend Builder Bear Generates compile-commands.json files for other projects   Build System Meson Easy to use, Very fast   Build System CMake More easy to use   Build System Autotools Works on esoteric platforms where other choke   Compile Cache ccache Dramatically speeds up incremental builds   Distributed Builds icecc/icecream Spread builds out to a server of faster machines   Code Formatting clang-format Easy, Highly customizeable, sane defaults   Compilers clang Better Error messages, clang/llvm Ecosystem   Compilers GCC g++ Currently still faster, more common   IDE Integratin clangd Clang based IDE integration shows warnings and advice   Debugger lldb Highly programmable, handles templates well, easy to use   Debugger gdb The standard debugger, esoteric interface   Debugger templight Specialized debugger for compile time C++ code   Debugger metashell An older, ease of use tool built atop templight   Indexing Exhuberant Ctags The de facto tool for this job   Linting clang-tidy Most extensive and “correct” linter   Profiling perf Linux Specific, Extremely robust, easy to use   Searching ag/ripgrep insanely fast, sane defaults, not syntactic sensitive   Searching clang-query Slow, semantic sensitive   Searching grep Common, pretty fast, not semantic sensitive   Tracer ltrace Trace shared library calls   Tracer strace Trace system calls   Tracer dtrace Trace/Profile kernel and elsewhere, not widely available   Tracer llvm-xray Tracer with similar design principles to dtrace, but requires recompilation and is more available   Leak Checking Leak Sanitizer locate various memory leaks in programs   Undefined Behavior Checking Address Sanitizer locate various memory misuses in programs   Undefined Behavior Checking Memory Sanitizer locate uninitialized reads in programs   Undefined Behavior Checking UndefinedBehavior Sanitizer locate other undefined behavior in programs   Undefined Behavior Checking Thread Sanitizer locate data races in programs   Package Manager Spack Package manager focused on HPC; Similar to PIP   Package Manager VcPkg/Connan/Wraptool C++ centric package managers; you miliage may very depending your usecase    I’ve recently added a learning to learn document for CMake\nYou’ll also eventually decide that you need/want some libraries to get useful work done. This post would be remiss if I didn’t mention a few cross cutting libraries.\n Boost - a family of libraries that stretch the limits of what C++ can do. Libraries from Boost often become standardized. The best reference I have found is The Boost C++ libraries book. Qt - While primarily a UI toolkit, it features a bunch of useful features. The online documentation is great. Abseil - Google’s take on a general purpose library. Provides backward compatibility for new standard concepts. The comprehensive docs are sparse, but the code is well documented.  Here is a list of other libraries that I have used and would recommend.\n   Purpose Library Why     Commandline parsing getopt Very common command line parser, very portable, not pretty   Unit Testing Google Test Very common testing tool, easy to use   Benchmarking Google Benchmark Very common benchmarking tool, easy to use   Networking Protobuf/gRPC Networking Server/Communication framework   Networking Boost.ASIO De facto C++ native networking library   Networking sys/socket.h Still works, arguably simpler than ASIO   Graphs Boost.Graph Tons of standard graph algorithms and structures   Date Math date.h Incredibly fast, easy to use; now in the standard library   JSON/XML Parsing Boost.PropertyTree Easy to use   Distributed Programming HPX A different take on HPC; I would argue easier to use   Distributed Programming Boost.MPI More native than standard MPI; fewer interfaces   Distributed Programming OpenMPI Very flexible    Profiling and Speeding up C++ builds C++ can take a long time to build especially when your code is really template heavy. First just adopt ccache, it will dramatically speed things up for you for incremental builds.\nHere is how I profile C++ builds. First if you are using ninja, you can clean your build, delete your .ninja_log file, and run your build. This will populate this file with a log of the build process. Next, You can extract timings for the build using this ninja stats script written in AWK. Once you’ve narrowed down your search to a few files, you can use clang’s -ftime-trace to get a detailed view of what is taking so long to compile/instantiate. See The Blog post “time-trace: timeline / flame chart profiler for Clang” for more information about how to use these traces.\nOnce you’ve made as many changes to your problematic structures and functions as you can, you may further reduce build times by using “precompiled headers” and “unity builds”. Precompiled headers work by serializing the compilers internal state so that the parsing phase of C++ can be skipped. Unity builds reduce the time required to instantiate identical headers by grouping source files for compilation. These both are not without their drawbacks for tooling which relies on source file names such as clangd, but I am hopeful that both of these techniques will be obviated with C++20 modules while improving the tooling situation. However, at time of writing, C++20 modules are not yet completely implemented by most major compilers.\nObject-Oriented C++ C++ has a uniquely complicated object oriented system. Most of this is due to the use of templates for generic programming and Turing-completeness of templates.\nFor this section, the ordering is less important. Several of these books apply to more than just C++, but are especially important in a language as verbose as C++.\n “Design Patterns Elements of Reusable Software” by the “Gang of Four” - before the pitch-forks come out: 1) the examples of patterns in this book are often in C++, 2) object-oriented programming is object-oriented programming, and it doesn’t change much from language to language. I also find that most people struggle in OO to reinvent the wheel labeled by these four in 1994. It changed the way that I structure programs that I write. “Refactoring: Improving the Design of Existing Software” by Martin Fowler - over the course of learning C++ you’ll discover that you’ve done horrible, terrible things. This book while targeted at a general audience will help you fix them. It also puts the proper focus on usable, understandable interfaces and code over the spaghetti I often see in new C++ developers. The Pimpl Idiom - Pointer to Implementation is a powerful technique to reduce compile time dependancies. Read the set of two articles entitled “Compilation Firewalls” by Herb Sutter. The RAII Pattern - Resource Acquisition is Initialization is a fundamental to memory and exception safe programming in C++. Read the article about RAII on CPP Reference. Modern C++ Design: Generic Programming and Design Patterns Applied by Andrei Alexandrescu - One of the few uniquely C++ Object-Oriented books I have read. It assumes a fair bit of knowledge on generics and templates so read about it first. Metaclasses: Thoughts on Generative C++ by Herb Sutter - This video highlights were object oriented C++ is going at time of writing in early 2018.  Generic C++ and Templates Generics and Templates are among C++ most powerful features. Every C++ programmer should know the basics.\nFor this section, the ordering is especially important, the later items are quite advanced and build on the previous items.\n “C++ Templates the Complete Guide” by David Vandevoorde, Nicolai M. Josuttis, and Douglas Gregor - An easy as possible introduction to the sometimes black magic of C++ templates. Curiously Recurring Template Pattern - while discussed in the Vandevoorde book, I found the article, “Polymorphic Clones in Modern C++\" by Jonathan Boccara a much more practical example of where this may be used. “Modern C++ Design: Generic Programming and Design Patterns Applied” by Andrei Alexandrescu - I listed this in the object-oriented section, but this book opened my eyes the possibilities of C++ templates and generic programming in general.  If you can’t figure out why a particular template won’t compile, consider using templight or metashell.\nFunctional C++ This is an evolving category of C++. As such, I expect these to be much more in the coming years.\nFor this section, I would read all of the articles, they are not too long.\n lambda expressions - a key building block for functional programming in C++. Read the CPP reference documentation on lambdas. std::function - a generic means of storing type-specified references to a function. Read CPP references documentation on std::function  - a example of a library that makes extensive use of functional concepts. Read CPP references documentation on   What next? When you’ve read most of the above, and are still looking to improve, I use the following to stay sharp.\n CPPCon - the yearly C++ developers conference. Filled with thought provoking talks and most are on YouTube. Read llvm’s libtooling, clang’s libC++ or Google’s abseil source code to see clear examples of well-written C++ code. Read the C++ Standard - it’s not for the feint of heart. The final version is behind a pay-wall, but the drafts are not. Read this if you want to understand some of the deeper behaviors of C++. C++Weekly - A video podcast that overviews different aspects of C++ in bite size chunks. CPP Cast - An audio podcast that covers upcoming C++ news  Suggestions to Learn the language I have two key suggestions to learn the language:\n Start small: choose a subset of the language that you want to learn well. The language is too large for most if not all people to be an expert on all parts of the language. Somethings like parameter passing should be in everyone’s subset, but the oddities of std::atomic, vector or the CRTP probably don’t need to be. Expand your subset as needed: choose a series of small projects that motivate why you want to learn various aspects of the language. This will help you practice and remember what you’ve learned.  I hope you find this useful. Until next time!\nChange Notes  2020 - Added section on build profiling, updated tools, library components to learn, and further resources 2018 - Initial version  ","wordCount":"2224","inLanguage":"en","datePublished":"2018-01-12T19:00:14-05:00","dateModified":"2018-01-12T19:00:14-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/learning/cpp.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Learning to Learn: C++
</h1>
<div class=post-meta><span title="2018-01-12 19:00:14 -0500 -0500">January 12, 2018</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2224 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#order-of-topics>Order of Topics</a>
<ul>
<li><a href=#beginning-c>Beginning C++</a></li>
<li><a href=#standard-library>Standard Library</a></li>
<li><a href=#build-systems-and-the-c-ecosystem>Build Systems and the C++ Ecosystem</a></li>
<li><a href=#profiling-and-speeding-up-c-builds>Profiling and Speeding up C++ builds</a></li>
<li><a href=#object-oriented-c>Object-Oriented C++</a></li>
<li><a href=#generic-c-and-templates>Generic C++ and Templates</a></li>
<li><a href=#functional-c>Functional C++</a></li>
<li><a href=#what-next>What next?</a></li>
</ul>
</li>
<li><a href=#suggestions-to-learn-the-language>Suggestions to Learn the language</a>
<ul>
<li><a href=#change-notes>Change Notes</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.</p>
<h1 id=order-of-topics>Order of Topics<a hidden class=anchor aria-hidden=true href=#order-of-topics>#</a></h1>
<p>This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.</p>
<h2 id=beginning-c>Beginning C++<a hidden class=anchor aria-hidden=true href=#beginning-c>#</a></h2>
<p>Everyone needs to start somewhere, for C++ I would start here.</p>
<p>For this section, I would read at least Effective C++ and Effective Modern C++, and then I would skim the C++ Core Guidelines. Together these will give you a broad basis to learn more about C++. The other references are still useful, but maybe not as pressing.</p>
<ol>
<li>Effective C++ by Scott Meyers - still the best beginners book for C++ and overviews common design concerns in C++. While it focuses on C++98, much of this book still applies.</li>
<li>Effective STL C++ by Scott Meyers - Overview the standard template libary (set of containers and algorithms included in the standard libary) and how to use the common parts effectively.</li>
<li>More Effective C++ by Scott Meyers - Extensions to &ldquo;Effective C++&rdquo; but more special purpose than the base book. While it focuses on C++98, much of this book still applies.</li>
<li>Modern Effective C++ by Scott Meyers - How to effectively use new features in C++11 which radically modernized the language.</li>
<li><a href=https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md>C++ Core Guidelines</a> - How to effectively use newer parts of the language.</li>
</ol>
<h2 id=standard-library>Standard Library<a hidden class=anchor aria-hidden=true href=#standard-library>#</a></h2>
<p>It almost goes without saying that the C++ Standard library is incredibly useful, and you should almost always start here. Its not as complete as say Python&rsquo;s standard library, but its far more flexible. I would use <a href=http://en.cppreference.com/w/>cppreference.com</a> or <a href=https://devdocs.io/>devdoc.io</a> to read documentation on the standard library.</p>
<p>I would at least know about the following core objects in the standard library ordered by how roughly important I find them.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;algoritm></code></td>
<td>generally useful functions</td>
</tr>
<tr>
<td>unique_ptr</td>
<td>pointers that are the only reference to an object in memory</td>
</tr>
<tr>
<td>shared_ptr</td>
<td>pointers that automatically count references</td>
</tr>
<tr>
<td>format</td>
<td>a typesafe printf-like alterative to iostreams</td>
</tr>
<tr>
<td>array</td>
<td>a statically allocated array with handy bindings</td>
</tr>
<tr>
<td>vector</td>
<td>a dynamically resizing array</td>
</tr>
<tr>
<td>map</td>
<td>key value store, often implemented as a red-black tree</td>
</tr>
<tr>
<td>unordered_map</td>
<td>key value store, often implemented as a hash table</td>
</tr>
<tr>
<td>set</td>
<td>key store, often implemented as a red-black tree</td>
</tr>
<tr>
<td>unordered_set</td>
<td>key store, often implemented as a hash table</td>
</tr>
<tr>
<td>Iterator Concepts/Ranges</td>
<td>simplifies accessing members of a collection</td>
</tr>
<tr>
<td>string</td>
<td>dynamically resizing character data</td>
</tr>
<tr>
<td>span</td>
<td>a nonowning view into an existing container</td>
</tr>
<tr>
<td>string_view</td>
<td>a non-owning reference to character data</td>
</tr>
<tr>
<td>tuple</td>
<td>a generic version of a struct useful for generic programming</td>
</tr>
<tr>
<td>list</td>
<td>a doublely linked list</td>
</tr>
<tr>
<td>ostream</td>
<td>output to file, string, or stdout</td>
</tr>
<tr>
<td>istream</td>
<td>input from file, string, stdin</td>
</tr>
<tr>
<td>exception</td>
<td>indicates extra-ordinary circumstances</td>
</tr>
</tbody>
</table>
<h2 id=build-systems-and-the-c-ecosystem>Build Systems and the C++ Ecosystem<a hidden class=anchor aria-hidden=true href=#build-systems-and-the-c-ecosystem>#</a></h2>
<p>Tools are important to getting actual work done while programming. Because of the nature of C++ I find that it has and need more types of tools than you may have used in other languages. I target this section to Linux/Unix platforms because it is what I use most often. When I list multiple tools, you generally only need one, and I list them in order of personal preference.</p>
<p>For this section, read what each class of tool does; then use it as a reference when you need an instance of that kind of tool. By no means is this a comprehensive list.</p>
<table>
<thead>
<tr>
<th>Purpose</th>
<th>Tool</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Backend Builder</td>
<td>Ninja</td>
<td>Much faster than Make</td>
</tr>
<tr>
<td>Backend Builder</td>
<td>Make</td>
<td>Incredibly common on Unix platforms</td>
</tr>
<tr>
<td>Backend Builder</td>
<td>Bear</td>
<td>Generates <code>compile-commands.json</code> files for other projects</td>
</tr>
<tr>
<td>Build System</td>
<td>Meson</td>
<td>Easy to use, Very fast</td>
</tr>
<tr>
<td>Build System</td>
<td>CMake</td>
<td>More easy to use</td>
</tr>
<tr>
<td>Build System</td>
<td>Autotools</td>
<td>Works on esoteric platforms where other choke</td>
</tr>
<tr>
<td>Compile Cache</td>
<td>ccache</td>
<td>Dramatically speeds up incremental builds</td>
</tr>
<tr>
<td>Distributed Builds</td>
<td>icecc/icecream</td>
<td>Spread builds out to a server of faster machines</td>
</tr>
<tr>
<td>Code Formatting</td>
<td>clang-format</td>
<td>Easy, Highly customizeable, sane defaults</td>
</tr>
<tr>
<td>Compilers</td>
<td>clang</td>
<td>Better Error messages, clang/llvm Ecosystem</td>
</tr>
<tr>
<td>Compilers</td>
<td>GCC <code>g++</code></td>
<td>Currently still faster, more common</td>
</tr>
<tr>
<td>IDE Integratin</td>
<td>clangd</td>
<td>Clang based IDE integration shows warnings and advice</td>
</tr>
<tr>
<td>Debugger</td>
<td>lldb</td>
<td>Highly programmable, handles templates well, easy to use</td>
</tr>
<tr>
<td>Debugger</td>
<td>gdb</td>
<td>The standard debugger, esoteric interface</td>
</tr>
<tr>
<td>Debugger</td>
<td>templight</td>
<td>Specialized debugger for compile time C++ code</td>
</tr>
<tr>
<td>Debugger</td>
<td>metashell</td>
<td>An older, ease of use tool built atop templight</td>
</tr>
<tr>
<td>Indexing</td>
<td>Exhuberant Ctags</td>
<td>The de facto tool for this job</td>
</tr>
<tr>
<td>Linting</td>
<td>clang-tidy</td>
<td>Most extensive and &ldquo;correct&rdquo; linter</td>
</tr>
<tr>
<td>Profiling</td>
<td>perf</td>
<td>Linux Specific, Extremely robust, easy to use</td>
</tr>
<tr>
<td>Searching</td>
<td>ag/ripgrep</td>
<td>insanely fast, sane defaults, not syntactic sensitive</td>
</tr>
<tr>
<td>Searching</td>
<td>clang-query</td>
<td>Slow, semantic sensitive</td>
</tr>
<tr>
<td>Searching</td>
<td>grep</td>
<td>Common, pretty fast, not semantic sensitive</td>
</tr>
<tr>
<td>Tracer</td>
<td>ltrace</td>
<td>Trace shared library calls</td>
</tr>
<tr>
<td>Tracer</td>
<td>strace</td>
<td>Trace system calls</td>
</tr>
<tr>
<td>Tracer</td>
<td>dtrace</td>
<td>Trace/Profile kernel and elsewhere, not widely available</td>
</tr>
<tr>
<td>Tracer</td>
<td>llvm-xray</td>
<td>Tracer with similar design principles to dtrace, but requires recompilation and is more available</td>
</tr>
<tr>
<td>Leak Checking</td>
<td>Leak Sanitizer</td>
<td>locate various memory leaks in programs</td>
</tr>
<tr>
<td>Undefined Behavior Checking</td>
<td>Address Sanitizer</td>
<td>locate various memory misuses in programs</td>
</tr>
<tr>
<td>Undefined Behavior Checking</td>
<td>Memory Sanitizer</td>
<td>locate uninitialized reads in programs</td>
</tr>
<tr>
<td>Undefined Behavior Checking</td>
<td>UndefinedBehavior Sanitizer</td>
<td>locate other undefined behavior in programs</td>
</tr>
<tr>
<td>Undefined Behavior Checking</td>
<td>Thread Sanitizer</td>
<td>locate data races in programs</td>
</tr>
<tr>
<td>Package Manager</td>
<td>Spack</td>
<td>Package manager focused on HPC; Similar to PIP</td>
</tr>
<tr>
<td>Package Manager</td>
<td>VcPkg/Connan/Wraptool</td>
<td>C++ centric package managers; you miliage may very depending your usecase</td>
</tr>
</tbody>
</table>
<p>I&rsquo;ve recently added a learning to learn document for <a href=http://robertu94.github.io/learning/cmake.html>CMake</a></p>
<p>You&rsquo;ll also eventually decide that you need/want some libraries to get useful work done.
This post would be remiss if I didn&rsquo;t mention a few cross cutting libraries.</p>
<ul>
<li>Boost - a family of libraries that stretch the limits of what C++ can do. Libraries from Boost often become standardized. The best reference I have found is <a href=https://theboostcpplibraries.com/>The Boost C++ libraries book</a>.</li>
<li>Qt - While primarily a UI toolkit, it features a bunch of useful features. The <a href=https://doc.qt.io/>online documentation</a> is great.</li>
<li>Abseil - Google&rsquo;s take on a general purpose library. Provides backward compatibility for new standard concepts. The <a href=https://abseil.io/docs/cpp.html>comprehensive docs</a> are sparse, but the code is well documented.</li>
</ul>
<p>Here is a list of other libraries that I have used and would recommend.</p>
<table>
<thead>
<tr>
<th>Purpose</th>
<th>Library</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commandline parsing</td>
<td>getopt</td>
<td>Very common command line parser, very portable, not pretty</td>
</tr>
<tr>
<td>Unit Testing</td>
<td>Google Test</td>
<td>Very common testing tool, easy to use</td>
</tr>
<tr>
<td>Benchmarking</td>
<td>Google Benchmark</td>
<td>Very common benchmarking tool, easy to use</td>
</tr>
<tr>
<td>Networking</td>
<td>Protobuf/gRPC</td>
<td>Networking Server/Communication framework</td>
</tr>
<tr>
<td>Networking</td>
<td>Boost.ASIO</td>
<td>De facto C++ native networking library</td>
</tr>
<tr>
<td>Networking</td>
<td>sys/socket.h</td>
<td>Still works, arguably simpler than ASIO</td>
</tr>
<tr>
<td>Graphs</td>
<td>Boost.Graph</td>
<td>Tons of standard graph algorithms and structures</td>
</tr>
<tr>
<td>Date Math</td>
<td>date.h</td>
<td>Incredibly fast, easy to use; now in the standard library</td>
</tr>
<tr>
<td>JSON/XML Parsing</td>
<td>Boost.PropertyTree</td>
<td>Easy to use</td>
</tr>
<tr>
<td>Distributed Programming</td>
<td>HPX</td>
<td>A different take on HPC; I would argue easier to use</td>
</tr>
<tr>
<td>Distributed Programming</td>
<td>Boost.MPI</td>
<td>More native than standard MPI; fewer interfaces</td>
</tr>
<tr>
<td>Distributed Programming</td>
<td>OpenMPI</td>
<td>Very flexible</td>
</tr>
</tbody>
</table>
<h2 id=profiling-and-speeding-up-c-builds>Profiling and Speeding up C++ builds<a hidden class=anchor aria-hidden=true href=#profiling-and-speeding-up-c-builds>#</a></h2>
<p>C++ can take a long time to build especially when your code is really template heavy.
First just adopt ccache, it will dramatically speed things up for you for incremental builds.</p>
<p>Here is how I profile C++ builds.
First if you are using <code>ninja</code>, you can clean your build, delete your <code>.ninja_log</code> file, and run your build.
This will populate this file with a log of the build process.
Next, You can extract timings for the build using <a href=https://github.com/ninja-build/ninja/issues/1080#issuecomment-255436851%60>this ninja stats script written in AWK</a>.
Once you&rsquo;ve narrowed down your search to a few files, you can use clang&rsquo;s <code>-ftime-trace</code> to get a detailed view of what is taking so long to compile/instantiate.
See <a href=https://aras-p.info/blog/2019/01/16/time-trace-timeline-flame-chart-profiler-for-Clang/>The Blog post &ldquo;time-trace: timeline / flame chart profiler for Clang&rdquo;</a> for more information about how to use these traces.</p>
<p>Once you&rsquo;ve made as many changes to your problematic structures and functions as you can, you may further reduce build times by using &ldquo;precompiled headers&rdquo; and &ldquo;unity builds&rdquo;. Precompiled headers work by serializing the compilers internal state so that the parsing phase of C++ can be skipped. Unity builds reduce the time required to instantiate identical headers by grouping source files for compilation. These both are not without their drawbacks for tooling which relies on source file names such as clangd, but I am hopeful that both of these techniques will be obviated with C++20 modules while improving the tooling situation. However, at time of writing, C++20 modules are not yet completely implemented by most major compilers.</p>
<h2 id=object-oriented-c>Object-Oriented C++<a hidden class=anchor aria-hidden=true href=#object-oriented-c>#</a></h2>
<p>C++ has a uniquely complicated object oriented system. Most of this is due to the use of templates for generic programming and Turing-completeness of templates.</p>
<p>For this section, the ordering is less important. Several of these books apply to more than just C++, but are especially important in a language as verbose as C++.</p>
<ol>
<li>&ldquo;Design Patterns Elements of Reusable Software&rdquo; by the &ldquo;Gang of Four&rdquo; - before the pitch-forks come out: 1) the examples of patterns in this book are often in C++, 2) object-oriented programming is object-oriented programming, and it doesn&rsquo;t change much from language to language. I also find that most people struggle in OO to reinvent the wheel labeled by these four in 1994. It changed the way that I structure programs that I write.</li>
<li>&ldquo;Refactoring: Improving the Design of Existing Software&rdquo; by Martin Fowler - over the course of learning C++ you&rsquo;ll discover that you&rsquo;ve done horrible, terrible things. This book while targeted at a general audience will help you fix them. It also puts the proper focus on usable, understandable interfaces and code over the spaghetti I often see in new C++ developers.</li>
<li>The Pimpl Idiom - Pointer to Implementation is a powerful technique to reduce compile time dependancies. Read the set of <a href=https://herbsutter.com/gotw/>two articles</a> entitled &ldquo;Compilation Firewalls&rdquo; by Herb Sutter.</li>
<li>The RAII Pattern - Resource Acquisition is Initialization is a fundamental to memory and exception safe programming in C++. Read the <a href=http://en.cppreference.com/w/cpp/language/raii>article about RAII</a> on CPP Reference.</li>
<li>Modern C++ Design: Generic Programming and Design Patterns Applied by Andrei Alexandrescu - One of the few uniquely C++ Object-Oriented books I have read. It assumes a fair bit of knowledge on generics and templates so read about it first.</li>
<li><a href="https://www.youtube.com/watch?v=4AfRAVcThyA">Metaclasses: Thoughts on Generative C++</a> by Herb Sutter - This video highlights were object oriented C++ is going at time of writing in early 2018.</li>
</ol>
<h2 id=generic-c-and-templates>Generic C++ and Templates<a hidden class=anchor aria-hidden=true href=#generic-c-and-templates>#</a></h2>
<p>Generics and Templates are among C++ most powerful features. Every C++ programmer should know the basics.</p>
<p>For this section, the ordering is especially important, the later items are quite advanced and build on the previous items.</p>
<ol>
<li>&ldquo;C++ Templates the Complete Guide&rdquo; by David Vandevoorde, Nicolai M. Josuttis, and Douglas Gregor - An easy as possible introduction to the sometimes black magic of C++ templates.</li>
<li>Curiously Recurring Template Pattern - while discussed in the Vandevoorde book, I found the article, <a href=https://www.fluentcpp.com/2017/09/08/make-polymorphic-copy-modern-cpp/>&ldquo;Polymorphic Clones in Modern C++"</a> by Jonathan Boccara a much more practical example of where this may be used.</li>
<li>&ldquo;Modern C++ Design: Generic Programming and Design Patterns Applied&rdquo; by Andrei Alexandrescu - I listed this in the object-oriented section, but this book opened my eyes the possibilities of C++ templates and generic programming in general.</li>
</ol>
<p>If you can&rsquo;t figure out why a particular template won&rsquo;t compile, consider using templight or metashell.</p>
<h2 id=functional-c>Functional C++<a hidden class=anchor aria-hidden=true href=#functional-c>#</a></h2>
<p>This is an evolving category of C++. As such, I expect these to be much more in the coming years.</p>
<p>For this section, I would read all of the articles, they are not too long.</p>
<ol>
<li>lambda expressions - a key building block for functional programming in C++. Read the <a href=http://en.cppreference.com/w/cpp/language/lambda>CPP reference documentation on lambdas</a>.</li>
<li><code>std::function</code> - a generic means of storing type-specified references to a function. Read <a href=http://en.cppreference.com/w/cpp/utility/functional>CPP references documentation on std::function</a></li>
<li><code>&lt;algorithm></code> - a example of a library that makes extensive use of functional concepts. Read <a href=http://en.cppreference.com/w/cpp/algorithm>CPP references documentation on &lt;algorithm></a></li>
</ol>
<h2 id=what-next>What next?<a hidden class=anchor aria-hidden=true href=#what-next>#</a></h2>
<p>When you&rsquo;ve read most of the above, and are still looking to improve, I use the following to stay sharp.</p>
<ol>
<li>CPPCon - the yearly C++ developers conference. Filled with thought provoking talks and most are on YouTube.</li>
<li>Read llvm&rsquo;s <code>libtooling</code>, clang&rsquo;s <code>libC++</code> or Google&rsquo;s <code>abseil</code> source code to see clear examples of well-written C++ code.</li>
<li>Read the C++ Standard - it&rsquo;s not for the feint of heart. The final version is behind a pay-wall, but the drafts are not. Read this if you want to understand some of the deeper behaviors of C++.</li>
<li>C++Weekly - A video podcast that overviews different aspects of C++ in bite size chunks.</li>
<li>CPP Cast - An audio podcast that covers upcoming C++ news</li>
</ol>
<h1 id=suggestions-to-learn-the-language>Suggestions to Learn the language<a hidden class=anchor aria-hidden=true href=#suggestions-to-learn-the-language>#</a></h1>
<p>I have two key suggestions to learn the language:</p>
<ol>
<li>Start small: choose a subset of the language that you want to learn well. The language is too large for most if not all people to be an expert on all parts of the language. Somethings like parameter passing should be in everyone&rsquo;s subset, but the oddities of <code>std::atomic&lt;></code>, <code>vector&lt;bool></code> or the CRTP probably don&rsquo;t need to be.</li>
<li>Expand your subset as needed: choose a series of small projects that motivate why you want to learn various aspects of the language. This will help you practice and remember what you&rsquo;ve learned.</li>
</ol>
<p>I hope you find this useful. Until next time!</p>
<h2 id=change-notes>Change Notes<a hidden class=anchor aria-hidden=true href=#change-notes>#</a></h2>
<ul>
<li>2020 - Added section on build profiling, updated tools, library components to learn, and further resources</li>
<li>2018 - Initial version</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/learning-to-learn.html>Learning to Learn</a></li>
<li><a href=http://robertu94.github.io/tags/programming.html>Programming</a></li>
<li><a href=http://robertu94.github.io/tags/c++.html>C++</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>