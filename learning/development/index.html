<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#FFFFFF"><title>Learning to Learn: Software Development on Linux &#183; Systems++</title>
<meta name=title content="Learning to Learn: Software Development on Linux &#183; Systems++"><script type=text/javascript src=/js/appearance.min.8a082f81b27f3cb2ee528df0b0bdc39787034cf2cc34d4669fbc9977c929023c.js integrity="sha256-iggvgbJ/PLLuUo3wsL3Dl4cDTPLMNNRmn7yZd8kpAjw="></script><link type=text/css rel=stylesheet href=/css/main.bundle.min.f5d02fd21ba62de62cf162b932a2a9bf2ea60bb62b0c8226cfa8734afb546691.css integrity="sha256-9dAv0humLeYs8WK5MqKpvy6mC7YrDIImz6hzSvtUZpE="><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.f4243e18b1f012d4086a1c8588e367983174063418141921d1fe6f6fdbfa6eca.js integrity="sha256-9CQ+GLHwEtQIahyFiONnmDF0BjQYFBkh0f5vb9v6bso=" data-copy=Copy data-copied=Copied></script><meta name=description content="
      
        What is software development?
At a most basic level, it is the activity of using a programming language to achieve some set of goals over time.
It includes everything from scripts that a graduate student might write to analyze some data to massive systems that control aircraft.
As our world continues to progress technically, software development will likely become even more commonplace than it is now.
In this post, I aim to provide a comprehensive overview of how one can develop software efficiently using free and open source tools on Linux.
      
    "><link rel=canonical href=https://robertu94.github.io/learning/development/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:url" content="https://robertu94.github.io/learning/development/"><meta property="og:site_name" content="Systems++"><meta property="og:title" content="Learning to Learn: Software Development on Linux"><meta property="og:description" content="What is software development? At a most basic level, it is the activity of using a programming language to achieve some set of goals over time. It includes everything from scripts that a graduate student might write to analyze some data to massive systems that control aircraft. As our world continues to progress technically, software development will likely become even more commonplace than it is now. In this post, I aim to provide a comprehensive overview of how one can develop software efficiently using free and open source tools on Linux."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="learning"><meta property="article:published_time" content="2023-01-22T08:00:00-05:00"><meta property="article:modified_time" content="2023-01-22T08:00:00-05:00"><meta property="article:tag" content="Learning to Learn"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Software Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning to Learn: Software Development on Linux"><meta name=twitter:description content="What is software development? At a most basic level, it is the activity of using a programming language to achieve some set of goals over time. It includes everything from scripts that a graduate student might write to analyze some data to massive systems that control aircraft. As our world continues to progress technically, software development will likely become even more commonplace than it is now. In this post, I aim to provide a comprehensive overview of how one can develop software efficiently using free and open source tools on Linux."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","articleSection":"","name":"Learning to Learn: Software Development on Linux","headline":"Learning to Learn: Software Development on Linux","abstract":"\u003cp\u003eWhat is software development?\nAt a most basic level, it is the activity of using a programming language to achieve some set of goals over time.\nIt includes everything from scripts that a graduate student might write to analyze some data to massive systems that control aircraft.\nAs our world continues to progress technically, software development will likely become even more commonplace than it is now.\nIn this post, I aim to provide a comprehensive overview of how one can develop software efficiently using free and open source tools on Linux.\u003c\/p\u003e","inLanguage":"en","url":"https:\/\/robertu94.github.io\/learning\/development\/","author":{"@type":"Person","name":"Robert Underwood"},"copyrightYear":"2023","dateCreated":"2023-01-22T08:00:00-05:00","datePublished":"2023-01-22T08:00:00-05:00","dateModified":"2023-01-22T08:00:00-05:00","keywords":["Learning to Learn","Linux","Software Engineering"],"mainEntityOfPage":"true","wordCount":"15089"}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://robertu94.github.io/","name":"Systems","position":1},{"@type":"ListItem","item":"https://robertu94.github.io/learning/","name":"","position":2},{"@type":"ListItem","name":"Learning to Learn Software Development on Linux","position":3}]}</script><meta name=author content="Robert Underwood"><link href=https://github.com/robertu94 rel=me><link href=mailto:rr.underwood94@gmail.com rel=me><link href=/about rel=me><link href="https://scholar.google.com/citations?user=GbhfWUIAAAAJ&amp;hl=en" rel=me><link href=https://orcid.org/0000-0002-1464-729X rel=me><link href=https://www.youtube.com/@robertunderwood97 rel=me><link href=https://keybase.io/robertu94 rel=me></head><body class="m-auto flex h-screen max-w-7xl flex-col bg-neutral px-6 text-lg leading-7 text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="-translate-y-8 rounded-b-lg bg-primary-200 px-3 py-1 text-sm focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="pe-2 font-bold text-primary-600 dark:text-primary-400">&darr;</span>Skip to main content</a></div><header class="py-6 font-semibold text-neutral-900 dark:text-neutral sm:py-10 print:hidden"><nav class="flex items-start justify-between sm:items-center"><div class="flex flex-row items-center"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>Systems++</a></div><ul class="flex list-none flex-col text-end sm:flex-row"><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/about/ title="About Me"><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">About</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/posts/ title=Posts><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Blog</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/guides/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Guides</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0.5"><a href=/learning/ title><span class="decoration-primary-500 group-hover:underline group-hover:decoration-2 group-hover:underline-offset-2">Learning To Learn</span></a></li><li class="group mb-1 sm:mb-0 sm:me-7 sm:last:me-0"><button id=search-button-m0 title="Search (/)">
<span class="group-dark:hover:text-primary-400 transition-colors group-hover:text-primary-600"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></span></button></li></ul></nav></header><div class="relative flex grow flex-col"><main id=main-content class=grow><article><header class=max-w-prose><h1 class="mb-8 mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Learning to Learn: Software Development on Linux</h1><div class="mb-10 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2023-01-22 08:00:00 -0500 -0500">22 January 2023</time><span class="px-2 text-primary-500">&#183;</span><span>15089 words</span><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">71 mins</span></div></div></header><section class="prose mt-0 flex max-w-full flex-col dark:prose-invert lg:flex-row"><div class="order-first px-0 lg:order-last lg:max-w-xs lg:ps-8"><div class="toc pe-5 lg:sticky lg:top-10 print:hidden"><details open class="-ms-5 mt-0 overflow-hidden rounded-lg ps-5"><summary class="block cursor-pointer bg-neutral-100 py-1 ps-5 text-lg font-semibold text-neutral-800 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="border-s border-dotted border-neutral-300 py-2 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#what-are-requirements>What are requirements?</a></li><li><a href=#what-are-_good_-requirements>What are <em>good</em> requirements?</a></li><li><a href=#stakeholders-who-makes-the-decisions>Stakeholders: Who makes the decisions?</a></li></ul><ul><li><a href=#how-do-i-get-better-at-design-study-existing-designs>How do I get better at design? Study existing designs</a></li><li><a href=#what-lessons-have-i-learned>What Lessons Have I Learned?</a><ul><li><a href=#quality-attributes-a-powerful-way-to-think-about-non-functional-requirements>Quality Attributes: A powerful way to think about non-functional requirements</a></li><li><a href=#diagramming-a-quick-picture-is-worth-a-hundred-hours>Diagramming: A Quick Picture is Worth a Hundred Hours</a></li><li><a href=#blank-baling-the-art-and-value-of-prototyping>Blank Baling: The Art and Value of Prototyping</a></li><li><a href=#focus-on-the-interface-api-design-reviews>Focus on the interface: API Design Reviews</a></li><li><a href=#good-requirements-problems-with-not-invented-here-and-never-invent-here>Good Requirements: Problems with Not Invented Here and Never Invent Here</a></li><li><a href=#rational-expectations-preparing-for-the-future-versus-yagni-you-aint-gonna-need-it>Rational Expectations: Preparing for the Future versus YAGNI (You Ain&rsquo;t Gonna Need It)</a></li><li><a href=#refactoring-improving-the-design-of-existing-software>Refactoring: Improving the Design of Existing Software</a></li><li><a href=#security-and-threat-modeling-thinking-about-confidentiality-integrity-and-availability>Security and Threat Modeling: thinking about confidentiality, integrity, and availability,</a></li></ul></li><li><a href=#what-languagelibrary-should-i-use>What language/library should I use?</a></li></ul><ul><li><a href=#learning-a-language>Learning A Language</a></li><li><a href=#tactics-vs-strategy>Tactics vs Strategy</a></li><li><a href=#comments>Comments</a></li><li><a href=#tools>Tools</a><ul><li><a href=#text-editors>Text Editors</a></li><li><a href=#debuggers>Debuggers</a></li><li><a href=#profilers>Profilers</a></li><li><a href=#build-systems>Build Systems</a></li><li><a href=#version-control>Version control</a></li></ul></li><li><a href=#libraries>Libraries</a><ul><li><a href=#logging>Logging</a></li><li><a href=#configuration-files>Configuration Files</a></li></ul></li></ul><ul><li><a href=#targeting-linux>Targeting Linux</a><ul><li><a href=#standards>Standards</a></li><li><a href=#security-model>Security Model</a></li><li><a href=#writing-daemons>Writing Daemons</a></li><li><a href=#available-components>Available Components</a></li><li><a href=#traditional-package-formats>Traditional Package Formats</a></li><li><a href=#container-technology>Container Technology</a></li></ul></li><li><a href=#continuous-integration-and-continuous-deployment>Continuous Integration and Continuous Deployment</a></li></ul><ul><li><a href=#change-log>Change Log</a></li></ul></nav></div></details></div></div><div class="min-h-0 min-w-0 max-w-prose grow"><p>What is software development?
At a most basic level, it is the activity of using a programming language to achieve some set of goals over time.
It includes everything from scripts that a graduate student might write to analyze some data to massive systems that control aircraft.
As our world continues to progress technically, software development will likely become even more commonplace than it is now.
In this post, I aim to provide a comprehensive overview of how one can develop software efficiently using free and open source tools on Linux.</p><p>With the rise of software development has come the discipline of software engineering.
Software engineering is the study, generalization, and application of the practice of software development.
It often concerns it self with how to most efficiently use time and developer resources to achieve the goals of a particular project.
Within software engineering are methodologies which provide templates that have been shown to consistently produce results.</p><p>Software engineering methodologies (Waterfall, Agile, Kanban, etc&mldr;) differ over the exact components and ordering of the processes, but there are some overarching themes that are consistent.
They begin by engaging stakeholders to gather precise, accurate, and prioritized requirements.
Then these requirements are synthesized into a design which is evaluated and refined through communication with stakeholders.
As the design becomes clearer, engineers begin to develop individual components that represent high value returns to the stakeholders.
As components become available, their designs are tested individually and as part of the integrated whole.
Finally, once the design is considered finished, it is released to the world.</p><p>However if all we study is software engineering, we perhaps have missed the point.
We lose sight of the development of the individual over time, their maturation in the discipline, and their self awareness of their abilities.
This is what I call software craftsmanship.</p><p>Software craftsmanship highlights the need for the development of the individual developer over time.
As I use it, software craftsmanship is the inherently personal processes of software engineering that transcend a project boundary.
Software engineering more often focuses on a topic like task management as something that is shared among a team.
Whereas, software craftsmanship is the self awareness of how an individual will progress through the task.
Software engineering often looks at measures of performance across an organization.
Whereas, software craftsmanship focuses inward as to how one can grow for the long term.</p><p>That is not to say that software craftsman are alone.
A true craftsman seeks out mentor-ship and the experience of others as they grow in their trade, and joyfully shares their knowledge with others.
Their passion for their craft excites and inspires others to go forth in their example.
This post aims explain how I have learned the craft of software engineering using open source technologies.</p><p>This post is the second in a series focused on using Linux to get work done.
The <a href=https://robertu94.github.io/learning/linux/>previous post</a> serves as an introduction to Linux for general use.
If you have never used Linux before, you should read that article first.
While this article is primarily aimed at new developers,
I hope that some of the insights that I offer here will empower more experienced developers to get more done as well.</p><h1 id=how-to-read-this-post class="relative group">How to read this post <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#how-to-read-this-post aria-label=Anchor>#</a></span></h1><p>There are three ways not to read this article:</p><p><strong>First</strong>, do not try to read and apply this article all at once.
Software development is a skill that requires practice; so I recommend practicing before making a decision on whether something is useful or not.
Instead, first skim the entire article;
then pick a section or subsection that you would like to focus on improving, read it carefully, and integrate it into your work-flow.
Software development is a creative process, and like other creative processes different approaches will work better for some than others.
That is not to say that there are not norms or best practices that on average show improvements, but how evidence-backed concepts are implemented will very from person to person.</p><p>The first time that I was aware of doing this with software development when reading Drew Neil&rsquo;s excellent book &ldquo;Practical Vim&rdquo;.
The book is a collection of more than 50 tips about how to use the Vim text editor.
Yes, reading the book through passively was fascinating.
It gave me several insights into the elegance of using Vim that stick with me to this day.
However, when it really became powerful to me is when I applied what I was reading to the tasks that I had at work.
When I put them into practice, I started to see other areas and applications where I could use my new found skill.
Reading actively is essential.</p><p><strong>Second</strong>, these practices are not dogma, you will not be excommunicated for following or not following them.
From my experience, you it will not be too long before you will hear comments like these:</p><ol><li>If you are not using a <code>$TEXT_EDITOR</code>, you are an inferior software developer.</li><li><code>$LANGUAGE_1</code> is always a better language than <code>$LANGUAGE_2</code> be cause it has <code>$FEATURE</code></li><li><code>$ENGINEERING_METHODOLOGY_1</code> is strictly better than <code>$ENGINEERING_METHODOLOGY_2</code>, why are you stuck in the past?</li></ol><p>Often upon further extermination, these kinds of claims can be shown to logically false and are more an expression of the ignorance or preference person who said them.
That is not to say that they may not defect some truth, but software development is a study of trade-offs.
Lets look at a some specific examples:</p><blockquote><p>Vim is a better text editor than Nano</p></blockquote><p>This is an incredibly vague claim. There are may ways in which text editors may be better than one another: simplicity of implementation, number of lines of efficient, correct code written per hour by an new or experienced user, flexibility to new programming languages, etc. And in some ways, yes Vim is better than Nano: it offers features such as build system integration, code completion, and code navigation that have been shown to increase productivity for the average developer. However, Vim has a steep learning curve requiring weeks to become proficient and Nano can be used by many users in a manner of minutes. Over time, it can be shown that Vim offers better productivity, but that doesn&rsquo;t make it strictly better than Nano in all cases.</p><blockquote><p>Java is a better language than C because it does not use pointers</p></blockquote><p>This claim is also vague. But oftentimes when you push the people who make it, they mean that Java is better than C because it is garbage collected and is immune to some classes of memory related errors such as segmentation faults or use after free errors.
However in exchange for the immunity to segmentation faults or use after free errors, Java now has to preform garbage collection.
In a &ldquo;real-time&rdquo; context, your you need the code to have a precise, consistent runtime, garbage collection can be a huge source of variation.
This means that move from something that will be hard to get working to something that will likely never work.
Beyond that, a pedantic C developer might point out that Java has the concept of a <code>NullPointerException</code> which often operates similarly to a segmentation fault as far as program execution goes.</p><p>Ultimately, in both of these cases, you need to refine the question and determine objective means to come to a conclusion.
Software engineering the is study of techniques that make software development more repeatable and effective.
Software engineering gives us tools to answer questions such as:
Do I favor performance over readability? Resilience over performance? Portability over Implement-ability?
These are all choices that skilled software developers make and one a careful application of process can help answer.</p><p><strong>Finally</strong>, these practices are best learned in community.
Often when we are alone, we loose perspective that can be gained from others.
That is not to say that internal reflection is not important, but that others can provide keen insight into ourselves that we might otherwise be unwilling or unable to see.</p><p>I can think of several more seasoned craftsman who have shaped my development practice:
From one of my first technical mentors Irish who inspired me to get things right and to care about my tools.
To Austin, one of the most gifted engineers that I know who taught me the importance of making a design that communicates.
Marshall who showed me observant technical leadership and a quiet curiosity.
My colleagues at Boeing who showed me what it means to fit into the bigger picture and make a difference for customers.
My adviser Dr. Apon who showed me the power of empowering your team and taught me about the science of computing.
Dr. Malloy who taught me to prototype early and don&rsquo;t be afraid to fail.
To Dr. McGregor who showed me the importance of history and trade-offs in design.</p><p>We learn best in community, be aware of who you can learn from and who you can best teach.
We all have something to offer.</p><h1 id=gathering-good-requirements class="relative group">Gathering Good Requirements <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#gathering-good-requirements aria-label=Anchor>#</a></span></h1><h2 id=what-are-requirements class="relative group">What are requirements? <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#what-are-requirements aria-label=Anchor>#</a></span></h2><p>It may seem odd that I don&rsquo;t begin with a discussion of languages and tools.
Remember my discussions of trade-offs in the previous section?
You can&rsquo;t really begin to discuss the way you are going to implement a design until you truly understand the constraints involved.
In most software engineering methodologies, this is called requirements analysis or requirements gathering.</p><p>So what does this do with the craftsmanship of software?
Writing good requirements is difficult.
Almost no one knows exactly what they want from the beginning and can correctly anticipate how that will shift over time.
A software craftsman can tell the difference between certain and uncertain requirements and design in such a way as to obviate those concerns.
However, a good software craftsman can also identify when the stakeholders are asking for something impossible balances of conflicting concerns.
My graduate software engineering professor put it this way:</p><p>So what are requirements?
Requirements are not just what the software is supposed to do (functional requirements), but also qualities of the system (non-functional requirements).
Functional attributes are conceptually simpler.
You can often perform a test, does it do what is required or not.
This then implies the responsibility to actually test those requirements, but I will address testing later.</p><p>However non-functional requirements can be just as important if not more so.
Non functional requirements are those requirements are attributes of the system.
It&rsquo;s hard for these requirements to run an explicit test.
Example of non-functional requirements may be it must be maintainable or modifiable.
For these kinds of requirements different kinds of processes are needed to access if you are actually meeting your requirements; I&rsquo;ll discuss that in the section on verification.</p><p>The goal of considering requirements and stakeholders is to build realistic expectations for yourself and others.
Seldom if ever are you going to write the next big application that is going to skyrocket to a million users.
Rarely are things going to take the time or cost that you think they are going to, especially if you don&rsquo;t think carefully about what is involved.
Setting unrealistic expectations ruins credibility, destroys moral, and wastes time and effort.
You are not going to do this perfectly; the goal is to do better than you would if you did not try.</p><h2 id=what-are-_good_-requirements class="relative group">What are <em>good</em> requirements? <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#what-are-_good_-requirements aria-label=Anchor>#</a></span></h2><blockquote><p>A good requirement is: correct, unambiguous, complete, consistent, prioritized, verifiable, modifiable, traceable, necessary ~ John McGreggor</p></blockquote><p>At first this list seems very obvious, but there is often more nuance to this, so lets break it down.</p><p>Correct means that the system does exactly what it is supposed to do.
For example, people seldom need 100% accuracy, and can tolerate 99% accuracy if the system runs an order of magnitude faster.
In economics, these trade offs are measured in marginal costs &ndash; how much would you give up for a small gain in something else.
Now people may not know at first what they are willing to trade, but a good requirement seeks out how to measure the user&rsquo;s marginal cost structure.</p><p>Unambiguous indicates that the requirement can be interpreted in only one way.
However, unambiguous requirements are really challenging to write.
For example, consider the requirement that a function return a python <code>dict</code>.
On one level the requirement is unambiguous &ndash; it names the specific type.
However, often what is actually required is a <code>dict</code> containing certain keys which in turn refer to values of a specific type.</p><p>Complete requirement describe the totality of the requirements.
For example consider this definition of a find operation in a dictionary: it returns a exactly the value associated with a key.
However, this leaves out a key part of the requirement, what should be done if the key cannot be found?
This doesn&rsquo;t mean that the behavior should always be strictly and formally dictated.
A good example of this is undefined behavior in C/C++.
Compilers rely on allowing certain outcomes to produce unknowable effects to optimize the generated code for heterogeneous hardware and simplify implementation.
The point of having complete requirements is to specify what behaviors are well-defined and which are not; not to specify which behavior to take in every case.</p><p>Consistent means that it is possible that all requirements can be implemented at the same time.
On one level, this means that functional requirements should be non-contradictory.
On a deeper level it also means that non-functional requirements should be non-contradictory.
For example, consider the requirement that a system be highly usable.
This may be in conflict with requirements such as high security or extensive modify-ability which tend to increase complexity.</p><p>Few if any systems have ever implemented every feature considered.
In this case, budget concerns (both cost and schedule) can limit the extent of the implementation of the system.
Priorities are how we make these decisions.
When considering priorities, it is key to consider the dependencies of a requirement and what would be lost if the feature is not delivered.
It is also important to consider a project with multiple stakeholders is a form of multi-objective optimization.
In this case, there may not be one globally optimal point, but several Pareto optimal points.
Priorities need to reflect both kinds of concerns.</p><p>Verifiable means that it is possible to know if a requirement has been completed.
For things like functional requirements, this can be easier since the system either does or doesn&rsquo;t meet its requirements.
This is not always true, consider massive computation problems.
You may not be able to afford to run an experiment twice.
In this case you need to develop proxy requirements that approximate your actual needs.
For non-functional requirements, it can be essential to develop metrics that accurately reflect the extent to which the requirement is met.
For example usability, usability could be assessed by having potential users use an application and track what they can do without help and how quickly they can do it.</p><p>Modifiable indicates that a requirement can be changed without necessitating making substantial changes to other requirements.
That is not to say that lock in and hard requirements should be avoided in all circumstances.
Rather, hard requirements and lock-in should be considered carefully.
A more <a href=https://martinfowler.com/articles/oss-lockin.html target=_blank rel=noreferrer>complete treatment of modifiable requirements has been written by Gregor Hohpe</a>.
A clear personal example of this is when a team that I was working with required support of a particular protocol.
Requiring this protocol essentially limited their design space to one very expensive option because the protocol was proprietary to one vendor.
Did they actually need this? Perhaps they did.
In reality, they could have considered other and possibly better designs if they relaxed this requirement.</p><p>Trace-ability is not so much a question of the content of a requirement but rather the process that created it.
The idea is that you should be able to give a rational basis for why the requirement was introduced in the first place.
It can be &ldquo;traced&rdquo; to its cause.
Trace-ability becomes increasingly important for long standing projects where the understanding design decisions of years past can become a act of archaeological excavation and avoid repeating the mistakes of the past.</p><p>Lastly the principle of necessity is the Occam&rsquo;s Razor of software architecture.
Systems that are less constrained are easier to build.
I remember countless times where I later relaxed the original design constraints of my code after learning that I had made an unnecessary restriction.</p><h2 id=stakeholders-who-makes-the-decisions class="relative group">Stakeholders: Who makes the decisions? <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#stakeholders-who-makes-the-decisions aria-label=Anchor>#</a></span></h2><p>So who makes these requirements?
That would be stakeholders; those who have an interest in the outcome.
Often they are the persons funding the effort, will be using the results of the effort, but also those who will be leading the effort.
At this point one may say, &ldquo;but this is a personal project&rdquo;, or &ldquo;no one outside of my team will use or care about this&rdquo; to argue that they don&rsquo;t need to think about stakeholders.
These views are misguided.</p><p>Even for personal projects you have yourself as a stakeholder.
Both yourself now and in the future.
You never know when you are going to need to understand, adapt, or reuse code that you are writing now.
It is important to consider what you may need for this task in the next month, year, or decade.</p><p>Often the process of thinking about who the stakeholders are can be illuminating on just how your experiment, tool, or library will be used.
You could discover that you may have other users in the future.
You could uncover that other uses of your design.
You might design things differently.</p><p>Different stakeholders have different priorities and requirements.
Too many times, I have seen systems that were never designed for anyone else to use them.
They were undocumented, untested, and in many cases had to be substantially rewritten.
Get their feedback early and often.</p><ul class=activity><li>Who are the stakeholders and requirements for your system?</li></ul><h1 id=crafting-a-design-converting-requirements-to-an-architecture class="relative group">Crafting a Design: Converting Requirements to an Architecture <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#crafting-a-design-converting-requirements-to-an-architecture aria-label=Anchor>#</a></span></h1><h2 id=how-do-i-get-better-at-design-study-existing-designs class="relative group">How do I get better at design? Study existing designs <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#how-do-i-get-better-at-design-study-existing-designs aria-label=Anchor>#</a></span></h2><p>One on level, this suggestion goes without saying.
Of course, you should learn from the successes mistakes of others.
The is true regardless of what field or task you are facing.</p><p>You may be tempted to think that you are the first person to face a particular challenge.
This is likely not true.
Maybe you have different tools to work with, maybe you even have some unique problem that truly prohibits the most common solution, but that doesn&rsquo;t mean you are the first to face such a challenge.
The &ldquo;Teacher&rdquo; or &ldquo;Preacher&rdquo; or Ecclesiastes said it best, &ldquo;There is nothing new under the sun.&rdquo;
You may have to look to completely different disciplines than the ones you exercise regularly, but more than likely you are not alone.</p><p>I am constantly amazed how many &ldquo;new&rdquo; innovations are simply either better tooling or better marketing for a solution that was developed in the early days of UNIX.
Take containers for example.
These concepts were first introduced in FreeBSD as &ldquo;jails&rdquo;, and improved in Solaris as &ldquo;crossbow&rdquo;.
Yes, docker provides a substantially better interface for building and distributing containers than these existing technologies, but that doesn&rsquo;t mean it was first.</p><p>Now how can one learn the most from source code or architectures written by someone else?
I suggest that you read with a purpose; I&rsquo;ve recorded some thoughts on this in <a href=https://robertu94.github.io/learning/reading/>my post entitled &ldquo;Learning to Learn: Reading&rdquo;</a>
Here are some common questions that I ask when I am reading to understand a code base:</p><ol><li>What are the major parts of the code base/architecture related to what I do?<ol><li>Why did each one need to be included? Understanding the role a component fills can provide guidance about what kinds of roles or information you may need to implement your system.</li><li>How are the major components named and why? Naming is powerful in that shapes the way that we think about the system. A good name maps uniquely and naturally to the purpose of the thing that is named.</li><li>What interface or interfaces did they use? A good interface does not &ldquo;leak&rdquo; to reveal information about the information. Often you don&rsquo;t have access to more than the interface of an object or function. Interfaces are the connective tissue of your application and how they are designed matters.</li><li>How do they accomplish their task? Implementation details matter. Exactly how processing and memory resources are utilized matters. Sometimes you just need the structure of a solution.</li><li>What impacts would alternative designs possibly have on the usage of the interface? Understanding the trade-offs that exist within an architecture will guide you to better weigh which trade-offs that you should make yourself.</li></ol></li><li>What could I reuse design ideas from this work? Legally (is it allowed by the license) then either actually (copy/paste/<code>#include</code>/import), pragmatically (implement a analogous interface, or create an &ldquo;wrapper&rdquo;/&ldquo;adapter&rdquo;), abstractly (use the idea, but depart substantially from the interface)? Why or why not? Reusing work saves time and effort if possible. Keep in mind you don&rsquo;t have to reuse the implementation to learn from it.</li><li>How does this design compare/contrast to other designs preforming similar tasks? Why might these changes exist? Before you make your own trade-off decisions, understanding how others have made them can help you make them yourself.</li><li>What are the advantages and disadvantages of this design? Once you have considered all of the trade-offs, it&rsquo;s time to make finally decide what is good and bad about a design.</li></ol><p>The ordering here is important. First you need to understand what a design is on its own before you can consider using it, then comparing it, and finally evaluating it.</p><p>In the remainder of this section, I want to highlight a series of books, software, and other resources that have shaped my thoughts on software design.</p><ul><li>&ldquo;Object Oriented Design Patterns&rdquo; by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. This book while also about specific patterns on how to construct software, really introduced me to the concept of how to consider a broader class patterns than simply function prototypes.</li><li>&ldquo;Modern C++ Design: Generic Programming and Design Patterns Applied&rdquo; by Alexander Alexandrescu. This book is dense and introduces the concepts of using generic and meta programming to implement common software patterns to build higher levels of abstraction.</li><li>&ldquo;Functional Design Patterns in F#&rdquo; by Scott Wlashchin. This talk introduced me the concept that design patterns could be implemented in abstract ways to solve the same problems.</li><li>Linux Kernel. The Linux kernel showed me how much could truly be done with a comparatively simple language like C.</li><li>Clang/LLVM. LLVM has a host of advanced programming methods and structures used throughout its design. It is a veritable menagerie of cool data structures and algorithms.</li></ul><p>I&rsquo;d also like to caution against using Stack Overflow, random GitHub repos, and other Internet sources unquestioningly.
The quality of information you get depends greatly on how carefully it was constructed.
While there is doubtlessly many examples of good design and best practices,
there are [countless studies that record poor quality answers](<a href="https://scholar.google.com/scholar?q=stack" target=_blank rel=noreferrer>https://scholar.google.com/scholar?q=stack</a> overflow quality) on platforms such as these.</p><h2 id=what-lessons-have-i-learned class="relative group">What Lessons Have I Learned? <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#what-lessons-have-i-learned aria-label=Anchor>#</a></span></h2><p>Software craftsmanship is not learned overnight.
It isn&rsquo;t even necessarily learned reading posts or books such as these.
It is learned by doing and by learning from the doing of others.
In this section, I want to highlight some of the most important lessons that I have learned about software engineering.</p><h3 id=quality-attributes-a-powerful-way-to-think-about-non-functional-requirements class="relative group">Quality Attributes: A powerful way to think about non-functional requirements <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#quality-attributes-a-powerful-way-to-think-about-non-functional-requirements aria-label=Anchor>#</a></span></h3><p>One final tool that I think has been very powerful in how I think about software craftsmanship is quality attributes.
Quality attributes are a way to think about non-functional requirements of a system.
Here is a listing of Quality Attributes that I learned about in my graduate software engineering course:</p><ul><li>Efficiency<ul><li>Time Economy - does it run quickly? Can we implement it quickly?</li><li>Resource Economy - does it efficiently use hardware/human resources?</li></ul></li><li>Functionality<ul><li>Completeness - does it do everything that we want it to?</li><li>Correctness - does it handle everything that it does handle correctly?</li><li>Security - how robust is the security model, and how resilient to the modeled attacks it the system? Do we care?</li><li>Compatibility - does it fit into our existing work-flow?</li><li>Interoperability - does it inter-operate with our our other systems?</li></ul></li><li>Maintainability<ul><li>Correct-ability - how easy is it to fix bugs when they occur?</li><li>Analyze-ability - how easy is it to figure out what is going on with the system?</li><li>Modify-ability - how easy is it to modify the functionality of the system?</li><li>Test-ability - how easy is it to test that the system is operating as expected?</li></ul></li><li>Portability<ul><li>Hardware Independence - can the system run on multiple kinds of hardware?</li><li>Software Independence - can we change the underlying software dependencies (the operating system, standard library, other library components, etc&mldr;)</li><li>Adaptability - how can the system adapt to new circumstances without being modified?</li><li>Install-ability - how easy is it to install on the target platforms?</li><li>Co-existence - can the system be installed or used where other systems are installed or used?</li><li>Replace-ability - how difficult is it to repair the system after it has been installed?</li></ul></li><li>Reliability<ul><li>Maturity - how much testing and use has this system had before it was deployed?</li><li>Fault Tolerance - how many and which kinds of faults can the system experience before it stops offering meaningful service?</li><li>Recover-ability - how quickly do we recover from a fault after it has occurred? What do we have to do in order to recover?</li></ul></li><li>Usability<ul><li>Understand-ability - how easy is it to reason about the system to new users and developers?</li><li>Learn-ability - how quickly can users learn the new system given their current knowledge?</li><li>Operate-ability - how quickly or easily can users operate the system?</li></ul></li></ul><p>The important thing to recognize about quality attributes is that they represent trade-offs.
To make something more secure, you often make it less usable and adaptable.
To make something more adaptable or modifiable, you often make it less understandable.
So when thinking about quality attributes in a design, it is important to think about which attributes are most important, and what is the lowest and highest level of each that is required.</p><p>So how can one design for quality attributes, let&rsquo;s consider a few examples:</p><ul><li>Design for &ldquo;native paradigms&rdquo; &ndash; this requirement emphasizes the learn ability of the system for developers. By using software patterns that they are used to, they will likely be able to learn and modify the system more easily. However, using native paradigms make the system less portable to systems that don&rsquo;t share these paradigms. I tend favor native paradigms things that are unlikely to change. You probably won&rsquo;t rewrite the entire application in a different language, so using a language paradigm is probably ok. You probably will change the database system or UI, so organizing your data to optimize for a particular database/graphical toolkit probably isn&rsquo;t worth it.</li><li>Favor small modules and functions with a single task &ndash; this requirement favors modify-ability and understand-ability of individual component over the time/resource economy of the whole system. From personal experience, the cost in time/resource economy is overstated; optimizing compilers can often remove the layers of abstraction introduced completely, and the improved readability of the system is very often worth it. Additionally, when you isolate concerns like computation from IO, you have to change less if you want to introduce different IO or computational patterns later.</li><li>Prefer self-describing IO formats (protocol buffers, HDF5, JSON, CSV, ORMs). Using these formats makes your system more inter-operable, but will likely increase your resource usage over a custom wire/disk protocol. Personally, I tend to prefer Interoperability and switch to a custom protocol later if I have to for resource constraints.</li></ul><h3 id=diagramming-a-quick-picture-is-worth-a-hundred-hours class="relative group">Diagramming: A Quick Picture is Worth a Hundred Hours <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#diagramming-a-quick-picture-is-worth-a-hundred-hours aria-label=Anchor>#</a></span></h3><p>One of the best examples of lessons that I didn&rsquo;t learn by reading, but by doing is the importance of prototyping and diagramming.
In every software engineering class that I have ever taken, you would hear about something called the verification and validation curve as a model of the process for design software.
You can see an example of it below:</p><p><figure><img src=/static/posts/software_engineering/verification_and_validation.png alt="Verification and Validation V Model Diagram. In the V Model, the tasks of software engineering are placed in order of occurrence along a V shape." class="mx-auto my-0 rounded-md"></figure></p><p>Tasks at the top of the V have high impact, and tasks at the bottom have less impact on the final design.
However there are a two major problems:
At the beginning of the V, you have very little information about the design and what impact particular design decisions may have.
At the end of the V, you have a lot of information about the impact of design decisions, but less ability to change them without massive cost.
Therefore, it is desirable to be able to get as much information as possible to make the right decisions earlier in the process.
This is where diagramming and prototyping can be enormously helpful.</p><p>Diagramming makes a pictorial representation of one or more aspects of a system and possibly how they interact.
The major benefit of a good diagram is that it can take fraction of the time to create a diagram useful diagram than it would take to implement the system and has the side benefit of often more understandable to clients and colleagues.
I have found that I can create diagrams for a half dozen different candidate designs in the time it would take to code one component of a larger system.</p><p>A good diagram often doesn&rsquo;t display every aspect of the system.
Rather it highlights whatever aspect of the system that is currently important to the viewer.
If you need to consider a different aspect of the system, make another diagram.
It won&rsquo;t take you too long.</p><p>Here is an example from a paper that I published for FRaZ &ndash; a compressor framework that I developed while at Argonne National Laboratory:</p><p><figure><img src=/static/posts/software_engineering/diagram_example.png alt="The diagram is divided in to 3 groups boxes arranged vertically: &ldquo;Users&rdquo;, &ldquo;FRaZ&rdquo; and &ldquo;Compressors&rdquo;.  There are arrows running from top to bottom.  In the &ldquo;Users&rdquo; there are a number of names of scientific applications in yellow indicating software written by others.  The FRaZ section is in light green representing we contributed the design to link these components together.  In this box there are a few smaller boxes in Green which denotes software we wrote, and some in yellow representing dependencies.  There is a note in green attached to one of the dependencies indicating we made a small change to a component written by someone else.  On the bottom are the three compressors that we can use in yellow." class="mx-auto my-0 rounded-md"></figure></p><p>Does this diagram show everything we did in the system?
No.
This diagram was intended to show the major elements of the system, how they interact, and which elements we wrote vs got from others.
Now this is a publication quality figure, like what one might put in a presentation or a paper, but not all diagrams need to be this refined.
The original version of this diagram was just a sketch on a sheet of paper that took me about 10 minutes to make.
The publication quality version took about an hour, but the whole system took me weeks if not months to write.</p><p>Now, what and how can I diagram software systems?
You could potentially diagram any aspect of a system where you want to consider multiple possible implementations.
A book that I found helpful on subject is &ldquo;UML Distilled&rdquo; by Martin Fowler.
Two notations that I have found helpful are UML and AADL.
UML (unified markup language) is a notation that provides a common design language for expressing system interactions.
A vast majority of the time I use a subset of UML.
Another notation that I have used is AADL (architecture analysis and design language).
I think it does a better job of modeling information flow than UML by forcing you to focus on inputs, outputs, and their formats.
I don&rsquo;t use these notations strictly, but where I think they are helpful.</p><p>Lastly, what tools should I use to create diagrams?
Most of the time, I use a white board or pen and paper.
The goal is to reduce the effort of brainstorming interactions.
However, when I need something that looks more &ldquo;professional&rdquo;, I use either Inkscape, draw.io or Dia to make a publication quality version.</p><h3 id=blank-baling-the-art-and-value-of-prototyping class="relative group">Blank Baling: The Art and Value of Prototyping <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#blank-baling-the-art-and-value-of-prototyping aria-label=Anchor>#</a></span></h3><p>One of the lectures that has stuck with me the most in my academic career was by Dr. Malloy about the value of prototyping.
He would explain that archers, in order to practice their stance and release, would often stand blind-folded inches away from the target to practice shooting.
By closing their eyes and focusing on their form, they learn to over come target anxiety.
He analogized that prototyping software is very similar to blank-bailing.
He described how by focusing on the smallest aspects of our system, we can try and learn by practice what design decisions do in the small scale without worrying how things will fit into a larger architecture.
He encouraged us to create a &ldquo;play&rdquo; directory in our computer where we can feel free to try any odd thing and not have to worry about what it would do to the rest of our system or projects.
Prototyping often and early has been one piece of advice has been one of the most transformative practices in becoming a software craftsman.
In the remainder of this section, I want to highlight a few things about prototyping that I have learned since I started regularly practicing it a few years ago.</p><p>The first question that I had when I started prototyping regularly was what should I prototype?
There are two cases in which I often create prototypes.</p><p>I often create a prototype for each new API that I want to use.
Want to learn about MPI&rsquo;s type system, make a prototype.
Want to play with OpenMP tasking or nested parallelism, make a prototype.
These prototypes were nothing spectacular, just enough code to do something useful or prove that something could work in a vacuum.</p><p>I also from time to time create prototypes of client and library code when I am creating a new interface.
The goal with this kind of prototype is to determine what kind of information needs to pass across the interface boundary and how &ldquo;ergonomic&rdquo; an interface will be.
By creating several examples of client code, I get a better idea of what will be efficient or easy to do and what will be a pain.
It can also help me identify where I don&rsquo;t have all of the information that I need, and I need to add an method to the interface.</p><p>The second major question that I face with prototyping is how can I avoid this code &ldquo;ending up in production&rdquo;?
Prototype code often lacks important details (i.e. security, logging, documentation, and others) that would be in a &ldquo;production-ready&rdquo; code.
So you often want to be careful about using it in a way that is likely to end up being used directly for someone else.</p><p>This is where the &ldquo;play&rdquo; directory comes into play.
The &ldquo;play&rdquo; directory is not checked into the same source code repository that the &ldquo;production code&rdquo; would be.
Additionally, I never share code in prototype form with others.
If someone wants code that I have used for prototyping (it doesn&rsquo;t happen often, but occasionally it does), I typically go through a short process of making it &ldquo;production-ready&rdquo; which involves adding a license file, commenting the interfaces, ensuring &ldquo;secure&rdquo; and &ldquo;efficient&rdquo; APIs have been used where appropriate, and adding some tests cases and assertions to ensure correctness.
About 80% of my prototypes are fewer than 100 lines of code, with the average being about 61 lines of code including comments.
The person you are giving the code will probably appreciate it the higher quality code and for 60 lines of code it shouldn&rsquo;t take too long to make these changes.</p><p>Another major tool when building prototypes is mocks.
Mocks are components that rather than interacting with a more complex aspect of your system, returns some predefined data.
These can be really powerful in writing short code that can model some more complicated aspect of your system without bringing in the entire system as a dependency.
Most languages have a library or two that make it easier to quickly build mocks from existing classes.
Learning to use tools like these, can really cut down your time in writing prototypes</p><p>The last topic that I want to address here is when are higher level languages useful in prototyping?
C++ is a fantastic language if what you want is the some of the absolute highest level of control about what code gets generated, but it isn&rsquo;t always the best language for writing something quickly.
Sometimes, you want the more robust library support, or don&rsquo;t want to deal with questions like object lifetime.
For cases such as these, I have found Python &ndash; and more recently Julia &ndash; to be great languages to prototype in.
These languages come &ldquo;batteries included&rdquo; with language features that make writing quick and dirty code easy.
However, some times what you want to prototype is how to do something specific in the language in which you are going to finally implement everything.
In that case, you probably do want to use whatever lower-level language you will ultimately be using.</p><h3 id=focus-on-the-interface-api-design-reviews class="relative group">Focus on the interface: API Design Reviews <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#focus-on-the-interface-api-design-reviews aria-label=Anchor>#</a></span></h3><p>Another transformative talk that informed how I thought about software design was <a href=https://github.com/CppCon/CppCon2018/tree/master/Presentations/modern_cpp_api_design_pt_1 target=_blank rel=noreferrer>Titus Winter&rsquo;s 2018 CppCon talk entitled &ldquo;Modern C++ API Design&rdquo;</a>.
While this talk is focused on C++, it really got me thinking about what constitutes a good interface.
As I mentioned above, for anyone who has used Python is <code>dict</code> really the interface you want, or is it really a <code>dict</code> or is a <code>Dict[str,int]</code>? Or perhaps <code>Dict[AnyStr, float]</code> or even <code>Dict[AnyStr, List[float]]</code>
Likewise do you really want a <code>dict</code> or are you looking for something closer to a Java interface or a Rust trait?
Or does extension not matter, and what you really want is a struct with fixed names and types?
The interface you provide is essential.
It makes the difference between what is possible to achieve with a design and what is not.</p><p>So how can you ensure that you have the right design?
Winter&rsquo;s suggests, as others have, that there should be a design review for important interfaces to ensure they can be use efficiently and give the users what they need.
Here are some questions that I think about when designing types:</p><ol><li>Is the usage of the class &ldquo;intuitive&rdquo;?</li></ol><ul><li>Do I have to make several API calls to accomplish common tasks, or will a few calls suffice?</li><li>Are there more than one way to solve a problem, and if so is it clear when to use each?</li><li>Does each call do a minimal number meaningful of things?</li></ul><ol start=2><li>Does it fit within the larger software design?</li></ol><ul><li>Does it use consistent conventions? Naming? Parameter ordering? Return values?</li><li>Are their other existing classes with do similar things? If so why do both need to exist?</li><li>Does the code use the same paradigms as the rest of the code?</li><li>Does this design meet the functional and quality attributes goals of the architecture?</li></ul><ol start=3><li>What are the invariants that the class/function upholds? Some invariants I consider are:</li></ol><ul><li>Ownership &ndash; who creates and then later who owns the object? Does it have static or dynamic lifetime?</li><li>Uniqueness &ndash; how many copies of the object need to exist for its intended purpose?</li><li>Constancy/Purity &ndash; what parameters are held constant vs. Mutable? How does it interact with its environment if at all?</li><li>Thread Safety &ndash; what level of thread safety is provided?</li><li>Exception/Error behavior &ndash; can the invariant be maintained in the case of errors/warnings?</li></ul><ol start=4><li>How well does this class/function follow the robustness principle (be liberal in what you accept, and conservative in what you return)?</li></ol><ul><li>Am I really specifying the broadest interface that I can still consistently use correctly?</li><li>You can find some my thoughts about <a href=https://robertu94.github.io/posts/2019-11-17-strong-or-robust/>liberal vs conservative interfaces here</a></li></ul><ol start=5><li>Does the function/class appropriately propagate errors at the correct level of abstraction?</li></ol><p>Reviewing your plan after diagramming and prototyping some of the important APIs can really go along way into developing a use-able interface.</p><h3 id=good-requirements-problems-with-not-invented-here-and-never-invent-here class="relative group">Good Requirements: Problems with Not Invented Here and Never Invent Here <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#good-requirements-problems-with-not-invented-here-and-never-invent-here aria-label=Anchor>#</a></span></h3><p>As mentioned earlier, it is important to write good requirements.
However, from my experience two of the most wrongly imposed requirements are that the code either be written by someone else (also called never invent here) or that it must be developed in house (so called not invented here).
That is not to say that there isn&rsquo;t a trade-off that must be weighed between the two, but it is seldom a hard requirement that must be carefully decided between.
The reason I think these requirements are often over imposed is that they intuitively seem self-supporting.</p><p>Not invented here has been often driven by the engineering teams desire to create, the marketing teams desire to differentiate the product, or by the argument that &ldquo;our case is different&rdquo;.
If you are the only user, and you are doing this to learn, the first can be a sufficient reason.
However, the argument that your specific use-case is so different that you have to write everything or even most things from scratch is likely false.
You may not be using the same words, you may not think about it the same way, you may have to change the default configuration or re-write modular component, but in all likelihood someone has done something very similar to what you are doing now.</p><p>Never invent here has often been driven either by the desire to reduce cost or effort.
Components off the shelf (COTS) have many benefits, you don&rsquo;t have to maintain them, you might not have to support them, and they likely are already finished.
All of these properties are nice to have.
However, if you never allow the possibility of building what you need, you may end up with an experience which is more generic than you might hope.</p><p>Ultimately, you have to weigh the trade-offs between these two cases and decide which more closely matches with what you are doing.
Would writing this component provide sufficient value to overcome the additional maintenance and development costs?</p><p>So where can you find existing components?
Today, there is a tremendous volume of code that has been open sourced.
Provided it meets your license requirements and desired quality attributes, you can likely get it to work.
However, you should also consider proprietary solutions.</p><h3 id=rational-expectations-preparing-for-the-future-versus-yagni-you-aint-gonna-need-it class="relative group">Rational Expectations: Preparing for the Future versus YAGNI (You Ain&rsquo;t Gonna Need It) <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#rational-expectations-preparing-for-the-future-versus-yagni-you-aint-gonna-need-it aria-label=Anchor>#</a></span></h3><p>A similar conundrum that people get trapped in is preparing for the future vs YAGNI.
This conundrum deals with how modifiable and modular should you make the code vs how simple the implementation should be.
On one extreme you have <a href=https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition target=_blank rel=noreferrer>&ldquo;Enterprise Software&rdquo; memes</a> where any and everything can be reconfigured with a change to an XML file.
On the other extreme you have code which is so tied to a specific implementation, you can&rsquo;t change anything without re-writing from scratch.
Over the years, I have been susceptible to both.</p><p>So how can you avoid the traps of either extreme?
It really boils down to thinking carefully about what are rational expectations given your conversations with your stakeholders and your well-grounded beliefs about their future needs.
It is crucial to ask not just might I use this in the future, but do I clearly foresee doing this soon?
Additionally, it is important ask what will I have to change if I need to change this in the future, and how disruptive will that be?
Between these two factors you can do a cost-benefit analysis as to which situation you find yourself.</p><h3 id=refactoring-improving-the-design-of-existing-software class="relative group">Refactoring: Improving the Design of Existing Software <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#refactoring-improving-the-design-of-existing-software aria-label=Anchor>#</a></span></h3><p>There is a reason the Martin Fowler&rsquo;s signature book is the only book in this document to get its own subheading.
This book really changed my expectations about what could be do quickly to change source code and my understanding about how it would effect users.
You should definitely read it.</p><p>Two quick notes about refactoring.
Since the development of Fowler&rsquo;s book, a number of tool have been developed to preform basic refactoring.
Which tools are best, and which tools work for which languages shift over time, but I strongly advise learning these tools.
They take a lot of grunt work out of programming.
In fact, I regularly use two different development environments for several languages because one of them provides better code writing/exploration facilities and the other provides better refactoring support.</p><p>The other key part of refactoring is how to quickly test if a change broke something.
Of course if the code you are using has extensive unit-tests that have high coverage, you can just use that.
If they do not, <a href=https://approvaltests.com/ target=_blank rel=noreferrer>Approval tests</a> can be a quick way to write tests for unfamiliar code.
Essentially, they take an application and assert that the output hasn&rsquo;t changed.
Additionally there are a number of tools that can help you write Approval Tests quickly regardless of what language you use frequently.</p><h3 id=security-and-threat-modeling-thinking-about-confidentiality-integrity-and-availability class="relative group">Security and Threat Modeling: thinking about confidentiality, integrity, and availability, <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#security-and-threat-modeling-thinking-about-confidentiality-integrity-and-availability aria-label=Anchor>#</a></span></h3><p>It is often very hard to secure a system after it has been designed and widely deployed.
Therefore you should think about the security of your system upfront.
The process of planning for security often involves threat modeling.
Consider each of the valuable or private aspects of data that your system may interact with.
This can be personal information, expensive computing or storage resources, proprietary information, or a service that you provide.
For each ask:</p><ul><li>Confidentiality: how can private information be inadvertently shared by someone without authorization? What would someone need to do to access this information?</li><li>Integrity: how could private information be forged or modified without authorization? What would someone need to know to access this?</li><li>Availability: How could private information be made inaccessible? What could someone do to prevent users or systems with appropriate access from accessing the information?</li></ul><p>Now, just because there is a threat doesn&rsquo;t mean that you will implement a mitigation.
Some mitigation are prohibitively expensive to implement relative to their cost to remediate.
Balancing these concerns is key to implementing a secure system.</p><ul class=activity><li>Consider the techniques (quality attributes, prototyping, diagramming, api reviews, rational expectations, refactoring, etc&mldr;) listed above to craft requirements into a design. Which ones have you used? How have they effected they ways that you design software?</li></ul><h2 id=what-languagelibrary-should-i-use class="relative group">What language/library should I use? <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#what-languagelibrary-should-i-use aria-label=Anchor>#</a></span></h2><p>This is probably the question that several of you had when you first started reading this post.
There is a reason that I waited until now to cover it: design is often more important than implementation.
That doesn&rsquo;t mean that you can&rsquo;t have a bad implementation ruin a good design, but a bad design will ruin every implementation.
The choice of language is an implementation detail that has trade-offs.
In this sub-section, I present some things to think about when choosing languages.</p><p>First consider what existing work has been done.
Are you starting on a &ldquo;green-field&rdquo; project where you are writing the first line of code, or are you adding to an existing code-base?
Don&rsquo;t just think about the code that you are going to be writing when you are making this decision.
Think about code that you colleagues have or will write, think about what libraries and frameworks exist to do the task you are attempting.
You don&rsquo;t want to impose undue costs on yourself or your team by choosing something that no one else knows or uses for your task.
That doesn&rsquo;t mean that existing work should be dispositive (you eventually need to move on from Fortran-77 if only to a more modern version of Fortran), but it should weigh heavily on your decision.</p><p>You should also consider what language(s) you already know.
Learning a language takes time.
Is your goal to learn a new language, then great, ignore this advise.
However, if your goal is to be productive, you may be better off sticking to what you already know.</p><p>You should also consider how the language will effect quality attributes.
Two that are often important are stability and performance.
Some languages are relatively young and need frequent changes to their syntax and standard library.
They probably aren&rsquo;t a good choice for a system that needs to last 10 years.
Secondly, there is often a trade-off between compiled and interpreted languages in terms of runtime performance and development time.
Consider carefully if machine time is more important than human time for your particular task.</p><p>So lastly, I want to close out this section with a brief table of what languages I generally recommend for which purposes:</p><table><thead><tr><th>Purpose</th><th>Languages</th><th>Reason</th></tr></thead><tbody><tr><td>New programmer</td><td>Python</td><td>Super easy to learn</td></tr><tr><td>New computer scientist</td><td>C++</td><td>Exposes the how almost everything is written</td></tr><tr><td>&ldquo;Enterprise Software&rdquo;</td><td>Java</td><td>The language serves no other purpose in life</td></tr><tr><td>Containers</td><td>Go</td><td>Go produces tiny static binaries by default; great for containers</td></tr><tr><td>Interoperability</td><td>C/C++</td><td>Almost everything has a C foreign function interface</td></tr><tr><td>Operating Systems</td><td>C</td><td>By the time you use only the features in C++ that work without an OS, you have C; Rust is getting close</td></tr><tr><td>Performance Critical</td><td>C/C++</td><td>Nothing beats C/C++ for performance critical tasks</td></tr><tr><td>Prototyping</td><td>Python</td><td>Python is very concise, forgiving, and expressive</td></tr><tr><td>Safety Critical</td><td>Rust</td><td>Rust&rsquo;s borrow checker and bounds checking are awesome tools for ensuring you have reliable behavior</td></tr><tr><td>Scientific</td><td>Julia, R, Python</td><td>Most code you commonly would write is already written for you</td></tr><tr><td>Web Back-end</td><td>Python, Go, Javascript</td><td>Javascript can also be used on the front-end, Go works well in containers, Python has great tooling</td></tr><tr><td>Web Front-end</td><td>HTML, CSS, Javascript</td><td>These are the standards, and you don&rsquo;t have many other choices</td></tr></tbody></table><h1 id=implementation class="relative group">Implementation <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#implementation aria-label=Anchor>#</a></span></h1><p>Now that we have clearly thought about what design we want and which tools we are going to use, it comes time to finally implement the design
In this section, I want talk about how to actually implement the software.</p><h2 id=learning-a-language class="relative group">Learning A Language <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#learning-a-language aria-label=Anchor>#</a></span></h2><p>Learning a specific language is out of scope for this article, but I recommend that you check out my posts on learning languages:</p><ul><li><a href=https://robertu94.github.io/learning/cpp/>C++</a></li><li><a href=https://robertu94.github.io/learning/python/>Python</a></li></ul><h2 id=tactics-vs-strategy class="relative group">Tactics vs Strategy <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#tactics-vs-strategy aria-label=Anchor>#</a></span></h2><p>The difference between tactics and strategy is the time-frame on which they play out.
Strategy is the plan writ-large; tactics are the day to day, moment to moment decisions.
Almost everything that I have talked about so far could be call strategy.
Now I want to turn to focus on tactics.</p><p>Tactics are small units of change that you can introduce to your design to fix a particular problem.
Here are some tactics we discussed in my course work:</p><ul><li>Any System<ul><li><em>Splitting</em> &ndash; decompose a monolithic system or module into two or more modules; reducing cost of modifying a single responsibility.</li><li><em>Substitution</em> &ndash; one module is replaced by another with equivalent behavior but a different implementation</li></ul></li><li>Modular Systems<ul><li><em>Augmenting</em> &ndash; an additional module is added to the system.</li><li><em>Excluding</em> &ndash; a module is removed from the system.</li><li><em>Inversion</em> &ndash; two or more modules are modified to create a third module that capture common behavior</li><li><em>Porting</em> &ndash; A module is divided into a into a module that is coupled to the system and another that is free from a single system.</li></ul></li><li>Layered Systems<ul><li><em>Maintain Semantic Coherence</em> &ndash; ensure layers do make undue access to other layers</li><li><em>Raise the Abstraction</em> &ndash; create a new layer to encapsulate common work</li><li><em>Abstract Common Services</em> &ndash; group responsibilities within a layer into a service.</li><li><em>Use Layered Encapsulation</em> &ndash; layers either:
+ provide a facade to lower layers
+ provide an interface to the current layers new functionality</li><li><em>Restrict Communication Paths</em> &ndash; defines an ordering of layers such that layer N only access layer N-1</li><li><em>Use an Intermediary</em> &ndash; have one layer act on behalf of another layer</li><li><em>Relax Layered System</em> &ndash; allow a layer to access a deeper layer directly (for performance or simplicity)</li><li><em>Layering through inheritance</em> &ndash; a pattern that binds relationships between the layers at compile time</li></ul></li><li>Other tactics:<ul><li><em>General Encapsulation</em> &ndash; putting a module behind an interface so that it can be replaced.</li><li><em>Intermediary</em> &ndash; introduce a module between two components to perform some extra work.</li><li><em>Proxy</em> &ndash; decouples the components of a system from being on the same system/process.</li><li><em>Reflection</em> &ndash; allow the system to inspect the state of services at run time to select an implementation</li></ul></li></ul><p>These aren&rsquo;t the only tactics that exist. Martin Fowler&rsquo;s book &ldquo;Refactoring: Improving the Design of Existing Software&rdquo; has a another large list of tactics that can be applied to a software system. They can be found his <a href=https://refactoring.com/catalog/ target=_blank rel=noreferrer>catalog of refactoring techniques</a> online.</p><p>Lastly in addition to the question of what to do, there is the tactical question of what order to implement the system.
In general you should start with the part of the system which provides the highest value at the lowest cost.
However within that, there has been research on the ordering use to construct the various modules of a system (search for &ldquo;Integration Test Order Strategies&rdquo;).
In general, these approaches create a dependency graph of the system then order the implementation of the software components in topological order of the resulting directed acyclic graph.
They may have some weighting assigned based on the importance of the system, but that roughly the all work the same.</p><h2 id=comments class="relative group">Comments <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#comments aria-label=Anchor>#</a></span></h2><p>Nearly every programming language has a feature to include comments within the body of the source code. Additionally, tools like Git allow developers to associate comments with changes that they introduced to their source code. However, just because it is possible to comment, does not mean that a comment is the most appropriate way to communicate the message contained in the comment.</p><p>Comments are most appropriate when:</p><ol><li>The code would otherwise be completely opaque — for example most “lock free” using weakly consistent atomic featuring atom is or distributed synchronization code where the use of locks is distributed to several functions</li><li>To document interfaces especially when it documents pre or post conditions that are not easy to express in code with functions like assert. For example that the code requires a pointer to be “registered” with some other call first, or that the function “frees” the memory associated with its input</li><li>To provide macro level context of why code was written and what makes it different from other code that came before</li><li>To mark TODOs for the code</li><li>When the code serves as a personal reference or a teaching tool when it makes the code self-contained or to emphasize a subtle point.</li></ol><p>I tend to favor a lighter comment style. A comment can be seen in some cases as a code smell indicating that the APIs and functions involved dose not reflect the intent of the code. A developer favoring this style of comments would use variable and function names to show intent rather than comments. Note that this works best when functions are small and describe a single intent.</p><p>Maybe that changes if the code is truly arcane (a regex, shell code, forth, awk, Perl, some Haskell for a C programmer, and TeX all come to mind) maybe this changes, and documentation is sparse to non-existent.</p><p>However it’s worth knowing in every windows IDE I have ever used you just hover unfamiliar APIs like VirtualAllocEX and the IDE summarizes either the call and it’s arguments. If your comment shows up on hover, you don’t need to add it.</p><p>I write comments while learning new APIs. I keep a running journal of code like this, and even have a directory on my machine for code like this called <code>play</code> (Thank you Dr. Malloy) for this code. It also has a place in teaching examples. When I was first learning Perl and Haskell, it annoyed me how terse some of the code was without any comments, and it was not until I found a book that had comments like this that I finally got it.</p><p>When thinking about whether and how to comment consider:</p><ol><li>Tools can do a lot for you (even tools like Vim), and you should think about if you are duplicating their effort.</li><li>Good comments like code need to be updated and maintained with the code around them; is this comment worth the cost to maintain it in addition to the code?. Saying <code>close</code> closes a file in a comment is probably obvious and updating the comment is probably more effort than it’s worth, but I would not have guessed that VirtualAllocEx could allocate memory in another process. As a primarily a linux/unix developer, I appreciated this comment pointing out this huge possible foot-gun in the Windows API.</li><li>Git commit messages can not only serve as a place to keep important context about why a change was made, but also a high level summary of what is going on within a change. Reading through a large set of small changes is still challenging without some high level context of what was changed and why. In the note taking world this is called progressive summarization and is powerful in helping you review critical information quickly.</li></ol><h2 id=tools class="relative group">Tools <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#tools aria-label=Anchor>#</a></span></h2><p>A key part of learning to be a software craftsman is learning how to make the most out of your tools.
In is subsection, I discuss what kinds of tools to add to your belt and which ones that I use.</p><h3 id=text-editors class="relative group">Text Editors <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#text-editors aria-label=Anchor>#</a></span></h3><p>Another incredibly common question is what text editor/ IDE (integrated development environment) should I use?
This is a highly personal choice which will differ from person to person.
So while I don&rsquo;t want to proscribe a particular editor, I do want to caution against what I see as two common foibles.</p><p>First, don&rsquo;t shoot yourself in the foot by using a tool that provides so few features that you are going to be productive relative to more feature-full tools.
In this category, I place editors like &ldquo;pico&rdquo;, &ldquo;nano&rdquo;, &ldquo;gedit&rdquo; on Linux, and tools like &ldquo;notepad&rdquo; on windows.
These tools don&rsquo;t provide useful features like auto-completion, auto-indentation, and in some cases even basics like syntax highlighting.
There are many better tools that will help you write code better and faster.
Use them, they don&rsquo;t have that much higher of a learning curve.</p><p>My second &ndash; perhaps more controversial take &ndash; some IDEs are also not good choices.
Some IDEs have high monetary cost, are tied to a particular language/tool-chain, and require you to learn a completely new interface for each language that you use.
For these reasons, using proprietary IDEs <em>may</em> be not a good choice.
That doesn&rsquo;t mean that IDEs are not helpful, I use a proprietary IDE as a refactoring tool, but they shouldn&rsquo;t be the primary tool in your tool-belt.</p><p>When you want these rich features, I would recommend instead using a tool like the Language Server Protocol.
The Language Server Protocol provides an API to many of the features commonly implemented by IDEs in a way that many text editors can use them.
This makes these features much more portable to different text editors if you ever need or want to switch.
Likewise, I also automate the things that Language Server does not with a small tool that I wrote called <a href=https://github.com/robertu94/m target=_blank rel=noreferrer><code>m</code></a></p><p>I&rsquo;ve said quite a bit about what text editors what I wouldn&rsquo;t use, so which ones do I recommend.
I currently recommend:</p><ul><li>Vim &ndash; my daily driver</li><li>emacs &ndash; another capable editor</li><li>vscode &ndash; a light-weigh graphical editor</li></ul><table><thead><th scope=col>Editor</th><th scope=col>Vim</th><th scope=col>Emacs</th><th scope=col>Visual Stdio Code</th></thead><tbody><tr><th scope=row>Pros</th><td><ul><li>Ergonomic keyboard controls</li><li>Installed and runs almost everywhere</li></ul></td><td><ul><li>Emacs can be your entire workflow</li><li>Elisp is fully featured language</li></ul></td><td>Familiar Graphical Environment for new users while not pidgin holing you like an IDE</td></tr><tr><th scope=row>Cons</th><td><ul><li>The key bindings can be a nightmare to learn at first.</li><li>Vimscript is an awful language.</li></ul></td><td><ul><li>Emacs's learning curve is almost as steep as vim</li><li>Emacs constantly swaps files which is really frustrating on slow filesystems</li></ul></td><td><ul><li>Requires a graphical console</li><li>Uses the most memory and resources of the bunch</li><li>Extensions are written in JavaScript/TypeScript</li></ul></td></tr><tr><th scope=row>Common Misconception</th><td>Vim doesn't have advanced features like macros, autocompletion, syntax highlighting, code-formatting.
In reality these features are hidden behind obscure keyboard shortcuts</td><td>Emacs key combos will hurt your hand.
You can rebind almost any key, and plugin "EVIL mode" makes emacs much more ergonomic</td><td>You can't use VS Code on remote machines. In reality, it has built-in remote editing support that can edit files on other machines.</td></tr><tr><th scope=row>Getting Started</th><td><code>vimtutor</code> the build-in vim getting started exercise</td><td><ul><li><code>spacemacs</code> a emacs distribution with good defaults</li><li>the emacs tutorial, press <code>control+h</code> followed by <code>t</code> in emacs</li></ul></td><td>Introductory videos on the help page</td></tr><tr><th scope=row>Next Steps</th><td><ul><li>VimCasts - short videos on using vim</li><li>Practical Vim - a comprehensive book on vim tricks</li></ul></td><td><ul><li>learn elisp <code>control+h</code><code>i</code> then read choose <code>elisp</code></li></ul></td><td>Read the more extensive product documentatoin from the welcome screeen</td></tr></tbody></table><h3 id=debuggers class="relative group">Debuggers <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#debuggers aria-label=Anchor>#</a></span></h3><p>Debuggers are invaluable tools for programmers.
They allow you to step through a program at run time and interrogate the state of the program in a way that would otherwise be impossible or incredibly tedious.
Unfortunately debuggers are less universal than text editors.
I cannot just suggest one debugger that will work for every language even though <code>gdb</code> and <code>lldb</code> get close.
As such, I intend to point you to some features that are important and useful to have in your debugger.</p><ul><li>Run configurations/scripts &ndash; good debuggers allow you to allow you to save interesting sets of breakpoints/watchpoints and other settings in configuration files per project. You should use the features to be able to quickly run repeatable tests with your debugger.</li><li>Core Dumps &ndash; While not as emphasized today, core dumps are a dump of memory from the execution of a process that is created when a process is killed by the operating system. It is designed in such as way that all the key state is contained within the core-dump file making them invaluable for debugging problems from users.</li><li>Stop-hooks &ndash; stop hooks are a powerful feature when combined with break points. Stop hooks are arbitrary code that gets run when a breakpoint or watch point is triggered. You can use it to quickly print out useful state when the debugger stops or to make decisions about whether or not to a particular stop is interesting.</li><li>Watch points and conditional breakpoints &ndash; Watchpoints allow you to pause execution when a particular region of memory is modified. Conditional breakpoints are breakpoints that only actually stop when some condition is true. Together, these tools give a lot of power to control when to stop execution.</li><li>Writing plug-ins &ndash; Some of the most powerful debuggers like GDB and LLDB allow you to write extensions in a higher level language. They are several sets of the extensions that have been written and are used frequently such as <code>chisel</code> and <code>pwndbg</code>.</li></ul><p>Additionally, using a debugger is not a substitute for documenting and verifying your invariants (statements that are always true in your program) in your program.
Using language features or function like, C&rsquo;s <code>assert</code> macro can save a lot of time of determining when your state has become invalid.
There is an argument to be made that <code>assert</code> shouldn&rsquo;t be in production code; I&rsquo;m ambivalent on the question.
On the one hand, yes invalid state is bad, but is a crash worse?
At the minimum, it is better when debugging your code; use asserts at testing time.
If you have to take them out during runtime, use a feature like C&rsquo;s <code>assert</code> macro which remove debugs when the <code>-DNDEBUG</code> command line argument is passed.</p><p>Now some comments on how to use a debugger.
As I have suggested elsewhere, debugging is a scientific exercise.
You are creating a hypothesis that explains the behavior of the system, and you are using the debugger as tool to test that hypothesis.
This has some implications for how you use a debugger.
You aren&rsquo;t going to just step through the program line by line.
That is not a efficient use of your time, and it isn&rsquo;t a efficient use of the debugger.
Instead, postulate where you think the problem is, and stop there.
If you don&rsquo;t know where the problem is, use watchpoints or back tracing to find the suspect state.
You&rsquo;ll thank me later.</p><p>You can find more about <a href=https://robertu94.github.io/learning/gdb/>GDB here</a>.</p><h3 id=profilers class="relative group">Profilers <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#profilers aria-label=Anchor>#</a></span></h3><p>Profilers are typically &ldquo;lightweight&rdquo; tools that measure where the execution time of a program is being spent.
They save you the effort of having to manually instrument your code at all points where you would like to gather timings.
Some profilers can also incorporate low level system information from the kernel to give a more complete picture of performance.</p><p>One common problem across these tools is how to get a meaningful stack-traces.
Oftentimes, this comes down to two issues: including debugging symbols and not clobbering the frame pointer.
For gcc and clang with C/C++ programs, the flags you need are <code>-g -fno-omit-frame-pointer</code>, but there likely are similar flags for your language.</p><p>There are many different kinds of profilers.
Each has its own advantages and disadvantages.
Here are the ones that I use most often:</p><table><thead><tr><th>Tool</th><th>Type</th><th>Usecase</th></tr></thead><tbody><tr><td>Perf</td><td>sampling profiler</td><td>get instruction level usage information with low overhead</td></tr><tr><td>llvm-xray</td><td>call-sled profiler</td><td>get function call level overhead information with low overhead; Requires recompilation</td></tr><tr><td>callgrind</td><td>linker-based profiler</td><td>get function call level overhead information with moderate to high overhead; can simulate cache sizes</td></tr><tr><td>nvprof/nsight</td><td>Nvidia GPU profiling</td><td>You are profiling a GPU program on a Nvidia GPU</td></tr><tr><td>dtrace/ftrace/eBPF</td><td>Kernel call tracing</td><td>You want to profile time spent in the kernel</td></tr></tbody></table><p>You may also see suggesting to use <code>gprof</code>, In my opinion, this advise is largely out of date. The above tools are either higher performance, easier to use, or both.</p><p>Once you have a trace of the execution of your program, you will probably want to visualize it.
There are a number of tools for this, the ones I use are:</p><table><thead><tr><th>Tool</th><th>What it does</th></tr></thead><tbody><tr><td><a href=https://github.com/brendangregg/FlameGraph target=_blank rel=noreferrer>FlameGraphs</a></td><td>A set of Perl scripts that create SVG flame graphs which show hot spots in the application</td></tr><tr><td>KCacheGrind</td><td>An iterative tool that shows annotated call graphs</td></tr><tr><td>Google Chrome&rsquo;s <code>chorme://tracing</code></td><td>Interactive tool that can zoom in and out of complex and parallel traces</td></tr></tbody></table><p>To find more information, I would highly recommend Brandon Greg&rsquo;s <a href=http://www.brendangregg.com/linuxperf.html target=_blank rel=noreferrer>page on Linux introspection</a> which lists a host of other tools to get the information you need during runtime.</p><h3 id=build-systems class="relative group">Build Systems <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#build-systems aria-label=Anchor>#</a></span></h3><p>Another key tool to become familiar with is your build system.
Build systems as you expect allow you to build your project.
Yes, you could write a shell script or a program to build your program, but a proper build system will do a better job than you can quickly do without it:</p><ul><li>parallelize your build according to dependencies</li><li>handle caching and incremental compilation between builds</li><li>download and include dependencies</li><li>handle differences between compilers</li><li>provide a system to cross compile for a different native architecture</li><li>automatically provide hooks to customize installation, and debug builds</li><li>provide reasonable defaults.</li></ul><p>Every language seems to rely on its own build system and there are relatively few of them that work across languages.</p><p>So what should you learn to do with your build system?
At the risk of being obvious, you should learn to automate your entire build process using your build system.
This includes generating files when that is required, locating or downloading dependencies, or generating the source documentation.
This may not seem like a big deal, but by integrating with a build system for your language, you often get a series of knock-on effects like tooling that can use the information provided by your build system.</p><p>Another key thing to automate with the build system is the deployment of your application, but more on that in a later section.</p><p>Why do this, it ultimately saves you time and effort for almost everything else you want to do.</p><h3 id=version-control class="relative group">Version control <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#version-control aria-label=Anchor>#</a></span></h3><p>Lastly, the final tool that you should learn is a version control system.
Without a version control system, you can still track changes yourself: You&rsquo;ve probably had files on your computer called <code>thing_v1.txt</code>, <code>thing_v2.txt</code>, etc.
But then the question quickly becomes what if multiple team mates are making changes simultaneously, what was changed? Everything merged correctly? Why were things changed?
Version control systems solve the problems of</p><ul><li>tracking changes over time</li><li>making it easier to understand why a change was made</li><li>make it easier to share those changes consistently with others.</li></ul><p>At this point in history, that tool used most often is <code>git</code>.
Git currently is prevalent because it scales well to extremely large code bases and is flexible enough to support a number of different work flows.
To learn Git, I recommend the <a href=https://git-scm.com/book/en/v2 target=_blank rel=noreferrer>git book</a></p><p>However, beyond the question of mechanics, there are questions of policy.
When should you commit and why? If you commit, should you make one commit or a series of commits?
What constitutes a good commit message?
If you use branching, when do you use it and why?
If you use branching, what will your strategy be around handling conflicts when code diverges?
These are all questions that a seasoned craftsman should be able to answer.</p><p>So when should you commit?
There are two answers to this question.
On the one hand you should commit only when the code cleanly compiles and passes the test (a so-called atomic commit).
On the other hand, you might need multiple commits to have reasonable reversion points if you are making a big change.
So how do you resolve this conflict?
Different projects have different strategies, but I favor squashing the reasonable reversion points on development branches while avoiding rewriting history on the primary branch (typically called <code>master</code> or <code>develop</code>).
Other reasons to split commits would include to wall-off controversial changes from less controversial changes so they can be separately reviewed and committed.</p><p>Second, what constitutes a good commit message and why?
Here is a post that <a href=https://chris.beams.io/posts/git-commit/ target=_blank rel=noreferrer>I think thoughtfully addresses the issue</a>.
Ultimately it should be consistently formatted and spelled correctly, have a short descriptive title, a body that explains what was done, why it was done, and what other impacts it has, and cross references to issues databases if applicable.</p><p>Finally come the questions of branching.
There are several different philosophies about this.
There are naive answers like &ldquo;don&rsquo;t&rdquo; but such answers don&rsquo;t comprehend that in any distributed version control system, conflicts are inevitable on multi-person projects.
More nuanced answers say things like, &ldquo;one branch per feature&rdquo;, &ldquo;one branch per person&rdquo;, or &ldquo;one branch per release&rdquo;.
I&rsquo;ve worked with each, and don&rsquo;t have a strong opinion on which is correct.
It is more important to be consistent.</p><h2 id=libraries class="relative group">Libraries <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#libraries aria-label=Anchor>#</a></span></h2><p>Also important to any development effort is what you won&rsquo;t develop yourself.
Libraries are a form of dependency that provide standard functionality that you can adopt into your code leaving these dependencies to others.
While I talk about dependencies <a href=https://robertu94.github.io/posts/2022-05-05-dependencies/>more fully in another post</a>
I wanted to briefly list here the more kinds of things that you typically want to bring in as dependencies, and some of the key trade-offs</p><h3 id=logging class="relative group">Logging <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#logging aria-label=Anchor>#</a></span></h3><p>Logging is a deceptively simple problem.
Yes, the absolute simplest approach of printing to <code>stdout</code> or <code>console.log</code> is really easy to do,
but very quickly, you have a much more complicated problem.</p><p>Here are some of the things that send people looking for more complex logging tools:</p><ul><li>automatic insertion of context (i.e. stack traces, hostname, time, etc&mldr;)</li><li>distributed logging across several machines</li><li>log immutability and tamper dectection</li><li>filtering messages from a particular subsystem, severity, or host</li><li>extremely high reliability requirements &ndash; if logging does not work, you can not debug anything</li><li>extremely high bandwidth requirements &ndash; logging should not slow down the system</li><li>extremely constrained resource requirements &ndash; for example <code>printk</code> in the kernel needs to work before memory allocators are initialized.</li><li>human and machine readability</li></ul><p>Appropriate logging frameworks differ for each language, but projects like open telemetry are trying to
provide standard approaches to this that work across languages.</p><h3 id=configuration-files class="relative group">Configuration Files <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#configuration-files aria-label=Anchor>#</a></span></h3><p>Almost every program over a certain size has configuration files of some sort.
When considering how to design your configuration files, the real question is
what is your goal, and what will your users need and expect?</p><p>Here are some of the things that send people looking for more complex configuration tools:</p><ul><li>human readable error messages when an error is encountered parsing the file</li><li>types other than strings</li><li>fast parsing performance</li><li>human and machine read-abilty</li><li>machine and machine edit-ablity</li></ul><p>Here are a few possible choices:</p><p>Languages like <a href=https://cuelang.org/ target=_blank rel=noreferrer>like CUE</a> or
<a href=https://dhall-lang.org/ target=_blank rel=noreferrer>dHall</a> provide advanced features (data validation,
schema definition and error reporting, code generation, scripting tools) but
may not serve your particular language well or provide more features than you
may need.</p><p>YAML is another popular choice, giving a lot of flexibility, but features
aspects like type autodetection which are misfavored by some for the same
reasons that implicit casts are disfavored by some in C++.
Let’s be fair here: most the reasons people hate yaml are not yaml&rsquo;s fault. They
often boil down to the person who implemented yaml config files, essentially
wrote a Turing complete programming language in them (cough Kubernetes), or to
use it as a relational database and it is not the right tool for that.</p><p>TOML has many of the niceties of yaml but in my opinion provides less pain in
the edge cases and stripping out some of the unneeded features.</p><p>JSON is ubiquitous and simple, but some would argue is really easy to typo.
Classic ini files are also really simple, but lack schema validation.</p><p>XML is a very verbose (and often much maligned), but enables very sophisticated
manipulation and expression which may be appropriate given the complexity of a
particular use case &ndash; for example libVirt uses XML for virtual machine
definition and the web uses HTML which is similar in several respects.</p><p>Several projects that use embedded python or lua as the config file language.
This requires some setup, but is incredibly powerful granting functions,
looping, variables, string manipulation, and object orientation.
However all of this flexibility makes validation harder.</p><ul class=activity><li>What tools and libraries are part of your toolchain? If you do not use one of these tools why not? What would make your tool use more effective?</li></ul><h1 id=testing class="relative group">Testing <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#testing aria-label=Anchor>#</a></span></h1><p>One of the most expensive aspects of software development is when software either doesn&rsquo;t do what is supposed to.
Even innocuous seeming changes can sometimes have massive unintented effects, being able to detect these quickly massively increases productivity.
For this reason as soon as you know what you want to develop, testing code should follow swiftly after.</p><p>So now you have some code that is ready to test, how do you test it?
Scholars divide testing into two categories: verification and validation.</p><ul><li>Verification - does the system do what the requirement says the system does?</li><li>Validation - does the system do what we (the stakeholders) want it to?</li></ul><p>As suggested earlier in the sections on diagramming and prototyping, verification and validation should occur at several points along the development process in order to ensure the software works as expected and to minimize development efforts.
As such verification and validation occur in several forms.
I don&rsquo;t have room to say everything that could be said about testing.</p><p>You may be surprised that this section is far shorter than the others.
On the one level, I&rsquo;ve touched on verification and validation throughout the document.
On the another level, writing good tests is just something that comes with practice
In my opinion, writing good tests is one of the hardest skills to develop as a software craftsman.
One the one level, its easy to write tests.
You just do it using some library that makes it relatively easy for your language.
On another level, ensuring that you have the <em>right</em> tests is far harder.</p><p>So what are the right tests?
Perhaps obviously, you should conduct sufficient tests to ensure that the requirements are obeyed for all inputs.
Does that mean you should test every integer between <code>INT_MIN</code> and <code>INT_MAX</code>? No.
But you should test enough of them to know that you didn&rsquo;t make a mistake.
So how do you know what that is?
In practice, tests cases are chosen by:</p><ul><li>Choosing cases that execute a given function<ul><li>Choosing a few arbitrary cases</li><li>Choosing boundary conditions (i.e. <code>INT_MIN</code>, -1, <code>0</code>, 1, and <code>INT_MAX</code>, powers of 2 ± 1, etc for a routine that takes an integer) in addition to the arbitrary cases.</li></ul></li><li>Choosing cases that execute every branch of a given function at least once</li><li>Choosing cases that execute every path through a given function</li></ul><p>As you could imagine, as you go down the list the difficulty of creating the test cases becomes sizable, but we have more confidence that the implementation is correct.
This has led to efforts to find ways to otherwise verify the correctness of an implementation.</p><p>Some more esoteric options that have been used to build a list of test cases before are:</p><ul><li>Use fuzz testing which uses random inputs for a given length of time.</li><li>Use some generator which creates a provably sufficient set of test cases from the state machine that the program describes.</li><li>Write two (or more) separate implementations that use different algorithms/designs and compare their answers for a number of inputs.</li></ul><p>When you do your tests also matters.
Tests can be ordered in terms of the amount of the system that they test.
At one extreme, you have unit tests which test a single function or small set of functions.
Slightly larger are integration tests which test interface boundaries between modules.
Finally there are acceptance tests which validate the entire system (one example is approval test mentioned earlier).</p><p>Lastly what about testing without code?
One of the most common form of testing without code is the review.
If you have access to it, I would read the paper &ldquo;Design and Code Inspections to Reduce Errors in Program Development&rdquo;.
While it is an older paper, the techniques outlined it seem to be rediscovered every few years.
The paper shows that reviews are most effective when the reviewers and the person putting their code up for review are given a checklist which indicates areas that should be considered during the review in advance.
During the review, the reviewers bring up the aspects they found during their private review which they consider most important.
The checklist serves about which sections of the system are prone to error.
There are several of these lists that exist, but ultimately for the greatest utility, you will want to modify these lists to include issues which frequently are represented amongst you and your team.</p><p>The other major form of testing without code involves modeling.
In modeling, you construct an accurate mathematical model or simulation of the system to emulate the real world testing.
If you can prove some form of correspondence between the code and the model, and the model produces correct results, then you can conclude that the design is &ldquo;correct&rdquo;.
While the ultimate form of this where all software is verifiable mathematically is provably a pipe dream <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, short of that there are extensive areas where these problems can be solved allowing for so-called &ldquo;static analysis&rdquo;.
Static analysis has and continues to be powerful tool in proving the correctness of software.</p><ul class=activity><li>What is the current state of tests and reviews in the system you use? Do they catch bugs before you can? Why or why not?</li></ul><h1 id=deployment class="relative group">Deployment <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#deployment aria-label=Anchor>#</a></span></h1><p>The last major step of software development is to release the software to the world.
Now how you release it may differ: you might release the software strictly in binary form in exchange for monetary compensation (proprietary software), you might release the software under an open source license, you might publish a paper about the concepts revealed or discovered while writing the software.
Software is more useful while it is shared.</p><p>I do want to pause for a moment to remark that even those who aren&rsquo;t typically taught of as software engineers such as scientists and analysts need to think about deployment.
I think this is true for two reasons.
First, many conferences and journals now have reproducibility requirements in order to publish.
Second, even if you don&rsquo;t publish the work to the broader world, you almost certainly have other people on your team.
They need to be able to run your software too.
If they can, they can help you do your research and provide insights that they couldn&rsquo;t do if they can&rsquo;t reproduce your work.</p><p>So what does it mean to release software?
There is some debate about this question.
Fundamentally, there are a few axis on which teams develop their release process: timing or release, scope of release, and support of a release.</p><p>First comes the timing of a release.
Should you use a staged release process where you have a feature freeze, a time of bug fixing, and then a coordinated release?
Several projects do this: LLVM, the Fedora project, and the Linux kernel are all examples.
That doesn&rsquo;t mean that you couldn&rsquo;t download the pre-release code for any of these.
All of these have publicly available pre-release versions of their software, but that is not what they recommend that the general population use.
The alternative is rolling releases.
In a rolling release model, software is release continuously.
There are no &ldquo;releases&rdquo; that are to be considered more stable than the others.
Everything goes on the top of the source development tree and keeps going.
Projects like ArchLinux, OpenSUSE LEAP, Google&rsquo;s Abseil all do this.
The benefits of a staged release process is that it gives an opportunity to stabilize the code base as a formal part of the development process.
The benefits of a rolling release process is that you don&rsquo;t have to wait for a release to deliver a fix or new feature.</p><p>Second is the scope of the release.
What is true at the time of a release?
Is there documentation and test cases for all the code as their is with many pieces of proprietary software?
Is it coordinated with the release of other software like the sub-projects of LLVM?
When you release code, what promises are you making to your users?
This is the scope of the release.</p><p>Finally what is the support of the release?
Are users allowed to expect that they can use the software for 1 year, 2 years, 5 years, 10 years or more without changes?
What compilers and language version are you going to support?
What dependencies are you expecting that the users provide and which versions?
Writing software is important, maintaining it so that others can rely upon it is almost more important.</p><p>In the remainder of this section, I want to briefly address some specific concerns about how to release software for Linux and how to use Container technology which have largely shaped how software has been written for Linux in the last few years.</p><h2 id=targeting-linux class="relative group">Targeting Linux <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#targeting-linux aria-label=Anchor>#</a></span></h2><p>Linux is not just one platform.
Yes it is one kernel, but that most software uses more than just the kernel.
Therefore, understanding the broader ecosystem is important.</p><h3 id=standards class="relative group">Standards <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#standards aria-label=Anchor>#</a></span></h3><p>Writing portable software for Linux is difficult.
Every distribution seems to put files in different places, depend on different fundamental libraries, and make other slight differences.
One way help sort out the chaos is to take advantage of standards.</p><p>Some of the most important standards are POSIX and the XDG-Desktop standards.
These standards specify how you can do some basic things on a Linux system in portable way.
Things like reading files, starting processes, inter-process communication, are all covered by the POSIX standards.
The XDG-Desktop standards cover things like where to put configuration files for user facing programs, how to specify icons and launcher files, where to put documentation.
If there is a POSIX or XDG Desktop way to do things, you should probably prefer it.</p><p>Next, you should be aware of the services that are provided by systemd.
I&rsquo;ll talk about systemd more in a later section, but on most Linux distributions (with a few narrow exceptions), if you write your software to use Systemd APIs your program is likely to be portable across many different Linux distributions.
Systemd provides mechanisms to create users, monitor files, start daemons, control the network state, and much more.
I would prefer systemd mechanisms second.</p><p>Finally, I would look at specific desktop specific design guidelines such as those put out by Gnome Ubuntu KDE Elementary OS.
These guidelines can give lot of insight into how to make your application fit graphically into the desktop but often tie you to a specific desktop environment.
I use these methods with caution.</p><h3 id=security-model class="relative group">Security Model <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#security-model aria-label=Anchor>#</a></span></h3><p>Another important thing to think about when writing software for Linux is how you want to secure your program.
Linux provides a host of facilities to control what resources that particular programs have access to.
Most of these techniques are centered around creating a service user/group which has permissions to access particular resources in particular ways.</p><p>You should also be aware that there are more advanced mechanisms that implement mandatory role based access control schemes enforced by the kernel. Two such examples are SELinux and AppArmor. If you need more than what permissions and groups can offer you should consider using these tools.</p><h3 id=writing-daemons class="relative group">Writing Daemons <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#writing-daemons aria-label=Anchor>#</a></span></h3><p>What is a daemon?
A daemon is an old word for long-running software that runs in the background to provide some service.
There are many daemons that run on a typical machine, but examples include httpd (the web server), vsftpd (a ftp server), and even systemd (the system services daemon).</p><p>On Linux, there are two common types of daemons, new-style daemons and old-style daemons.
New style daemons work on any system running systemd (most of them).
Old style daemons work on more systems, but have far fewer default services available to them.
How to write each of them is out of scope for this article, but I recommend that you read the distinction between them on <a href=https://www.freedesktop.org/software/systemd/man/daemon.html target=_blank rel=noreferrer>Systemd&rsquo;s page</a>.</p><p>Another key piece of software to know about for writing user-facing daemons on Linux is DBus &ndash; the daemon bus.
It provides an interprocess communication mechanism that allows for services to register at both &ldquo;well-known&rdquo; names, but also at specific names allowing different implementations of the same services.
Many of these well-known interfaces are standardized under XDG-Desktop services.</p><h3 id=available-components class="relative group">Available Components <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#available-components aria-label=Anchor>#</a></span></h3><p>Linux has a number of infrastructure services that are available to use to build your software.
A <a href=https://wiki.archlinux.org/index.php/List_of_applications target=_blank rel=noreferrer>great list of services and tools is available on the Arch Linux Viki</a>.
There are probably several implementations of any particular supporting service that you need.
If you need help choosing between the services I recommend you checkout the corresponding section on choosing a Linux distribution of my <a href=https://robertu94.github.io/learning/linux/#choosing-a-distribution>learning to learn Linux post</a> since there are many similarities between choosing a distribution and choosing a particular implementation of a service.</p><h3 id=traditional-package-formats class="relative group">Traditional Package Formats <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#traditional-package-formats aria-label=Anchor>#</a></span></h3><p>So great, you&rsquo;ve written your software and now you are trying to figure out how to get it installed on someone else&rsquo;s computer.
That is where package management comes in.
I covered the major different kinds of packages in the learning to learn Linux post.
If your language provides a package management mechanism (most do), I recommend using it.
Most of the major packaging systems used by each distribution have ways to convert these specific package types to the one native for each system.</p><h3 id=container-technology class="relative group">Container Technology <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#container-technology aria-label=Anchor>#</a></span></h3><p>The other major alternative traditional package management is container technology.
On the one hand they aren&rsquo;t that different.
If you couldn&rsquo;t get your code to install consistently without a package manager, containers aren&rsquo;t going to magically fix it.
What they do fix is the distribution of the dependencies that you might need.</p><p>Here are a few key pieces of advice for building containers:</p><ol><li>Use a build script &ndash; the more autonomous you can make the build process, the less work it will be for you in the long run.</li><li>Use a container optimized distribution like &ldquo;Alpine Linux&rdquo;. Alpine Linux choose a great set of defaults for making minimal container images. They build libraries that you will typically need statically allowing you to install only what you absolutely need in the container to build a minimal image.</li><li>Restrict the permissions of the container as much as possible. This gives you a secure by default behavior which makes you containers easier to adopt and use. Likewise, don&rsquo;t run as <code>root</code> in the container.</li><li>Use tools like <code>.dockerignore</code> to avoid adding unnecessary files to the container images.</li><li>When building container build scripts, install the dependencies first as their own layer. This will make rebuilding the containers much faster</li><li>Either use a container build system that allows you to manually specify when layers are created (buildah, moby, etc&mldr;), or use scripting tools like <code>&&</code> to minimize the number of layers that are created.</li><li>Consider setting up a caching proxy if you are going to be building containers frequently to speed up the download process.</li><li>If you need to start several processes in the container, then write an entry point script that will start them or use a container management system like <code>supervisord</code></li><li>If at all reasonable, try to separate different daemons into separate containers. This will make it easier to update them and restrict the permissions on a single container.</li><li>Consider using a management tool like <code>docker-compose</code>, <code>dagger</code>, or <code>kubernetes</code> when you wan to run more than a few containers on a regular basis. This will help you ensure that containers are spawned in a consistent fashion.</li></ol><h2 id=continuous-integration-and-continuous-deployment class="relative group">Continuous Integration and Continuous Deployment <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#continuous-integration-and-continuous-deployment aria-label=Anchor>#</a></span></h2><p>The two final topics related to deployment regularly talked about are continuous integration and continuous deployment (CI/CD).
These deal with automating the process of building the application, running a series of tests against it, and releasing it to users.
This is desirable because release management efforts are time consuming, tedious, and error prone.
Automating the process means that your computer can work along side you to ensure that you are doing things correctly.</p><p>There are a bunch of tools for doing CI/CD.
The most well known are probably Jenkins, TravisCI, AppVeyor, and GitLab.
I&rsquo;ve recently come to appreicate tools like <code>dagger</code> which enable portable CI workflows.
Each offers their own distinct advantages and disadvantages that you should consider carefully when choosing which to use.
Almost all of them have templates for most common languages that you can copy and paste for your applications.
Setting up CI/CD often isn&rsquo;t hard, but you will likely be glad that you did.</p><h1 id=conclusion class="relative group">Conclusion <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#conclusion aria-label=Anchor>#</a></span></h1><p>Becoming a software craftsman is not something that happens overnight.
It takes consistent practice and effort to better your skills.
I hope this article was helpful in helping you consider where you can improve and showing some ways to improve.
Please let me know if you have any feedback.</p><h2 id=change-log class="relative group">Change Log <span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#change-log aria-label=Anchor>#</a></span></h2><ul><li>February 2023 - Added section on security, fixed table</li><li>January 2023 - Added section on libraries, updated sections on tools to explain why to use them.</li><li>October 2022 - Added section on comments</li><li>August 2020 - Added links to flame graphs.</li><li>March 2020 - Initial Version</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Software that could prove that software always terminates with the correct result would require the prover to first determine that the software would terminate which has been proved in to be impossible in a computationally efficient way. See the discussion in Cook, Stephen A. &ldquo;The complexity of theorem-proving procedures.&rdquo; Proceedings of the third annual ACM symposium on Theory of computing. 1971.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></section><footer class="max-w-prose pt-8 print:hidden"><div class=flex><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Author</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Robert Underwood</div><div class="text-sm text-neutral-700 dark:text-neutral-400">Robert is an Assistant Computer Scientist in the Mathematics and Computer Science Division at Argonne National Laboratory focusing on data and I/O for large-scale scientific applications including AI for Science using techniques of lossy compression, and data management. He currently co-leads the AuroraGPT Data Team with Ian Foster. In addition to AI, Robert’s library LibPressio, allows users to experiment and adopt advanced compressors quickly, has over 200 average unique monthly downloads, is used in over 17 institutions worldwide, and he is also a contributor to the R&amp;D100 winning SZ family of compressors and other compression libraries. He regularly mentors students and is the early career ambassador for Argonne to the Joint Laboratory for Extreme Scale Computing.</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://github.com/robertu94 target=_blank aria-label=Github rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=mailto:rr.underwood94@gmail.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=/about target=_blank aria-label=Link rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 640 512"><path fill="currentcolor" d="M172.5 131.1c55.6-55.59 148-55.59 203.6.0 50 50 57.4 129.7 16.3 187.2L391.3 319.9C381 334.2 361 337.6 346.7 327.3c-14.4-10.3-17.8-30.3-7.5-44.6L340.3 281.1C363.2 249 359.6 205.1 331.7 177.2c-31.4-31.4-82.5-31.4-114 0L105.5 289.5c-31.51 30.6-31.51 82.5.0 114C133.3 431.4 177.3 435 209.3 412.1L210.9 410.1C225.3 400.7 245.3 404 255.5 418.4 265.8 432.8 262.5 452.8 248.1 463.1L246.5 464.2c-58.4 41.1-136.3 34.5-186.29-15.4-56.469-56.5-56.469-148.1.0-204.5L172.5 131.1zM467.5 380c-56.5 56.5-148 56.5-204.5.0-50-50-56.5-128.8-15.4-186.3L248.7 192.1C258.1 177.8 278.1 174.4 293.3 184.7 307.7 194.1 311.1 214.1 300.8 229.3L299.7 230.9C276.8 262.1 280.4 306.9 308.3 334.8c31.4 31.4 82.5 31.4 114 0L534.5 222.5c31.5-31.5 31.5-83.4.0-114C506.7 80.63 462.7 76.99 430.7 99.9L429.1 101C414.7 111.3 394.7 107.1 384.5 93.58 374.2 79.2 377.5 59.21 391.9 48.94L393.5 47.82C451 6.731 529.8 13.25 579.8 63.24c56.5 56.46 56.5 148.06.0 204.46L467.5 380z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href="https://scholar.google.com/citations?user=GbhfWUIAAAAJ&amp;hl=en" target=_blank aria-label=Google-Scholar rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg height="16" width="16" viewBox="0 0 512 512"><path fill="currentcolor" d="M390.9 298.5s0 .1.1.1c9.2 19.4 14.4 41.1 14.4 64C405.3 445.1 338.5 512 256 512s-149.3-66.9-149.3-149.3c0-22.9 5.2-44.6 14.4-64h0c1.7-3.6 3.6-7.2 5.6-10.7 4.4-7.6 9.4-14.7 15-21.3 27.4-32.6 68.5-53.3 114.4-53.3 33.6.0 64.6 11.1 89.6 29.9 9.1 6.9 17.4 14.7 24.8 23.5 5.6 6.6 10.6 13.8 15 21.3 2 3.4 3.8 7 5.5 10.5zm26.4-18.8c-30.1-58.4-91-98.4-161.3-98.4s-131.2 40-161.3 98.4L0 202.7 256 0 512 202.7l-94.7 77.1z"/></svg></span></a>
<a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://orcid.org/0000-0002-1464-729X target=_blank aria-label=Orcid rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 512 512"><path fill="currentcolor" d="M294.75 188.19h-45.92V342h47.47c67.62.0 83.12-51.34 83.12-76.91.0-41.64-26.54-76.9-84.67-76.9zM256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm-80.79 360.76h-29.84v-207.5h29.84zm-14.92-231.14a19.57 19.57.0 1119.57-19.57 19.64 19.64.0 01-19.57 19.57zM3e2 369h-81V161.26h80.6c76.73.0 110.44 54.83 110.44 103.85C410 318.39 368.38 369 3e2 369z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://www.youtube.com/@robertunderwood97 target=_blank aria-label=Youtube rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 576 512"><path fill="currentcolor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78.0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"/></svg>
</span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" style=will-change:transform href=https://keybase.io/robertu94 target=_blank aria-label=Keybase rel="me noopener noreferrer"><span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 448 512"><path fill="currentcolor" d="M286.17 419a18 18 0 1018 18 18 18 0 00-18-18zm111.92-147.6c-9.5-14.62-39.37-52.45-87.26-73.71q-9.1-4.06-18.38-7.27A78.43 78.43.0 00244.57 86.29c-12.41-4.1-23.33-6-32.41-5.77-.6-2-1.89-11 9.4-35L198.66 32l-5.48 7.56c-8.69 12.06-16.92 23.55-24.34 34.89a51 51 0 00-8.29-1.25c-41.53-2.45-39-2.33-41.06-2.33-50.61.0-50.75 52.12-50.75 45.88l-2.36 36.68c-1.61 27 19.75 50.21 47.63 51.85l8.93.54a214 214 0 00-46.29 35.54C14 304.66 14 374 14 429.77v33.64l23.32-29.8a148.6 148.6.0 0014.56 37.56c5.78 10.13 14.87 9.45 19.64 7.33 4.21-1.87 10-6.92 3.75-20.11a178.29 178.29.0 01-15.76-53.13l46.82-59.83-24.66 74.11c58.23-42.4 157.38-61.76 236.25-38.59 34.2 10.05 67.45.69 84.74-23.84.72-1 1.2-2.16 1.85-3.22a156.09 156.09.0 012.8 28.43c0 23.3-3.69 52.93-14.88 81.64-2.52 6.46 1.76 14.5 8.6 15.74 7.42 1.57 15.33-3.1 18.37-11.15C429 443 434 414 434 382.32c0-38.58-13-77.46-35.91-110.92zM142.37 128.58l-15.7-.93-1.39 21.79 13.13.78a93 93 0 00.32 19.57l-22.38-1.34a12.28 12.28.0 01-11.76-12.79L107 119c1-12.17 13.87-11.27 13.26-11.32l29.11 1.73a144.35 144.35.0 00-7 19.17zm148.42 172.18a10.51 10.51.0 01-14.35-1.39l-9.68-11.49-34.42 27a8.09 8.09.0 01-11.13-1.08l-15.78-18.64a7.38 7.38.0 011.34-10.34l34.57-27.18-14.14-16.74-17.09 13.45a7.75 7.75.0 01-10.59-1s-3.72-4.42-3.8-4.53a7.38 7.38.0 011.37-10.34L214 225.19s-18.51-22-18.6-22.14a9.56 9.56.0 011.74-13.42 10.38 10.38.0 0114.3 1.37l81.09 96.32a9.58 9.58.0 01-1.74 13.44zM187.44 419a18 18 0 1018 18 18 18 0 00-18-18z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/learning/time/><span class="me-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&larr;</span><span class="ltr:hidden rtl:inline">&rarr;</span></span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Learning to Learn: Task Management, Time Tracking, and Journaling</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-01-22 08:00:00 -0500 -0500">22 January 2023</time>
</span></span></a></span><span><a class="group flex text-right" href=/learning/software_for_teams/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Learning to Learn: Software Teams</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-02-09 00:00:00 +0000 UTC">9 February 2023</time>
</span></span><span class="ms-2 text-neutral-700 transition-transform group-hover:-translate-x-[-2px] group-hover:text-primary-600 dark:text-neutral dark:group-hover:text-primary-400"><span class="ltr:inline rtl:hidden">&rarr;</span><span class="ltr:hidden rtl:inline">&larr;</span></span></a></span></div></div></footer></article></main><div class="pointer-events-none absolute bottom-0 end-0 top-[100vh] w-12" id=to-top hidden=true><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div><footer class="py-10 print:hidden"><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2025
Robert Underwood</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://github.com/jpanther/congo target=_blank rel="noopener noreferrer">Congo</a></p></div><div class="flex flex-row items-center"></div></div></footer><div id=search-wrapper class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://robertu94.github.io/><div id=search-modal class="top-20 mx-auto flex min-h-0 w-full max-w-3xl flex-col rounded-md border border-neutral-200 bg-neutral shadow-lg dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex flex-none items-center justify-between px-2"><form class="flex min-w-0 flex-auto items-center"><div class="flex h-8 w-8 items-center justify-center text-neutral-400"><span class="icon relative inline-block px-1 align-text-bottom"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="mx-1 flex h-12 flex-auto appearance-none bg-transparent focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex h-8 w-8 items-center justify-center text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="icon relative inline-block px-1 align-text-bottom"><svg viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto overflow-auto px-2"><ul id=search-results></ul></section></div></div></div></body></html>