<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>flex/bison on systems++</title><link>http://robertu94.github.io/tags/flex/bison.html</link><description>Recent content in flex/bison on systems++</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://robertu94.github.io/tags/flex/bison/index.xml" rel="self" type="application/rss+xml"/><item><title>Interpreters Made Easy</title><link>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</link><pubDate>Sun, 15 Jan 2017 10:14:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</guid><description>The Interpreter pattern from the &amp;ldquo;Design Patterns: Elements of Reusable Object Oriented Software&amp;rdquo; can potentially be a very powerful pattern. It allows you to use a domain specific language to represent a complex computational situation. However, writing interpreters in practice can be tricky and time consuming. It really helps to know something about some fundamental parsing algorithms and techniques.
The most naive approach to writing an interpret involves manually matching each possible next phrase and creating an if else soup to match each possible outcome.</description></item></channel></rss>