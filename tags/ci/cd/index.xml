<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CI/CD on Systems++</title><link>https://robertu94.github.io/tags/ci/cd/</link><description>Recent content in CI/CD on Systems++</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 24 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://robertu94.github.io/tags/ci/cd/index.xml" rel="self" type="application/rss+xml"/><item><title>Refactoring CI/CD for a Moderately Large C++ Code Base</title><link>https://robertu94.github.io/posts/2023-03-29-dagger/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/posts/2023-03-29-dagger/</guid><description>&lt;p>CI/CD is a critical, but difficult to get right part of software engineering.
You often want to test multiple distributions, multiple compilers on each commit, and you want that to be as fast as reasonably possible.
This gets more complicated when you have large dependency trees that you want to remain consistent.
Recently, I adapted the CI/CD system for a project that I maintain LibPressio to use Dagger &amp;ndash; a programmatic way to do CI/CD portable-ally across runner environments which made it easier to run our tests and verify correctness.&lt;/p></description></item></channel></rss>