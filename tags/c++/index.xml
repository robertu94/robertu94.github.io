<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Systems++</title><link>https://robertu94.github.io/tags/c++/</link><description>Recent content in C++ on Systems++</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 22 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://robertu94.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Learning to Learn: GDB</title><link>https://robertu94.github.io/learning/gdb/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/learning/gdb/</guid><description>&lt;p>GDB is a powerful tool that is underutilized by most programmers that I&amp;rsquo;ve met.
It can tell you the state of one or more running or crashed programs, and even manipulate the memory of a running process.
It is an invaluable tool for understanding what is going wrong with your programs.&lt;/p></description></item><item><title>Learning to Learn: MPI</title><link>https://robertu94.github.io/learning/mpi/</link><pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><guid>https://robertu94.github.io/learning/mpi/</guid><description>&lt;p>MPI is the de-facto standard way to write distributed programs that run on super computers.
Many have tried to replace it, but so far none of them have succeeded.
Learning to use it successfully, will enable you to write powerful distributed programs.&lt;/p></description></item><item><title>Learning to Learn: CMake</title><link>https://robertu94.github.io/learning/cmake/</link><pubDate>Tue, 15 Nov 2022 05:00:00 -0500</pubDate><guid>https://robertu94.github.io/learning/cmake/</guid><description>&lt;p>CMake is the de-facto C++ build system used by an overwhelming number of C++ projects.
Even if you personally favor more modern alternatives such as Meson, Bazel, or Pants, if you
ever pull in a 3rd party dependency, there is a good chance that it uses CMake so
knowing enough about CMake to understand it is worth knowing.&lt;/p></description></item><item><title>Generic Cuda</title><link>https://robertu94.github.io/posts/2018-05-12-generic-cuda/</link><pubDate>Sat, 12 May 2018 08:00:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2018-05-12-generic-cuda/</guid><description>&lt;p>GPU programming has the potential to make embarrassingly parallel tasks very quick.
But what if you want to perform the same task on a variety of different types?
In this post, I walk through a generic testing code that preforms a vector add on GPU and CPU to verify the correctness.&lt;/p></description></item><item><title>Learning to Learn: C++</title><link>https://robertu94.github.io/learning/cpp/</link><pubDate>Fri, 12 Jan 2018 19:00:14 -0500</pubDate><guid>https://robertu94.github.io/learning/cpp/</guid><description>&lt;p>C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.&lt;/p></description></item><item><title>Life with Libtooling</title><link>https://robertu94.github.io/posts/2017-12-10-life-with-libtooling/</link><pubDate>Sun, 10 Dec 2017 11:21:00 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-12-10-life-with-libtooling/</guid><description>&lt;p>Over the last two months, I spent a significant amount of time using Clang&amp;rsquo;s libtooling.
Libtooling is a great way to quickly develop tools to analyze and modify large quantizes of C++.
In this article, I share some lessons learned working with libtooling.&lt;/p></description></item><item><title>Qt is for more than just GUIs</title><link>https://robertu94.github.io/posts/2017-05-23-qt-as-library/</link><pubDate>Tue, 23 May 2017 10:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-05-23-qt-as-library/</guid><description>&lt;p>When most people think of Qt, I imagine that they think about the Graphical User Interface components.
But Qt has a variety of other components beyond just being a GUI framework.
In this post, I highlight some of what I find to be the more interesting features.&lt;/p></description></item><item><title>Resource Acquisition is Initialization and SDL</title><link>https://robertu94.github.io/posts/2017-05-08-sdl-raii/</link><pubDate>Mon, 08 May 2017 05:30:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-05-08-sdl-raii/</guid><description>&lt;p>Recently, I was working on a project for &lt;a href="brianmalloy.com">2D Game Development&lt;/a> where I had to use SDL 2.0.
SDL 2.0 is a family of media libraries designed for writing cross platform games in C.
However it can be difficult to remember where various resources are allocated and deallocated.
Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem.
So I wrote a series of wrappers for SDL 2.0 that use RAII and various other improvements.&lt;/p></description></item><item><title>Smart Pool</title><link>https://robertu94.github.io/posts/2017-04-29-smart-pool/</link><pubDate>Sun, 30 Apr 2017 09:58:14 -0500</pubDate><guid>https://robertu94.github.io/posts/2017-04-29-smart-pool/</guid><description>&lt;p>Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development.
However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool.
In this article, I layout a class that I recently used to automatically manage memory from a pool.&lt;/p></description></item></channel></rss>