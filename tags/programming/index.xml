<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Programming on systems++</title><link>http://robertu94.github.io/tags/programming.html</link><description>Recent content in Programming on systems++</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 10 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://robertu94.github.io/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>External Clang-Tidy Modules! C++ Refactoring for the Common Project</title><link>http://robertu94.github.io/2023/03/10/external-clang-tidy-modules-c-refactoring-for-the-common-project.html</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2023/03/10/external-clang-tidy-modules-c-refactoring-for-the-common-project.html</guid><description>Clang style refactoring has been something I&amp;rsquo;ve been admiring from afar for quite a while now. However for a user to actually use it, it has previously required forking llvm to be able to use it in a reasonable fashion because of things like the hack in clang used to locate the resource directory or other fragile hacks like LD_PRELOAD.
Recently, the Clang/LLVM developers vastly improved the situation by allowing loadable clang-tidy modules and by installing all of the headers that you actually need to do something with clang tidy, and they are finally packaged on both Fedora and Ubuntu!</description></item><item><title>Refactoring With Clang Query</title><link>http://robertu94.github.io/2022/12/28/refactoring-with-clang-query.html</link><pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/28/refactoring-with-clang-query.html</guid><description>Have you ever wanted to identify a list of files that would need modifications to adopt a new API? Clang-Query can make this much easier. I recently wanted to introduce a set of helper functions to simplfy an aspect of compressor configuation in LibPressio. But first, I needed to know what modules were effected.
Clang-query needs a compilation database which can be produced by tools such as bear (if you have a Autotools or Makefile based project) or more sophisticated build systems such as cmake, meson or bazel.</description></item><item><title>Three Neat Things I Did With Julia</title><link>http://robertu94.github.io/2022/12/15/three-neat-things-i-did-with-julia.html</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/2022/12/15/three-neat-things-i-did-with-julia.html</guid><description>In the past, I&amp;rsquo;ve written pretty glowingly about Julia. It&amp;rsquo;s been a few years since I first used Julia in 2019, and it hasn&amp;rsquo;t completely replaced Python for me. However, I wanted to share a few neat projects that I&amp;rsquo;ve done using it which would have been much more painful without it, and share what I think now about what I wrote in 2019.
Implementing a Statistical Metric on the GPU Being able to access heterogenous compute is important to be able to make the most of the availible hardware.</description></item><item><title>Learning to Learn: CMake</title><link>http://robertu94.github.io/learning/cmake.html</link><pubDate>Tue, 15 Nov 2022 05:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/cmake.html</guid><description>CMake is the de-facto C++ build system used by an overwhelming number of C++ projects. Even if you personally favor more modern alternatives such as Meson, Bazel, or Pants, if you ever pull in a 3rd party dependency, there is a good chance that it uses CMake so knowing enough about CMake to understand it is worth knowing.
How to get started I recommend new users to CMake start with the following resources:</description></item><item><title>Thoughts on Dependencies for Scientific Software</title><link>http://robertu94.github.io/2022/07/20/thoughts-on-dependencies-for-scientific-software.html</link><pubDate>Wed, 20 Jul 2022 00:00:00 -0500</pubDate><guid>http://robertu94.github.io/2022/07/20/thoughts-on-dependencies-for-scientific-software.html</guid><description>Modern software does not exist in a vacuum, developers always rely on other developers or engineers to provide aspects of their systems. Even if you write hello world in your programming language of your choice you likely still depend on the standard library from your language. Even if you were to write hello world in the raw binary format of your assembly language, you still depend on the operating system. Even if you wrote your own uni-kernel to produce hello world on the console, you likely rely on vendor provided firmware to initialize the program or memory.</description></item><item><title>Spack: a Truly Useful Package Manager</title><link>http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html</link><pubDate>Thu, 27 Aug 2020 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/2020/08/27/spack-a-truly-useful-package-manager.html</guid><description>So you are developing software, and you need the software to build for multiple difference machines, with different version of a library, or with just different compile time options. You can probably manage this by hand, but it very quickly gets out of hand. Spack is a package manager designed for high performance computing, but I would argue is more broadly useful for five reasons:
It is explicitly designed to run as an unprivileged user.</description></item><item><title>Julia: Could There be One Language?</title><link>http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html</link><pubDate>Thu, 04 Apr 2019 09:00:00 -0500</pubDate><guid>http://robertu94.github.io/2019/04/04/julia-could-there-be-one-language.html</guid><description>There is a constant problem with programming language design: fast, generic, easy to write; pick two. The principle is that programming languages cannot be all three at once. Code that is Fast and Generic like C++ isn&amp;rsquo;t exactly easy to write. Code that is Generic and easy to write like Python isn&amp;rsquo;t always fast in the sense that C/C++ programmers mean it. Code that is Fast and Easy to Write isn&amp;rsquo;t always Generic in the sense that Python is.</description></item><item><title>Learning to Learn: Python</title><link>http://robertu94.github.io/learning/python.html</link><pubDate>Wed, 23 Jan 2019 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/python.html</guid><description>Python is a relatively simple language compared to others such as C++. Despite its simplicity, Python really shines because of its robust standard library, extensive 3rd party library ecosystem (especially for statistics and data analysis), and intuitiveness. This post tracks my process of learning how to program well in Python.
Order of Topics The listing of topics here is arbitrary and represents the path that I took to learn Python roughly organized by topic.</description></item><item><title>Learning to Learn: Reading</title><link>http://robertu94.github.io/learning/reading.html</link><pubDate>Wed, 08 Aug 2018 08:00:00 -0500</pubDate><guid>http://robertu94.github.io/learning/reading.html</guid><description>From time to time, I get questions about how I read and retain as much information as I do. While it is never easy &amp;ndash; especially with dry technical documents &amp;ndash; there are a few strategies that I have learned along the what that I find helpful. In this post I provide some general suggestions along with some that are more useful in computer systems research.
Strategies for Reading in General My chemistry and physics teacher &amp;ndash; Dr.</description></item><item><title>Generic Cuda</title><link>http://robertu94.github.io/2018/05/12/generic-cuda.html</link><pubDate>Sat, 12 May 2018 08:00:14 -0500</pubDate><guid>http://robertu94.github.io/2018/05/12/generic-cuda.html</guid><description>GPU programming has the potential to make embarrassingly parallel tasks very quick. But what if you want to perform the same task on a variety of different types? In this post, I walk through a generic testing code that preforms a vector add on GPU and CPU to verify the correctness.
The Test Harness Our main function is pretty simple:
int main(int argc, char* argv[]) { check_type&amp;lt;int&amp;gt;(); check_type&amp;lt;long&amp;gt;(); check_type&amp;lt;double&amp;gt;(); check_type&amp;lt;float&amp;gt;(); return 0; } So how do we write check_type?</description></item><item><title>Learning to Learn: C++</title><link>http://robertu94.github.io/learning/cpp.html</link><pubDate>Fri, 12 Jan 2018 19:00:14 -0500</pubDate><guid>http://robertu94.github.io/learning/cpp.html</guid><description>C++ is a huge language. It has tools form imperative, functional, object-oriented, and generic paradigms. And that leaves out the extremely fine control over things like memory allocation strategies in the standard library not generally available elsewhere. In this post, I present my learning path through C++ and offer some suggestions for learning this multi-faceted language.
Order of Topics This is not intended to be an exhaustive (for that would be far too long), or optimal (for that would be context dependent) listing of the topics, but rather the path that I took through the language.</description></item><item><title>Life with Libtooling</title><link>http://robertu94.github.io/2017/12/10/life-with-libtooling.html</link><pubDate>Sun, 10 Dec 2017 11:21:00 -0500</pubDate><guid>http://robertu94.github.io/2017/12/10/life-with-libtooling.html</guid><description>Over the last two months, I spent a significant amount of time using Clang&amp;rsquo;s libtooling. Libtooling is a great way to quickly develop tools to analyze and modify large quantizes of C++. In this article, I share some lessons learned working with libtooling.
Beware the Stability Guarantees. The biggest problem with libtooling is that it has very few if any Stability guarantees. When I was learning libtooling, I watched Peter Goldsborough&amp;rsquo;s video excellent &amp;ldquo;clang-useful: Building useful tools with LLVM and clang for fun and profit&amp;rdquo;.</description></item><item><title>Design of A Matrix loading Library</title><link>http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html</link><pubDate>Sat, 23 Sep 2017 07:00:00 -0500</pubDate><guid>http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html</guid><description>Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.
Design Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:</description></item><item><title>Qt is for more than just GUIs</title><link>http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html</link><pubDate>Tue, 23 May 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html</guid><description>When most people think of Qt, I imagine that they think about the Graphical User Interface components. But Qt has a variety of other components beyond just being a GUI framework. In this post, I highlight some of what I find to be the more interesting features.
Object Communication via Signals and Slots One of the coolest features of Qt is its very clean implementation of signals and slots. Signals and slots are a means of communicating information (called signals) between objects via special callbacks (called slots).</description></item><item><title>Pluggable Authentication With PAM</title><link>http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html</link><pubDate>Sun, 14 May 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html</guid><description>Authentication and authorization is one of foundational aspects of any security system. However writing an authentication and authorization system can be anything but: There are complex, ever-changing requirements, not to mention differences for differing interfaces it can quickly become daunting. However, there already exists a system on Linux and Unix that allows for dynamic and complex authentication: PAM.
PAM Modules and Authentication Types Fundamentally, PAM is a collection of modules that provide several methods.</description></item><item><title>Resource Acquisition is Initialization and SDL</title><link>http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html</link><pubDate>Mon, 08 May 2017 05:30:14 -0500</pubDate><guid>http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html</guid><description>Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.</description></item><item><title>Smart Pool</title><link>http://robertu94.github.io/2017/04/30/smart-pool.html</link><pubDate>Sun, 30 Apr 2017 09:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/04/30/smart-pool.html</guid><description>Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.
The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.</description></item><item><title>Faster than light</title><link>http://robertu94.github.io/2017/01/29/faster-than-light.html</link><pubDate>Sun, 29 Jan 2017 10:06:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/29/faster-than-light.html</guid><description>Ansible is probably my favorite provisioning and configuration management tool. Its syntax is concise, expressive, and elegant. Unlike other tools in its category, it has excellent documentation with working examples and intuitive naming. Learning it use it effectively can help you be a more productive developer.
Speeding Up Ansible Anyone that has used ansible for more than a few hosts with more than a few tasks knows that by default it can be really slow.</description></item><item><title>LLVM Tooling for C++</title><link>http://robertu94.github.io/2017/01/22/llvm-tooling-for-c-.html</link><pubDate>Sun, 22 Jan 2017 18:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/22/llvm-tooling-for-c-.html</guid><description>C++ is a both a fantastic language and a mess. It supports at least 4 programming paradigms (procedural, functional, object-oriented, template meta-programming). In some senses, many languages give you one great way to do things: C++ gives you every way and trusts you to use them well. With this flexibility comes problems that C++ seems to have beyond what other languages experience. Therefore, having effective tooling to develop and use C++ is essential.</description></item><item><title>Interpreters Made Easy</title><link>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</link><pubDate>Sun, 15 Jan 2017 10:14:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/15/interpreters-made-easy.html</guid><description>The Interpreter pattern from the &amp;ldquo;Design Patterns: Elements of Reusable Object Oriented Software&amp;rdquo; can potentially be a very powerful pattern. It allows you to use a domain specific language to represent a complex computational situation. However, writing interpreters in practice can be tricky and time consuming. It really helps to know something about some fundamental parsing algorithms and techniques.
The most naive approach to writing an interpret involves manually matching each possible next phrase and creating an if else soup to match each possible outcome.</description></item><item><title>Poor Man's Parallelism</title><link>http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html</link><pubDate>Sun, 08 Jan 2017 10:58:14 -0500</pubDate><guid>http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html</guid><description>I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can&amp;rsquo;t or don&amp;rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.
You can do this via Unix/shell job control:
cmd=&amp;#34;systemctl enable --now docker.service&amp;#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh &amp;amp; $host $cmd done However from experience, this can be very error prone.</description></item><item><title>Learning to Learn: GDB</title><link>http://robertu94.github.io/learning/gdb.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/learning/gdb.html</guid><description>GDB is a powerful tool that is underutilized by most programmers that I&amp;rsquo;ve met. It can tell you the state of one or more running or crashed programs, and even manipulate the memory of a running process. It is an invaluable tool for understanding what is going wrong with your programs.
How to get started To get the most out of GDB you need to compile your program with debug information &amp;ndash; metadata that describes the program source.</description></item><item><title>Learning to Learn: MPI</title><link>http://robertu94.github.io/learning/mpi.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://robertu94.github.io/learning/mpi.html</guid><description>MPI is the de-facto standard way to write distributed programs that run on super computers. Many have tried to replace it, but so far none of them have succeeded. Learning to use it successfully, will enable you to write powerful distributed programs.
Order of Topics MPI has a minimal powerful and useful core, but really tries to completely own it&amp;rsquo;s space.
I strongly reccommend reading &amp;ldquo;Using MPI&amp;rdquo; by Gropp et al.</description></item></channel></rss>