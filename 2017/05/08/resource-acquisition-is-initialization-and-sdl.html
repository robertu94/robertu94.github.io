<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Resource Acquisition is Initialization and SDL | systems++</title>
<meta name=keywords content="c++,programming">
<meta name=description content="Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.57f29198e62b3a8f07d37acaca0427bafb684416046b823f5a616bd858bb4af1.css integrity="sha256-V/KRmOYrOo8H03rKygQnuvtoRBYEa4I/WmFr2Fi7SvE=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Resource Acquisition is Initialization and SDL">
<meta property="og:description" content="Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-05-08T05:30:14-05:00">
<meta property="article:modified_time" content="2017-05-08T05:30:14-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Resource Acquisition is Initialization and SDL">
<meta name=twitter:description content="Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Resource Acquisition is Initialization and SDL","item":"http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Resource Acquisition is Initialization and SDL","name":"Resource Acquisition is Initialization and SDL","description":"Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.","keywords":["c++","programming"],"articleBody":"Recently, I was working on a project for 2D Game Development where I had to use SDL 2.0. SDL 2.0 is a family of media libraries designed for writing cross platform games in C. However it can be difficult to remember where various resources are allocated and deallocated. Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem. So I wrote a series of wrappers for SDL 2.0 that use RAII and various other improvements.\nRAII and std::shared_ptr One of the key reasons for the wrapper was to take advantage of RAII. It is fairly common in SDL to have code like so (constants provided for clarity):\nSDL_Init(SDL_INIT_VIDEO); SDL_Window* window = SDL_CreateWindow(\"animation\", posX, posY, WIDTH, HEIGHT, 0) SDL_Renderer* renderer = SDL_CreateRenderer(window, FIRST_WINDOW, SDL_RENDERER_PRESENTVSYNC); /* use pointers */ SDL_DestroyRenderer(renderer); //order matters to prevent memory leaks SDL_DestroyWindow(window); SDL_Quit(); In my library it looks more like this:\nauto lib = std::make_sharedSDLInit(SDL_INIT_VIDEO); auto window = std::make_sharedSDLWindow(\"animation\", posX, posY, WIDTH, HEIGHT, 0); auto renderer = std::make_sharedSDLRenderer(window, FIRST_WINDOW, SDL_RENDERER_PRESENTVSYNC); /* use pointers */ Here RAII and shared pointers in each of the classes ensure that each relevant class initialized correctly prior to use. And also the reference counting of std::shared_ptr ensures that they are freed when no longer used in an order that prevents leaks.\nSDLRect One of the core data classes used in SDL is the SDL_Rect. SDL provides several methods that all operate on SDL_Rects. Providing them as methods on the class greatly reduced duplication and simplified user code. Additionally, std::make_{shared,unique} don’t understand struct aggregate initialization. So I grouped them the constructors and methods into a class and provided constructors\nstruct SDLRect: public SDL_Rect { SDLRect(); //aggregate initialization and make_{shared,unique} don't mix; provide a constructor \tSDLRect(int x, int y, int w, int h);\tSDLRect(SDL_Rect const\u0026);\tSDLRect intersectionRect(SDL_Rect const\u0026 rhs) const; SDLRect unionRect(SDL_Rect const\u0026 rhs) const; double dist(SDL_Rect const\u0026 rhs) const; bool encloses(SDL_Rect const\u0026 rhs) const; double angle(SDL_Rect const\u0026 pos) const; bool empty() const; bool hasIntersection(SDL_Rect const\u0026 rhs) const; bool operator==(SDL_Rect const\u0026) const; }; Also for those unfamiliar with c++, structs are just classes with a default public access permission. I choose to make SDLRect a struct to preserve API compatibility with the SDL_Rect used extensively in SDL.\nNow before you run away screaming, “But SDL_Rect has a non-virtual destructor!”. Yes it does, but in this case, the subclass allocates no additional memory from that of the base class. So this code does not contain a memory leak.\nExceptions for Error Handling On of the other major design decisions that I made in my wrapper was to replace error code checking with exceptions. The basis of this effort was creating a class called SDLException.\nclass SDLException: public std::exception { public: SDLException(); virtual ~SDLException() noexcept; virtual const char * what() const noexcept=0; }; std::ostream \u0026 operator (std::ostream \u0026 out, const SDLException \u0026 e) { return out  e.what()  \" \"  SDL_GetError(); } Then for each type of failure in the SDLWrappers library, I created a subclass that printed a better error in context of what failed. Some would argue that using exceptions introduce additional overhead because the exception must be checked. However, if you create the equivalent code C style code that checks the error messages, I’ve found there isn’t much difference. In addition, you written 100s of lines less code by using exceptions.\nWell that wraps up this post. Happy programming!\n","wordCount":"564","inLanguage":"en","datePublished":"2017-05-08T05:30:14-05:00","dateModified":"2017-05-08T05:30:14-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Resource Acquisition is Initialization and SDL
</h1>
<div class=post-meta><span title="2017-05-08 05:30:14 -0500 -0500">May 8, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;564 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#raii-and-stdshared_ptr>RAII and <code>std::shared_ptr</code></a></li>
<li><a href=#sdlrect>SDLRect</a></li>
<li><a href=#exceptions-for-error-handling>Exceptions for Error Handling</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>Recently, I was working on a project for <a href=brianmalloy.com>2D Game Development</a> where I had to use SDL 2.0.
SDL 2.0 is a family of media libraries designed for writing cross platform games in C.
However it can be difficult to remember where various resources are allocated and deallocated.
Resource Acquisition is Initialization (RAII) is a common pattern in C++ programming that solves this problem.
So I wrote a series of wrappers for SDL 2.0 that use RAII and various other improvements.</p>
<h2 id=raii-and-stdshared_ptr>RAII and <code>std::shared_ptr</code><a hidden class=anchor aria-hidden=true href=#raii-and-stdshared_ptr>#</a></h2>
<p>One of the key reasons for the wrapper was to take advantage of RAII.
It is fairly common in SDL to have code like so (<em>constants provided for clarity</em>):</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=n>SDL_Init</span><span class=p>(</span><span class=n>SDL_INIT_VIDEO</span><span class=p>);</span>
<span class=n>SDL_Window</span><span class=o>*</span> <span class=n>window</span> <span class=o>=</span> <span class=n>SDL_CreateWindow</span><span class=p>(</span><span class=s>&#34;animation&#34;</span><span class=p>,</span> <span class=n>posX</span><span class=p>,</span> <span class=n>posY</span><span class=p>,</span> <span class=n>WIDTH</span><span class=p>,</span> <span class=n>HEIGHT</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
<span class=n>SDL_Renderer</span><span class=o>*</span> <span class=n>renderer</span> <span class=o>=</span> <span class=n>SDL_CreateRenderer</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=n>FIRST_WINDOW</span><span class=p>,</span> <span class=n>SDL_RENDERER_PRESENTVSYNC</span><span class=p>);</span>
<span class=cm>/* use pointers */</span>
<span class=n>SDL_DestroyRenderer</span><span class=p>(</span><span class=n>renderer</span><span class=p>);</span> <span class=c1>//order matters to prevent memory leaks
</span><span class=c1></span><span class=n>SDL_DestroyWindow</span><span class=p>(</span><span class=n>window</span><span class=p>);</span>
<span class=n>SDL_Quit</span><span class=p>();</span>
</code></pre></div><p>In my library it looks more like this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>auto</span> <span class=n>lib</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>SDLInit</span><span class=o>&gt;</span><span class=p>(</span><span class=n>SDL_INIT_VIDEO</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>window</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>SDLWindow</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;animation&#34;</span><span class=p>,</span> <span class=n>posX</span><span class=p>,</span> <span class=n>posY</span><span class=p>,</span> <span class=n>WIDTH</span><span class=p>,</span> <span class=n>HEIGHT</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>renderer</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>SDLRenderer</span><span class=o>&gt;</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=n>FIRST_WINDOW</span><span class=p>,</span> <span class=n>SDL_RENDERER_PRESENTVSYNC</span><span class=p>);</span> 
<span class=cm>/* use pointers */</span>
</code></pre></div><p>Here RAII and shared pointers in each of the classes ensure that each relevant class initialized correctly prior to use.
And also the reference counting of std::shared_ptr ensures that they are freed when no longer used in an order that prevents leaks.</p>
<h2 id=sdlrect>SDLRect<a hidden class=anchor aria-hidden=true href=#sdlrect>#</a></h2>
<p>One of the core data classes used in SDL is the <code>SDL_Rect</code>.
SDL provides several methods that all operate on <code>SDL_Rect</code>s.
Providing them as methods on the class greatly reduced duplication and simplified user code.
Additionally, <code>std::make_{shared,unique}</code> don&rsquo;t understand struct aggregate initialization.
So I grouped them the constructors and methods into a class and provided constructors</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>SDLRect</span><span class=o>:</span> <span class=k>public</span> <span class=n>SDL_Rect</span> <span class=p>{</span>
	<span class=n>SDLRect</span><span class=p>();</span>
	<span class=c1>//aggregate initialization and make_{shared,unique} don&#39;t mix; provide a constructor
</span><span class=c1></span>	<span class=n>SDLRect</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>h</span><span class=p>);</span>	
	<span class=n>SDLRect</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span><span class=p>);</span>	

	<span class=n>SDLRect</span> <span class=nf>intersectionRect</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
	<span class=n>SDLRect</span> <span class=nf>unionRect</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
	<span class=kt>double</span> <span class=nf>dist</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
	<span class=kt>bool</span> <span class=nf>encloses</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
	<span class=kt>double</span> <span class=nf>angle</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>pos</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>

	<span class=kt>bool</span> <span class=nf>empty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
	<span class=kt>bool</span> <span class=nf>hasIntersection</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
	<span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>SDL_Rect</span> <span class=k>const</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>Also for those unfamiliar with c++, structs are just classes with a default public access permission.
I choose to make SDLRect a struct to preserve API compatibility with the SDL_Rect used extensively in SDL.</p>
<p>Now before you run away screaming, &ldquo;But SDL_Rect has a non-virtual destructor!&rdquo;.
Yes it does, but in this case, the subclass allocates no additional memory from that of the base class.
So this code does not contain a memory leak.</p>
<h2 id=exceptions-for-error-handling>Exceptions for Error Handling<a hidden class=anchor aria-hidden=true href=#exceptions-for-error-handling>#</a></h2>
<p>On of the other major design decisions that I made in my wrapper was to replace error code checking with exceptions.
The basis of this effort was creating a class called SDLException.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>SDLException</span><span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span>
<span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
	<span class=n>SDLException</span><span class=p>();</span>
	<span class=k>virtual</span> <span class=o>~</span><span class=n>SDLException</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>
	<span class=k>virtual</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span> <span class=nf>what</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>std</span><span class=o>::</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span> <span class=o>&amp;</span> <span class=n>out</span><span class=p>,</span> <span class=k>const</span> <span class=n>SDLException</span> <span class=o>&amp;</span> <span class=n>e</span><span class=p>)</span>
<span class=p>{</span>
	<span class=k>return</span> <span class=n>out</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>SDL_GetError</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div><p>Then for each type of failure in the SDLWrappers library, I created a subclass that printed a better error in context of what failed.
Some would argue that using exceptions introduce additional overhead because the exception must be checked.
However, if you create the equivalent code C style code that checks the error messages, I&rsquo;ve found there isn&rsquo;t much difference.
In addition, you written 100s of lines less code by using exceptions.</p>
<p>Well that wraps up this post.
Happy programming!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/c++.html>C++</a></li>
<li><a href=http://robertu94.github.io/tags/programming.html>Programming</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2017/05/14/pluggable-authentication-with-pam.html>
<span class=title>« Prev</span>
<br>
<span>Pluggable Authentication With PAM</span>
</a>
<a class=next href=http://robertu94.github.io/2017/04/30/smart-pool.html>
<span class=title>Next »</span>
<br>
<span>Smart Pool</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>