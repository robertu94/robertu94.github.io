<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Smart Pool | systems++</title>
<meta name=keywords content="C++,Templates,programming">
<meta name=description content="Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.
The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2017/04/30/smart-pool.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.57f29198e62b3a8f07d37acaca0427bafb684416046b823f5a616bd858bb4af1.css integrity="sha256-V/KRmOYrOo8H03rKygQnuvtoRBYEa4I/WmFr2Fi7SvE=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Smart Pool">
<meta property="og:description" content="Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.
The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2017/04/30/smart-pool.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-04-30T09:58:14-05:00">
<meta property="article:modified_time" content="2017-04-30T09:58:14-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Smart Pool">
<meta name=twitter:description content="Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.
The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Smart Pool","item":"http://robertu94.github.io/2017/04/30/smart-pool.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Smart Pool","name":"Smart Pool","description":"Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.\nThe template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.","keywords":["C++","Templates","programming"],"articleBody":"Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development. However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool. In this article, I layout a class that I recently used to automatically manage memory from a pool.\nThe template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy. Let’s take these one at a time:\nAllocation Policy The allocation policy is responsible for allocating (and possibly deallocating) instances of the class. It also provides some meta-data about the state of the allocated objects.\nHere is an implementation of an allocation policy that use perfect forwarding to a constructor: Other policies might call a factory method.\n#include template class Value class ForwardingAllocation { public: ForwardingAllocation(): allocated(0U) {} template class... Args std::make_uniqueValue Allocate(Args\u0026\u0026... args) { allocated++; return std::make_uniqueValue(std::forwardArgs(args)...); } void Deallocate(std::unique_ptrValue\u0026\u0026) { //intensional no-op unique_ptrs \t//free their own memory when they fall of of scope \tallocated--; } unsigned int getAllocated() const { return allocated; } protected: ~ForwardingAllocation()=default; private: unsigned int allocated; }; Reset Policy The reset policy is responsible for resetting an object after it is allocated before it is returned This implementation uses perfect forwarding and in-place construction. Other policies might call a specific reset method.\ntemplate class Value class inPlaceReset { public: void Reset(Value* ptr, Args\u0026\u0026... args) { new (ptr) Value (std::forwardArgs(args)...); } protected: ~ForwardingAllocation()=default; } onEmpty Policy Now to put these policies together. The onEmpty policy is responsible for what the pool should do when it exhausts all avail bile pointers. Here is an implementation of the onEmpty policy that allocates a single new object when the pool is empty.\ntemplate class Value, class ListType, class AllocationPolicy = ForwardingAllocationValue, class ResetPolicy = inPlaceResetValue  class onEmptyLoad: public AllocationPolicy, public ResetPolicy { public: templateclass... Args void onEmpty(ListType\u0026 free_list, Args\u0026\u0026... args) { free_list.emplace_back( this-Allocate(std::forwardArgs(args)...) ); } }; Object Proxy The object proxy is where the magic happens. It is responsible for calling release on an object when it falls out of scope. I implemented it as a enclosed class in the pool.\nclass ProxyType { public: typedef std::shared_ptrObjectPool Pool; ProxyType(Ptr\u0026\u0026 ptr, Pool pool): ptr(std::move(ptr)), pool(pool) {} ProxyType(ProxyType\u0026\u0026 rhs)=default; ProxyType\u0026 operator=(ProxyType\u0026\u0026 rhs)=default; ProxyType(ProxyType\u0026)=delete; ~ProxyType() { //don't forget that moved from pointers also also destructed!! \tif(ptr.get() != nullptr) { pool-release(std::move(ptr)); } } //expose pointer a la std::{shared,unique}_ptr \tValue* operator-() const { return ptr.get(); } Value\u0026 operator*() const { return *ptr.get(); } Value* get() { return ptr.get(); } private: Ptr ptr; std::shared_ptrObjectPool pool; }; Putting it all together Now we simply need a class that puts all of this together. This class uses a free list but other implementations are possible.\ntemplate class Value, template class... class EmptyPolicy = onEmptyLoad, template class... class ListType = std::vector  class ObjectPool: public std::enable_shared_from_thisObjectPoolValue,EmptyPolicy,ListType, public EmptyPolicyValue, ListTypestd::unique_ptrValue { public: typedef std::unique_ptrValue Ptr; typedef ListTypePtr List; ObjectPool()=default; ObjectPool(List\u0026\u0026 free): EmptyPolicyValue, List(free.size()), free(std::move(free)) {} class ProxyType {...}; template class... Args ProxyType request(Args\u0026\u0026... args) { Ptr back; if(free.empty()) { this-onEmpty(free, std::forwardArgs(args)...); back = std::move(free.back()); free.pop_back(); } else { back = std::move(free.back()); this-Reset(back.get(), std::forwardArgs(args)...); free.pop_back(); } return ProxyType(std::move(back), this-shared_from_this()); } void release(Ptr\u0026\u0026 ptr) { if(ptr.get()==nullptr) { throw std::logic_error(\"ptr cannot be null\"); } free.emplace_back(std::move(ptr)); } size_t getFree() const { return free.size(); } size_t getInUse() const { return this-getAllocated() - free.size(); } private: ListTypestd::unique_ptrValue free; }; And that’s it; a pool that auto-magically manages memory using c++14. Happy programming!\n","wordCount":"581","inLanguage":"en","datePublished":"2017-04-30T09:58:14-05:00","dateModified":"2017-04-30T09:58:14-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2017/04/30/smart-pool.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Smart Pool
</h1>
<div class=post-meta><span title="2017-04-30 09:58:14 -0500 -0500">April 30, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;581 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#allocation-policy>Allocation Policy</a></li>
<li><a href=#reset-policy>Reset Policy</a></li>
<li><a href=#onempty-policy>onEmpty Policy</a></li>
<li><a href=#object-proxy>Object Proxy</a></li>
<li><a href=#putting-it-all-together>Putting it all together</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>Object Pools are a commonly used pattern used in operating systems, game, and high performance computing development.
However just as it can be easy to forget to return a pointer to memory, it can be easy to forget to return the memory to the pool.
In this article, I layout a class that I recently used to automatically manage memory from a pool.</p>
<p>The template pool class has 4 parts: an onEmpty policy, an allocation policy, a reset policy, and an object proxy.
Let&rsquo;s take these one at a time:</p>
<h2 id=allocation-policy>Allocation Policy<a hidden class=anchor aria-hidden=true href=#allocation-policy>#</a></h2>
<p>The allocation policy is responsible for allocating (and possibly deallocating) instances of the class.
It also provides some meta-data about the state of the allocated objects.</p>
<p>Here is an implementation of an allocation policy that use perfect forwarding to a constructor:
Other policies might call a factory method.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Value</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>ForwardingAllocation</span>
<span class=p>{</span>
	<span class=k>public</span><span class=o>:</span>

	<span class=n>ForwardingAllocation</span><span class=p>()</span><span class=o>:</span> <span class=n>allocated</span><span class=p>(</span><span class=mi>0U</span><span class=p>)</span> <span class=p>{}</span>

	<span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
	<span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>Allocate</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=n>allocated</span><span class=o>++</span><span class=p>;</span>
		<span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
	<span class=p>}</span>

	<span class=kt>void</span> <span class=nf>Deallocate</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;&amp;</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=c1>//intensional no-op unique_ptrs
</span><span class=c1></span>		<span class=c1>//free their own memory when they fall of of scope
</span><span class=c1></span>		<span class=n>allocated</span><span class=o>--</span><span class=p>;</span>
	<span class=p>}</span>

	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>getAllocated</span><span class=p>()</span> <span class=k>const</span>
	<span class=p>{</span>
		<span class=k>return</span> <span class=n>allocated</span><span class=p>;</span>
	<span class=p>}</span>

	<span class=k>protected</span><span class=o>:</span>
	<span class=o>~</span><span class=n>ForwardingAllocation</span><span class=p>()</span><span class=o>=</span><span class=k>default</span><span class=p>;</span>

	<span class=k>private</span><span class=o>:</span>
	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>allocated</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><h2 id=reset-policy>Reset Policy<a hidden class=anchor aria-hidden=true href=#reset-policy>#</a></h2>
<p>The reset policy is responsible for resetting an object after it is allocated before it is returned
This implementation uses perfect forwarding and in-place construction.
Other policies might call a specific reset method.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Value</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>inPlaceReset</span>
<span class=p>{</span>
	<span class=k>public</span><span class=o>:</span>
	<span class=kt>void</span> <span class=n>Reset</span><span class=p>(</span><span class=n>Value</span><span class=o>*</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=k>new</span> <span class=p>(</span><span class=n>ptr</span><span class=p>)</span> <span class=n>Value</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
	<span class=p>}</span>

	<span class=k>protected</span><span class=o>:</span>
	<span class=o>~</span><span class=n>ForwardingAllocation</span><span class=p>()</span><span class=o>=</span><span class=k>default</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h2 id=onempty-policy>onEmpty Policy<a hidden class=anchor aria-hidden=true href=#onempty-policy>#</a></h2>
<p>Now to put these policies together.
The onEmpty policy is responsible for what the pool should do when it exhausts all avail bile pointers.
Here is an implementation of the onEmpty policy that allocates a single new object when the pool is empty.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Value</span><span class=p>,</span>
		  <span class=k>class</span> <span class=nc>ListType</span><span class=p>,</span>
		  <span class=k>class</span> <span class=nc>AllocationPolicy</span> <span class=o>=</span> <span class=n>ForwardingAllocation</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=p>,</span>
		  <span class=k>class</span> <span class=nc>ResetPolicy</span> <span class=o>=</span> <span class=n>inPlaceReset</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span>
		  <span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>onEmptyLoad</span><span class=o>:</span> <span class=k>public</span> <span class=n>AllocationPolicy</span><span class=p>,</span> <span class=k>public</span> <span class=n>ResetPolicy</span>
<span class=p>{</span>
	<span class=k>public</span><span class=o>:</span>
	<span class=k>template</span><span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
	<span class=kt>void</span> <span class=n>onEmpty</span><span class=p>(</span><span class=n>ListType</span><span class=o>&amp;</span> <span class=n>free_list</span><span class=p>,</span> <span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=n>free_list</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span>
			<span class=k>this</span><span class=o>-&gt;</span><span class=n>Allocate</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...)</span>
			<span class=p>);</span>
	<span class=p>}</span>

<span class=p>};</span>

</code></pre></div><h2 id=object-proxy>Object Proxy<a hidden class=anchor aria-hidden=true href=#object-proxy>#</a></h2>
<p>The object proxy is where the magic happens.
It is responsible for calling release on an object when it falls out of scope.
I implemented it as a enclosed class in the pool.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>ProxyType</span>
<span class=p>{</span>
	<span class=k>public</span><span class=o>:</span>
	<span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>ObjectPool</span><span class=o>&gt;</span> <span class=n>Pool</span><span class=p>;</span>

	<span class=n>ProxyType</span><span class=p>(</span><span class=n>Ptr</span><span class=o>&amp;&amp;</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>Pool</span> <span class=n>pool</span><span class=p>)</span><span class=o>:</span> <span class=n>ptr</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>ptr</span><span class=p>)),</span> <span class=n>pool</span><span class=p>(</span><span class=n>pool</span><span class=p>)</span> <span class=p>{}</span>
	<span class=n>ProxyType</span><span class=p>(</span><span class=n>ProxyType</span><span class=o>&amp;&amp;</span> <span class=n>rhs</span><span class=p>)</span><span class=o>=</span><span class=k>default</span><span class=p>;</span>
	<span class=n>ProxyType</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>ProxyType</span><span class=o>&amp;&amp;</span> <span class=n>rhs</span><span class=p>)</span><span class=o>=</span><span class=k>default</span><span class=p>;</span>

	<span class=n>ProxyType</span><span class=p>(</span><span class=n>ProxyType</span><span class=o>&amp;</span><span class=p>)</span><span class=o>=</span><span class=k>delete</span><span class=p>;</span>

	<span class=o>~</span><span class=n>ProxyType</span><span class=p>()</span>
	<span class=p>{</span>
		<span class=c1>//don&#39;t forget that moved from pointers also also destructed!!
</span><span class=c1></span>		<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>.</span><span class=n>get</span><span class=p>()</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=n>pool</span><span class=o>-&gt;</span><span class=n>release</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>ptr</span><span class=p>));</span> 
		<span class=p>}</span>
	<span class=p>}</span>


	<span class=c1>//expose pointer a la std::{shared,unique}_ptr
</span><span class=c1></span>	<span class=n>Value</span><span class=o>*</span> <span class=k>operator</span><span class=o>-&gt;</span><span class=p>()</span> <span class=k>const</span> 
	<span class=p>{</span>
		<span class=k>return</span> <span class=n>ptr</span><span class=p>.</span><span class=n>get</span><span class=p>();</span> 
	<span class=p>}</span>

	<span class=n>Value</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>*</span><span class=p>()</span> <span class=k>const</span> 
	<span class=p>{</span>
		<span class=k>return</span> <span class=o>*</span><span class=n>ptr</span><span class=p>.</span><span class=n>get</span><span class=p>();</span> 
	<span class=p>}</span>

	<span class=n>Value</span><span class=o>*</span> <span class=nf>get</span><span class=p>()</span>
	<span class=p>{</span>
		<span class=k>return</span> <span class=n>ptr</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
	<span class=p>}</span>

	<span class=k>private</span><span class=o>:</span>
	<span class=n>Ptr</span> <span class=n>ptr</span><span class=p>;</span>
	<span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>ObjectPool</span><span class=o>&gt;</span> <span class=n>pool</span><span class=p>;</span>
<span class=p>};</span>

</code></pre></div><h2 id=putting-it-all-together>Putting it all together<a hidden class=anchor aria-hidden=true href=#putting-it-all-together>#</a></h2>
<p>Now we simply need a class that puts all of this together.
This class uses a free list but other implementations are possible.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>Value</span><span class=p>,</span>
		 <span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span><span class=err>...</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>EmptyPolicy</span> <span class=o>=</span> <span class=n>onEmptyLoad</span><span class=p>,</span>
		 <span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span><span class=err>...</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>ListType</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span>
		 <span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>ObjectPool</span><span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>enable_shared_from_this</span><span class=o>&lt;</span><span class=n>ObjectPool</span><span class=o>&lt;</span><span class=n>Value</span><span class=p>,</span><span class=n>EmptyPolicy</span><span class=p>,</span><span class=n>ListType</span><span class=o>&gt;&gt;</span><span class=p>,</span>
				  <span class=k>public</span> <span class=n>EmptyPolicy</span><span class=o>&lt;</span><span class=n>Value</span><span class=p>,</span> <span class=n>ListType</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&gt;&gt;</span>
<span class=p>{</span>
	<span class=k>public</span><span class=o>:</span>
	<span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>Ptr</span><span class=p>;</span>
	<span class=k>typedef</span> <span class=n>ListType</span><span class=o>&lt;</span><span class=n>Ptr</span><span class=o>&gt;</span> <span class=n>List</span><span class=p>;</span>

	<span class=n>ObjectPool</span><span class=p>()</span><span class=o>=</span><span class=k>default</span><span class=p>;</span>
	<span class=n>ObjectPool</span><span class=p>(</span><span class=n>List</span><span class=o>&amp;&amp;</span> <span class=n>free</span><span class=p>)</span><span class=o>:</span> <span class=n>EmptyPolicy</span><span class=o>&lt;</span><span class=n>Value</span><span class=p>,</span> <span class=n>List</span><span class=o>&gt;</span><span class=p>(</span><span class=n>free</span><span class=p>.</span><span class=n>size</span><span class=p>()),</span> <span class=n>free</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>free</span><span class=p>))</span> <span class=p>{}</span>

	<span class=k>class</span> <span class=nc>ProxyType</span> <span class=p>{...};</span>

	<span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
	<span class=n>ProxyType</span> <span class=n>request</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=n>Ptr</span> <span class=n>back</span><span class=p>;</span>
		<span class=k>if</span><span class=p>(</span><span class=n>free</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
		<span class=p>{</span>
			<span class=k>this</span><span class=o>-&gt;</span><span class=n>onEmpty</span><span class=p>(</span><span class=n>free</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
			<span class=n>back</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>free</span><span class=p>.</span><span class=n>back</span><span class=p>());</span>
			<span class=n>free</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
			<span class=n>back</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>free</span><span class=p>.</span><span class=n>back</span><span class=p>());</span>
			<span class=k>this</span><span class=o>-&gt;</span><span class=n>Reset</span><span class=p>(</span><span class=n>back</span><span class=p>.</span><span class=n>get</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
			<span class=n>free</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=nf>ProxyType</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>back</span><span class=p>),</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>shared_from_this</span><span class=p>());</span>

	<span class=p>}</span>

	<span class=kt>void</span> <span class=nf>release</span><span class=p>(</span><span class=n>Ptr</span><span class=o>&amp;&amp;</span> <span class=n>ptr</span><span class=p>)</span>
	<span class=p>{</span>
		<span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>.</span><span class=n>get</span><span class=p>()</span><span class=o>==</span><span class=k>nullptr</span><span class=p>)</span>
		<span class=p>{</span>
			<span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>logic_error</span><span class=p>(</span><span class=s>&#34;ptr cannot be null&#34;</span><span class=p>);</span>
		<span class=p>}</span>
		<span class=n>free</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>ptr</span><span class=p>));</span>
	<span class=p>}</span>

	<span class=n>size_t</span> <span class=nf>getFree</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>free</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=p>}</span>
	<span class=n>size_t</span> <span class=nf>getInUse</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>getAllocated</span><span class=p>()</span> <span class=o>-</span> <span class=n>free</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=p>}</span>

	<span class=k>private</span><span class=o>:</span>
	<span class=n>ListType</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&gt;</span> <span class=n>free</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>And that&rsquo;s it; a pool that auto-magically manages memory using c++14.
Happy programming!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/c++.html>C++</a></li>
<li><a href=http://robertu94.github.io/tags/templates.html>Templates</a></li>
<li><a href=http://robertu94.github.io/tags/programming.html>Programming</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2017/05/08/resource-acquisition-is-initialization-and-sdl.html>
<span class=title>« Prev</span>
<br>
<span>Resource Acquisition is Initialization and SDL</span>
</a>
<a class=next href=http://robertu94.github.io/2017/02/23/surprisingly-functional.html>
<span class=title>Next »</span>
<br>
<span>Surprisingly Functional</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2025 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>