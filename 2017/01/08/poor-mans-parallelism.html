<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Poor Man's Parallelism | systems++</title>
<meta name=keywords content="shell,parallel,programming">
<meta name=description content="I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can&rsquo;t or don&rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.
You can do this via Unix/shell job control:
cmd=&#34;systemctl enable --now docker.service&#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh & $host $cmd done However from experience, this can be very error prone.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.57f29198e62b3a8f07d37acaca0427bafb684416046b823f5a616bd858bb4af1.css integrity="sha256-V/KRmOYrOo8H03rKygQnuvtoRBYEa4I/WmFr2Fi7SvE=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Poor Man's Parallelism">
<meta property="og:description" content="I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can&rsquo;t or don&rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.
You can do this via Unix/shell job control:
cmd=&#34;systemctl enable --now docker.service&#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh & $host $cmd done However from experience, this can be very error prone.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-01-08T10:58:14-05:00">
<meta property="article:modified_time" content="2017-01-08T10:58:14-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Poor Man's Parallelism">
<meta name=twitter:description content="I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can&rsquo;t or don&rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.
You can do this via Unix/shell job control:
cmd=&#34;systemctl enable --now docker.service&#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh & $host $cmd done However from experience, this can be very error prone.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Poor Man's Parallelism","item":"http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Poor Man's Parallelism","name":"Poor Man\u0027s Parallelism","description":"I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can\u0026rsquo;t or don\u0026rsquo;t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.\nYou can do this via Unix/shell job control:\ncmd=\u0026#34;systemctl enable --now docker.service\u0026#34; hosts=(host{1..4}) for host in ${hosts[@]} do ssh \u0026amp; $host $cmd done However from experience, this can be very error prone.","keywords":["shell","parallel","programming"],"articleBody":"I really like orchestration tools such as Ansible or SaltStack. They can make running tasks on a group of machines a breeze. But sometimes you can’t or don’t want to install these tools on a machine. In cases like these, it is helpful to know how to parallelize some tasks in the shell.\nYou can do this via Unix/shell job control:\ncmd=\"systemctl enable --now docker.service\" hosts=(host{1..4}) for host in ${hosts[@]} do ssh \u0026 $host $cmd done However from experience, this can be very error prone. For example, The placement of the \u0026 is important so as to background the ssh command and not the command on the remote machine. Additionally, what if you had a lot of hosts and you didn’t want to run all of them at once. Instead, you want to utilize a bounded pool of processes.\nThere are a few ways of doing this: most ways are messy or or fairly non-portable. On systems with the util-linux installed you might use flock or lockfile, but then you have essentially to implement semaphores using mutex locks and shell arithmetic. If you don’t have util-linux you can accomplish the same thing taking advantage of the atomicity of mkdir on most (but not all) file systems:\nHowever rather than doing this, take a look at the fairly pervasive xargs command. According the manpage, xargs “builds and executes command lines from standard input.” It has an option -P  that takes determines how many commands to run in parallel. With this, it is just a matter of formatting commands in a way that xargs understands.\ncmd=\"systemctl enable --now docker.service\" hosts=(host{1..4}) numprocs=8 echo ${hosts[@]} | xargs -P $numprocs -d\" \" -I{} -n 1 ssh {} $cmd Admittedly this looks a bit cryptic. It helps to know that -d is setting the delimiter from the default newline to space, -n  sets the number of arguments to pass to each command, and -I  is setting the replacement string for xargs so that ssh {} $cmd becomes ssh host1 $cmd for the first command and so on. The xargs command also accepts an input file option (-a ) where we could put each host on a newline to simplify the call.\nNow we can easily create process pools in a mostly portable fashion in shell scripts. There are lots of useful things you could do with this, but here are two recipes that I came up with:\n#copy a file to many nodes function pcopy(){ filename=$1 dest=$2 shift 2 echo $* | xargs -d\" \" -P 8 -I{} -n 1 scp $filename {}:$dest } pcopy somefile.txt host{1..8} #retrieve files from many nodes function pget(){ filename=$1 shift echo $* | xargs -d\" \" -P 8 -I{} -n 1 scp {}:$filename $(basename $filename).{} } Happy shell scripting!\n","wordCount":"462","inLanguage":"en","datePublished":"2017-01-08T10:58:14-05:00","dateModified":"2017-01-08T10:58:14-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2017/01/08/poor-mans-parallelism.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Poor Man's Parallelism
</h1>
<div class=post-meta><span title="2017-01-08 10:58:14 -0500 -0500">January 8, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Robert Underwood
</div>
</header>
<div class=post-content><p>I really like orchestration tools such as <a href=https://docs.ansible.com>Ansible</a> or <a href=https://docs.saltstack.com>SaltStack</a>.
They can make running tasks on a group of machines a breeze.
But sometimes you can&rsquo;t or don&rsquo;t want to install these tools on a machine.
In cases like these, it is helpful to know how to parallelize some tasks in the shell.</p>
<p>You can do this via Unix/shell job control:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nv>cmd</span><span class=o>=</span><span class=s2>&#34;systemctl enable --now docker.service&#34;</span>
<span class=nv>hosts</span><span class=o>=(</span>host<span class=o>{</span>1..4<span class=o>})</span>

<span class=k>for</span> host in <span class=si>${</span><span class=nv>hosts</span><span class=p>[@]</span><span class=si>}</span>
<span class=k>do</span>
	ssh <span class=p>&amp;</span> <span class=nv>$host</span> <span class=nv>$cmd</span>
<span class=k>done</span>
</code></pre></div><p>However from experience, this can be very error prone.
For example, The placement of the <code>&</code> is important so as to background the ssh command and not the command on the remote machine.
Additionally, what if you had a lot of hosts and you didn&rsquo;t want to run all of them at once.
Instead, you want to utilize a bounded pool of processes.</p>
<p>There are a few ways of doing this: most ways are messy or or fairly non-portable.
On systems with the util-linux installed you might use <code>flock</code> or <code>lockfile</code>, but then you have essentially to implement semaphores using mutex locks and shell arithmetic.
If you don&rsquo;t have util-linux you can accomplish the same thing taking advantage of the atomicity of <code>mkdir</code> <a href=http://mywiki.wooledge.org/BashFAQ/045>on most (but not all) file systems</a>:</p>
<p>However rather than doing this, take a look at the fairly pervasive <code>xargs</code> command.
According the manpage, <a href=https://linux.die.net/man/1/xargs><code>xargs</code></a> &ldquo;builds and executes command lines from standard input.&rdquo;
It has an option <code>-P &lt;NUM_PROCS></code> that takes determines how many commands to run in parallel.
With this, it is just a matter of formatting commands in a way that <code>xargs</code> understands.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nv>cmd</span><span class=o>=</span><span class=s2>&#34;systemctl enable --now docker.service&#34;</span>
<span class=nv>hosts</span><span class=o>=(</span>host<span class=o>{</span>1..4<span class=o>})</span>
<span class=nv>numprocs</span><span class=o>=</span><span class=m>8</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>hosts</span><span class=p>[@]</span><span class=si>}</span> <span class=p>|</span> xargs -P <span class=nv>$numprocs</span> -d<span class=s2>&#34; &#34;</span> -I<span class=o>{}</span> -n <span class=m>1</span> ssh <span class=o>{}</span> <span class=nv>$cmd</span>
</code></pre></div><p>Admittedly this looks a bit cryptic.
It helps to know that <code>-d</code> is setting the delimiter from the default newline to space,
<code>-n &lt;NUM_ARGS></code> sets the number of arguments to pass to each command, and
<code>-I &lt;REPLACE_STR></code> is setting the replacement string for <code>xargs</code> so that <code>ssh {} $cmd</code> becomes <code>ssh host1 $cmd</code> for the first command and so on.
The <code>xargs</code> command also accepts an input file option (<code>-a &lt;file></code>) where we could put each host on a newline to simplify the call.</p>
<p>Now we can easily create process pools in a mostly portable fashion in shell scripts.
There are lots of useful things you could do with this, but here are two recipes that I came up with:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1>#copy a file to many nodes</span>
<span class=k>function</span> pcopy<span class=o>(){</span>
<span class=nv>filename</span><span class=o>=</span><span class=nv>$1</span>
<span class=nv>dest</span><span class=o>=</span><span class=nv>$2</span>
<span class=nb>shift</span> <span class=m>2</span>
<span class=nb>echo</span> <span class=nv>$*</span> <span class=p>|</span> xargs -d<span class=s2>&#34; &#34;</span> -P <span class=m>8</span> -I<span class=o>{}</span> -n <span class=m>1</span> scp  <span class=nv>$filename</span> <span class=o>{}</span>:<span class=nv>$dest</span>
<span class=o>}</span>
pcopy somefile.txt host<span class=o>{</span>1..8<span class=o>}</span>

<span class=c1>#retrieve files from many nodes</span>
<span class=k>function</span> pget<span class=o>(){</span>
<span class=nv>filename</span><span class=o>=</span><span class=nv>$1</span>
<span class=nb>shift</span>
<span class=nb>echo</span> <span class=nv>$*</span> <span class=p>|</span> xargs -d<span class=s2>&#34; &#34;</span> -P <span class=m>8</span> -I<span class=o>{}</span> -n <span class=m>1</span> scp <span class=o>{}</span>:<span class=nv>$filename</span> <span class=k>$(</span>basename <span class=nv>$filename</span><span class=k>)</span>.<span class=o>{}</span>
<span class=o>}</span>
</code></pre></div><p>Happy shell scripting!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/shell.html>shell</a></li>
<li><a href=http://robertu94.github.io/tags/parallel.html>parallel</a></li>
<li><a href=http://robertu94.github.io/tags/programming.html>Programming</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2017/01/15/interpreters-made-easy.html>
<span class=title>« Prev</span>
<br>
<span>Interpreters Made Easy</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2024 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>