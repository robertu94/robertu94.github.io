<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Design of A Matrix loading Library | systems++</title>
<meta name=keywords content="matrix,graph,programming">
<meta name=description content="Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.
Design Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.57f29198e62b3a8f07d37acaca0427bafb684416046b823f5a616bd858bb4af1.css integrity="sha256-V/KRmOYrOo8H03rKygQnuvtoRBYEa4I/WmFr2Fi7SvE=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Design of A Matrix loading Library">
<meta property="og:description" content="Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.
Design Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-09-23T07:00:00-05:00">
<meta property="article:modified_time" content="2017-09-23T07:00:00-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Design of A Matrix loading Library">
<meta name=twitter:description content="Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.
Design Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Design of A Matrix loading Library","item":"http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Design of A Matrix loading Library","name":"Design of A Matrix loading Library","description":"Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.\nDesign Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:","keywords":["matrix","graph","programming"],"articleBody":"Ever notice that every matrix and graph library seems to have a different interface for constructing matrices? Also notice that each only only supports some subset of common matrix formats? With a little help from the Adapter and Builder design patterns we can actually solve this problem.\nDesign Overview In this design, we have 2 main actors: Parser andBuilder as well as their implementations ParserImpl and BuilderImpl. It allows us to write code like this in c++:\n#include #include #include  int main(int argc, char *argv[]) { using namespace matrixloader; typedef BoostGraphBuilderdouble bgb; std::ifstream matrix_file{argv[1]}; auto builder = std::make_uniquebgb(); auto parser = std::make_uniqueMatrixMarketParserbgb(std::move(builder)); auto matrix = parser.load(matrix_file); return 0; } I have chosen to mock up the interface in C++ because of its expressiveness with generic types. I have also created an implementation of the library in python and as a header only library in C++.\nBuilder Interface The Builder class is an implementation of the Builder pattern so that Parser classes have a common interface to use to construct matrices and graphs. The Builder class is an abstract generic class that provides three methods: add_edge, reserve and build, and require 2 types: Value and Matrix.\nThe Value type represents the type of a particular edge weight. The Matrix type represents the graph or matrix of Values. Often these types vary jointly, but are, in fact, different. For example double is not viable where a vector is. Additionally it is not always possible to extract the subtype from the collection like it is with vector::value_type. Sure, you could probably do some SFINAE or reflection nonsense to make a reasonable guess for most cases, but this is not always possible.\nreserve reserve is used to provide hints about the size of the resulting matrix and takes 3 parameters rows, columns, and nonzeros.\nAn earlier version of this interface did not provide the nonzeros argument. It was added because the earlier interface was not suitable for providing accurate hints for sparse matrices which often expect the number of nonzero entries for efficient construction.\nNotice, the use of the word hints. The implementation is not required to honor the arguments to this function if not practical. Take for example the Graph class form python’s networkx package, it provides no means to indicate how many nodes or edges – let alone nonzeros – to expect. Therefore its implementation of Builder has a no-op for this method.\nadd_edge add_edge is used to indicate a value of an edge. This function unconditionally requires an edge value because in the event that weights are not meaningful, the parser implantation can simply pass 1 to create an adjacency matrix.\nbuild build constructs or returns the final matrix. Some libraries like networkx do not provide batch more efficient batch construction methods, whereas libraries like scipy.sparse are not efficient without them. Therefore the implementation could choose to construct the graph/matrix representation when the constructor is called, or wait until build is called to finally construct the matrix. For this reason, calling build more than one time may cause undefined behavior.\nBuilderImpl The BuilderImpl is simply an Adapter to the specific matrix interface of the matrix construction methods. It exists so that we have a common interface for matrix construction.\nParser Design Parser is an abstract generic class that provides one method Builder::Matrix parse(std::istream\u0026). It is generic on only one type Builder which is expected to conform the Interface Builder. For languages that do not allow for type alias to be members of a class (IE Java), It should be generic on two types Builder and Matrix where Matrix is the Matrix type passed to Builder.\nThe reason for taking an std::istream over something more common like a std::string or a const char * is threefold:\n There is a class called std::istringstream that provides an adapter from these types to std::istream The most common use case for this use case is loading from a file. For several reasons we may not read the whole file and thus do not need to load it all into memory.  A previous version of the this interface accepted std::string by line and return void (requiring a call to build on Builder), but this was changed for three reasons:\n It avoids excess code on the common case by wrapping it. Some matrix file formats are not newline delimited making an awkward interface to implement for binary files. It reduces the number of objects that need to be passed around.  ParserImpl ParserImpl simply implements the Parser interface for the format desired such as MatrixMarket or EdgeList in terms of contained the Builder interface by reading the file.\nConclusion While by no means is this a definitive interface for matrix construction, I think it serves a good start. Well until next time happy coding!\n","wordCount":"796","inLanguage":"en","datePublished":"2017-09-23T07:00:00-05:00","dateModified":"2017-09-23T07:00:00-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2017/09/23/design-of-a-matrix-loading-library.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Design of A Matrix loading Library
</h1>
<div class=post-meta><span title="2017-09-23 07:00:00 -0500 -0500">September 23, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;796 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#design-overview>Design Overview</a>
<ul>
<li><a href=#builder-interface>Builder Interface</a>
<ul>
<li><a href=#reserve>reserve</a></li>
<li><a href=#add_edge>add_edge</a></li>
<li><a href=#build>build</a></li>
<li><a href=#builderimpl>BuilderImpl</a></li>
</ul>
</li>
<li><a href=#parser-design>Parser Design</a>
<ul>
<li><a href=#parserimpl>ParserImpl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href=#conclusion>Conclusion</a></li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>Ever notice that every matrix and graph library seems to have a different interface for constructing matrices?
Also notice that each only only supports some subset of common matrix formats?
With a little help from the Adapter and Builder design patterns we can actually solve this problem.</p>
<h1 id=design-overview>Design Overview<a hidden class=anchor aria-hidden=true href=#design-overview>#</a></h1>
<p><img loading=lazy src=%7b%7bsite.url%7d%7d/static/posts/matrixbuilder/overview.png alt=overview-diagram>
</p>
<p>In this design, we have 2 main actors: <code>Parser</code> and<code>Builder</code> as well as their implementations <code>ParserImpl</code> and <code>BuilderImpl</code>.
It allows us to write code like this in c++:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;fstream&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;matrixloader/parser/matrixmarket.hpp&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;matrixloader/builder/boostgraph.hpp&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
<span class=p>{</span>
	<span class=k>using</span> <span class=k>namespace</span> <span class=n>matrixloader</span><span class=p>;</span>
	<span class=k>typedef</span> <span class=n>BoostGraphBuilder</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>bgb</span><span class=p>;</span>
	<span class=n>std</span><span class=o>::</span><span class=n>ifstream</span> <span class=n>matrix_file</span><span class=p>{</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]};</span>
	<span class=k>auto</span> <span class=n>builder</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>bgb</span><span class=o>&gt;</span><span class=p>();</span>
	<span class=k>auto</span> <span class=n>parser</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MatrixMarketParser</span><span class=o>&lt;</span><span class=n>bgb</span><span class=o>&gt;&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>builder</span><span class=p>));</span>
	<span class=k>auto</span> <span class=n>matrix</span> <span class=o>=</span> <span class=n>parser</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>matrix_file</span><span class=p>);</span>
	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>I have chosen to mock up the interface in <code>C++</code> because of its expressiveness with generic types.
I have also created an implementation of the library in <code>python</code> and as a header only library in <code>C++</code>.</p>
<h2 id=builder-interface>Builder Interface<a hidden class=anchor aria-hidden=true href=#builder-interface>#</a></h2>
<p>The <code>Builder</code> class is an implementation of the Builder pattern so that <code>Parser</code> classes have a common interface to use to construct matrices and graphs. The <code>Builder</code> class is an abstract generic class that provides three methods: <code>add_edge</code>, <code>reserve</code> and <code>build</code>, and require 2 types: <code>Value</code> and <code>Matrix</code>.</p>
<p>The <code>Value</code> type represents the type of a particular edge weight. The <code>Matrix</code> type represents the graph or matrix of <code>Values</code>. Often these types vary jointly, but are, in fact, different. For example <code>double</code> is not viable where a <code>vector&lt;dobule></code> is. Additionally it is not always possible to extract the subtype from the collection like it is with <code>vector&lt;int>::value_type</code>. Sure, you could probably do some <code>SFINAE</code> or reflection nonsense to make a reasonable guess for most cases, but this is not always possible.</p>
<h3 id=reserve>reserve<a hidden class=anchor aria-hidden=true href=#reserve>#</a></h3>
<p><code>reserve</code> is used to provide hints about the size of the resulting matrix and takes 3 parameters <code>rows</code>, <code>columns</code>, and <code>nonzeros</code>.</p>
<p>An earlier version of this interface did not provide the nonzeros argument. It was added because the earlier interface was not suitable for providing accurate hints for sparse matrices which often expect the number of nonzero entries for efficient construction.</p>
<p>Notice, the use of the word <code>hints</code>. The implementation is not required to honor the arguments to this function if not practical. Take for example the <code>Graph</code> class form <code>python</code>&rsquo;s networkx package, it provides no means to indicate how many nodes or edges &ndash; let alone nonzeros &ndash; to expect. Therefore its implementation of Builder has a no-op for this method.</p>
<h3 id=add_edge>add_edge<a hidden class=anchor aria-hidden=true href=#add_edge>#</a></h3>
<p><code>add_edge</code> is used to indicate a value of an edge. This function unconditionally requires an edge value because in the event that weights are not meaningful, the parser implantation can simply pass <code>1</code> to create an adjacency matrix.</p>
<h3 id=build>build<a hidden class=anchor aria-hidden=true href=#build>#</a></h3>
<p><code>build</code> constructs or returns the final matrix. Some libraries like <code>networkx</code> do not provide batch more efficient batch construction methods, whereas libraries like <code>scipy.sparse</code> are not efficient without them. Therefore the implementation could choose to construct the graph/matrix representation when the constructor is called, or wait until <code>build</code> is called to finally construct the matrix. For this reason, calling <code>build</code> more than one time may cause undefined behavior.</p>
<h3 id=builderimpl>BuilderImpl<a hidden class=anchor aria-hidden=true href=#builderimpl>#</a></h3>
<p>The BuilderImpl is simply an Adapter to the specific matrix interface of the matrix construction methods. It exists so that we have a common interface for matrix construction.</p>
<h2 id=parser-design>Parser Design<a hidden class=anchor aria-hidden=true href=#parser-design>#</a></h2>
<p><code>Parser</code> is an abstract generic class that provides one method <code>Builder::Matrix parse(std::istream&)</code>. It is generic on only one type Builder which is expected to conform the Interface Builder. For languages that do not allow for type alias to be members of a class (IE Java), It should be generic on two types <code>Builder</code> and <code>Matrix</code> where <code>Matrix</code> is the <code>Matrix</code> type passed to Builder.</p>
<p>The reason for taking an <code>std::istream</code> over something more common like a <code>std::string</code> or a <code>const char *</code> is threefold:</p>
<ol>
<li>There is a class called <code>std::istringstream</code> that provides an adapter from these types to <code>std::istream</code></li>
<li>The most common use case for this use case is loading from a file.</li>
<li>For several reasons we may not read the whole file and thus do not need to load it all into memory.</li>
</ol>
<p>A previous version of the this interface accepted <code>std::string</code> by line and return void (requiring a call to build on Builder), but this was changed for three reasons:</p>
<ol>
<li>It avoids excess code on the common case by wrapping it.</li>
<li>Some matrix file formats are not newline delimited making an awkward interface to implement for binary files.</li>
<li>It reduces the number of objects that need to be passed around.</li>
</ol>
<h3 id=parserimpl>ParserImpl<a hidden class=anchor aria-hidden=true href=#parserimpl>#</a></h3>
<p><code>ParserImpl</code> simply implements the <code>Parser</code> interface for the format desired such as MatrixMarket or EdgeList in terms of contained the <code>Builder</code> interface by reading the file.</p>
<h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1>
<p>While by no means is this a definitive interface for matrix construction, I think it serves a good start. Well until next time happy coding!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/matrix.html>matrix</a></li>
<li><a href=http://robertu94.github.io/tags/graph.html>graph</a></li>
<li><a href=http://robertu94.github.io/tags/programming.html>Programming</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2017/12/10/life-with-libtooling.html>
<span class=title>« Prev</span>
<br>
<span>Life with Libtooling</span>
</a>
<a class=next href=http://robertu94.github.io/2017/05/23/qt-is-for-more-than-just-guis.html>
<span class=title>Next »</span>
<br>
<span>Qt is for more than just GUIs</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2024 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>