<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Configuration Management: the Battle Royal | systems++</title>
<meta name=keywords content="Ansible,Chef,Puppet,SaltStack">
<meta name=description content="So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I&rsquo;ll highlight the strengths of these systems and their respective weaknesses.
Every evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.
 Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation  Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Configuration Management: the Battle Royal">
<meta property="og:description" content="So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I&rsquo;ll highlight the strengths of these systems and their respective weaknesses.
Every evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.
 Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation  Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-07-31T09:00:00-05:00">
<meta property="article:modified_time" content="2018-07-31T09:00:00-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Configuration Management: the Battle Royal">
<meta name=twitter:description content="So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I&rsquo;ll highlight the strengths of these systems and their respective weaknesses.
Every evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.
 Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation  Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Configuration Management: the Battle Royal","item":"http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Configuration Management: the Battle Royal","name":"Configuration Management: the Battle Royal","description":"So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I\u0026rsquo;ll highlight the strengths of these systems and their respective weaknesses.\nEvery evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.\n Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation  Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.","keywords":["Ansible","Chef","Puppet","SaltStack"],"articleBody":"So, you need a Configuration Management System, so which one do you choose? This post is the second in a three part series on configuration management. In this post, I’ll highlight the strengths of these systems and their respective weaknesses.\nEvery evaluation needs to have criteria to be useful. Here are some of the criteria that I have had when I thought about this question.\n Ease of Use Time to Setup Difficulty of Adding More Machines Difficulty of Creating New Modules Difficulty of Supporting More Configurations Quality of Documentation  Puppet Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments. In my opinion, it is the most different out of the four open source configuration management systems. It uses a completely declarative language that requires some getting used to. It managements ordering by the use of explicit ordering statements. Additionally each resource, may only be declared once. The problem this proposes is with inter-module dependency management. Puppet solves this problem with the use of virtual resources. Virtual resources then can be “realized” multiple times, but only one instance of the resource will be created. For those unfamiliar with this concept, it takes a while to get used to. Using the completely graph oriented execution policy allows Puppet to create highly parallel and fast execution graphs to apply the specified policy.\nPuppet uses a client-server architecture with multiple components. Each managed box runs a copy of the agent which is intended to run in concert with a master. The agent registers with the Puppet master which then applies the policy with according to a specified regularity. The other key components of Puppet are , facter, hiera, and puppetdb. facter is responsible for gather “facts” about the nodes such as the hostname, number of cpus, or the ip-address. hiera is responsible for providing hierarchical information to the nodes such as what group(s) a node belongs to and group based variables. puppetdb acts as a “fact cache” and repository of events that happen on the nodes.\nAdding a new box generally requires the agent requesting a master to sign a certificate request. Without the signing their request, the agents will not be delivered a configuration to deploy. This can provides a high level of security, but is admit auntly harder to configure than some of the other solutions.\nSupporting more configurations is somewhat easy to do using Puppet. There are two common ways this is accomplished. The first is using so-called “parameter modules” which are small Puppet files that use conditional expressions to specify an appropriate values based on the facts on a system. The other method is using hiera to specify different values. The hiera should be thought of providing different values based on role, where as “parameter modules” should be thought of providing for variations on the same role. However, the exact point to draw the line between the two is not always clear which in my opinion cases some confusion.\nCreating new resources types can be done with ruby. Puppet types are simply ruby classes that provide certain members and methods. For those who know ruby, extending Puppet is a breeze.\nPuppets documentation is perhaps its worst facet. It is at times impenetrable at others hopeless vague and unhelpful. Its gotten better since when I first used it over four years ago, but it is still the worst of the four by far.\nAnsible Ansible is another early open source configuration management system. Unlike Puppet, Ansible uses “playbooks” which are linear lists of instructions that generally execute from top to bottom. While this makes it easier to use and reason about, it can make it slower to execute. There is additionally no restraint on having resources managed in only one location. This creates a greater possibility of error if there are conflicting requirements, but makes it easier to work with common resources. Additionally recently, it was acquired by Red Hat making it likely to stick around and be well supported for years to come.\nInstead of requiring its own agent infrastructure, Ansible reuses ssh and python making it fairly easy to adopt since most systems already have these installed. The ansible agent is temporarily loaded on to the system when the master connects. This obviates the need to maintain or update the agent since it is loaded fresh each time. This temporary agent does all required fact finding and receives the appropriate set of host and group facts from the master.\nAdding a new box is a breeze with Ansible. Simply use ssh-copy-id to copy the master’s ssh key on the node, and ensure that a somewhat recent venison of python is installed. It may be one of the easiest system to get started.\nSupporting new configurations with Ansible is easy. Ansible has a clearly defined variable precedence hierarchy. Simply define variables with the appropriate level of precedence. There is one exception to this: Windows. Windows systems often require different modules that make it more difficulty to integrate them using the same role files.\nCreating new ansible modules (what Puppet calls a resource) can be done with python. They are simply scripts that accept from standard input and return JSON to standard output as text. Additionally, Ansible provides a large number of helper methods in python to make it easy to develop new modules. For windows systems, they provide a set of power shell modules that provide similar features.\nAnsible’s documentation is the best of the four by far. It has both extensive high level documentation making it easy to get started, but also extensive and up-to-date low level documentation to make it easy to reference for experienced users. The documentation has ample examples of usage that demonstrate a variety of use cases.\nSaltStack SaltStack is one of the slightly newer configuration management systems. SaltStack brings refinement to the modules design presented by ansible. Many of the cross distribution abstractions in SaltStack are more refined than their Ansible counter parts. One annoying weaknesses of Salt is there is no concept of a comment in the files. This makes it harder to documentation more obscure configuration choices.\nLike puppet, it recommends a agent to be running on the client machines. However like Ansible it does not strictly require one via the SaltSSH feature; technically puppet has a currently experimental feature called “bolt” that provides this functionality, but it very much is experimental. The agent still must register with the master for the agent based mode, but this is relatively easy.\nSupporting new configurations in SaltStack is about as easy as Puppet. Simply define a pillar (SaltStack’s admittedly simpler, but less flexible version of hiera) with the appropriate variables defined or create a new grain (SaltStack’s version of a fact) that determines the appropriate information.\nCreating new SaltStack modules is easily done with python. Modules are simply functions in a python file that accept and return a dictionary. This is substantially more polished than the clunky text oriented approach used by Ansible. This makes them fairly easy to implement, but perhaps not as refined as Puppet’s object oriented approach.\nSaltStack’s documentation is not as well refined as Ansible’s. While it still has excellent low level documentation, its high level documentation is not quite as refined. I believe this combined with the less support for various modules than Ansible has hindered SaltStack’s adoption.\nChef Chef is the other prominently used configuration management tool. Unlike SaltStack, Puppet, or Ansible, Chef uses nearly pure ruby to describe its configuration which it calls cookbooks. This has the advantage of being flexible, but the disadvantage of being harder to learn to use well than the descriptive domain specific languages used by the other three. Unfortunately of the four commonly used configuration management tools it is the one that I have the least experience with. I have used each of other systems to manage several systems that I consider production, and I have only managed test systems with Chef.\nLike Puppet and SaltStack, Chef uses a client-server architecture. However, unlike Puppet and Chef getting started on new nodes is very easy because of the chef knife feature. The knife tool allows you to easily bootstrap the chef agent on other machines making it almost as easy to get started as Ansible. Additionally the kitchen tool allows you to create and manage virtual machines for the purposes of testing applied configurations. This gives it a very compelling story form a getting started perspective.\nSince chef supports nearly arbitrary ruby code in “cookbooks”, making supporting new configurations is easy, but perhaps not quite as clean as some of the other systems such as Ansible. Chef like SaltStack has respectable and reasonably mature abstractions to make cross distribution development reasonable.\nCreating new chef types is as simple as writing new ruby classes. Since it uses nearly pure ruby, you can reach into the vast array of existing ruby libraries to build your modules.\nChef has ok documentation, but I find that it misses some of the high level documentation that really makes Ansible shine, however I would rate it above SaltStack.\nWhich is Better? Before deciding on which system you should use, you should think about what requirements you have and why you have them. I’d also consider writing a small project in each when evaluating if it meets your needs. Some things like ease of use are highly subjective, so don’t take my word for them try them yourself. I would recommend something simple like installing your dotfiles.\nThat brings an end to part 2 of this series. In the final part of this series, I’ll offer some advise built on years of experience using configuration management systems.\n","wordCount":"1616","inLanguage":"en","datePublished":"2018-07-31T09:00:00-05:00","dateModified":"2018-07-31T09:00:00-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Configuration Management: the Battle Royal
</h1>
<div class=post-meta><span title="2018-07-31 09:00:00 -0500 -0500">July 31, 2018</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1616 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#puppet>Puppet</a></li>
<li><a href=#ansible>Ansible</a></li>
<li><a href=#saltstack>SaltStack</a></li>
<li><a href=#chef>Chef</a></li>
<li><a href=#which-is-better>Which is Better?</a></li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>So, you need a Configuration Management System, so which one do you choose?
This post is the second in a three part series on configuration management.
In this post, I&rsquo;ll highlight the strengths of these systems and their respective weaknesses.</p>
<p>Every evaluation needs to have criteria to be useful.
Here are some of the criteria that I have had when I thought about this question.</p>
<ul>
<li>Ease of Use</li>
<li>Time to Setup</li>
<li>Difficulty of Adding More Machines</li>
<li>Difficulty of Creating New Modules</li>
<li>Difficulty of Supporting More Configurations</li>
<li>Quality of Documentation</li>
</ul>
<h1 id=puppet>Puppet<a hidden class=anchor aria-hidden=true href=#puppet>#</a></h1>
<p>Puppet is the oldest open source configuration management system, and perhaps the mostly widely deployed in enterprise environments.
In my opinion, it is the most different out of the four open source configuration management systems.
It uses a completely declarative language that requires some getting used to.
It managements ordering by the use of explicit ordering statements.
Additionally each resource, may only be declared once.
The problem this proposes is with inter-module dependency management.
Puppet solves this problem with the use of virtual resources.
Virtual resources then can be &ldquo;realized&rdquo; multiple times, but only one instance of the resource will be created.
For those unfamiliar with this concept, it takes a while to get used to.
Using the completely graph oriented execution policy allows Puppet to create highly parallel and fast execution graphs to apply the specified policy.</p>
<p>Puppet uses a client-server architecture with multiple components.
Each managed box runs a copy of the agent which is intended to run in concert with a master.
The agent registers with the Puppet master which then applies the policy with according to a specified regularity.
The other key components of Puppet are , <code>facter</code>, <code>hiera</code>, and <code>puppetdb</code>.
<code>facter</code> is responsible for gather &ldquo;facts&rdquo; about the nodes such as the hostname, number of cpus, or the ip-address.
<code>hiera</code> is responsible for providing hierarchical information to the nodes such as what group(s) a node belongs to and group based variables.
<code>puppetdb</code> acts as a &ldquo;fact cache&rdquo; and repository of events that happen on the nodes.</p>
<p>Adding a new box generally requires the agent requesting a master to sign a certificate request.
Without the signing their request, the agents will not be delivered a configuration to deploy.
This can provides a high level of security, but is admit auntly harder to configure than some of the other solutions.</p>
<p>Supporting more configurations is somewhat easy to do using Puppet.
There are two common ways this is accomplished.
The first is using so-called &ldquo;parameter modules&rdquo; which are small Puppet files that use conditional expressions to specify an appropriate values based on the facts on a system.
The other method is using <code>hiera</code> to specify different values.
The <code>hiera</code> should be thought of providing different values based on role, where as &ldquo;parameter modules&rdquo; should be thought of providing for variations on the same role.
However, the exact point to draw the line between the two is not always clear which in my opinion cases some confusion.</p>
<p>Creating new resources types can be done with ruby.
Puppet types are simply ruby classes that provide certain members and methods.
For those who know ruby, extending Puppet is a breeze.</p>
<p>Puppets documentation is perhaps its worst facet.
It is at times impenetrable at others hopeless vague and unhelpful.
Its gotten better since when I first used it over four years ago, but it is still the worst of the four by far.</p>
<h1 id=ansible>Ansible<a hidden class=anchor aria-hidden=true href=#ansible>#</a></h1>
<p>Ansible is another early open source configuration management system.
Unlike Puppet, Ansible uses &ldquo;playbooks&rdquo; which are linear lists of instructions that generally execute from top to bottom.
While this makes it easier to use and reason about, it can make it slower to execute.
There is additionally no restraint on having resources managed in only one location.
This creates a greater possibility of error if there are conflicting requirements, but makes it easier to work with common resources.
Additionally recently, it was acquired by Red Hat making it likely to stick around and be well supported for years to come.</p>
<p>Instead of requiring its own agent infrastructure, Ansible reuses <code>ssh</code> and <code>python</code> making it fairly easy to adopt since most systems already have these installed.
The ansible agent is temporarily loaded on to the system when the master connects.
This obviates the need to maintain or update the agent since it is loaded fresh each time.
This temporary agent does all required fact finding and receives the appropriate set of host and group facts from the master.</p>
<p>Adding a new box is a breeze with Ansible.
Simply use <code>ssh-copy-id</code> to copy the master&rsquo;s ssh key on the node, and ensure that a somewhat recent venison of <code>python</code> is installed.
It may be one of the easiest system to get started.</p>
<p>Supporting new configurations with Ansible is easy.
Ansible has a clearly defined variable precedence hierarchy.
Simply define variables with the appropriate level of precedence.
There is one exception to this: Windows.
Windows systems often require different modules that make it more difficulty to integrate them using the same role files.</p>
<p>Creating new ansible modules (what Puppet calls a resource) can be done with <code>python</code>.
They are simply scripts that accept from standard input and return JSON to standard output as text.
Additionally, Ansible provides a large number of helper methods in <code>python</code> to make it easy to develop new modules.
For windows systems, they provide a set of power shell modules that provide similar features.</p>
<p>Ansible&rsquo;s documentation is the best of the four by far.
It has both extensive high level documentation making it easy to get started, but also extensive and up-to-date low level documentation to make it easy to reference for experienced users.
The documentation has ample examples of usage that demonstrate a variety of use cases.</p>
<h1 id=saltstack>SaltStack<a hidden class=anchor aria-hidden=true href=#saltstack>#</a></h1>
<p>SaltStack is one of the slightly newer configuration management systems.
SaltStack brings refinement to the modules design presented by ansible.
Many of the cross distribution abstractions in SaltStack are more refined than their Ansible counter parts.
One annoying weaknesses of Salt is there is no concept of a comment in the files.
This makes it harder to documentation more obscure configuration choices.</p>
<p>Like puppet, it recommends a agent to be running on the client machines.
However like Ansible it does not strictly require one via the SaltSSH feature; technically puppet has a currently experimental feature called &ldquo;bolt&rdquo; that provides this functionality, but it very much is experimental.
The agent still must register with the master for the agent based mode, but this is relatively easy.</p>
<p>Supporting new configurations in SaltStack is about as easy as Puppet.
Simply define a pillar (SaltStack&rsquo;s admittedly simpler, but less flexible version of <code>hiera</code>) with the appropriate variables defined or create a new grain (SaltStack&rsquo;s version of a fact) that determines the appropriate information.</p>
<p>Creating new SaltStack modules is easily done with python.
Modules are simply functions in a python file that accept and return a dictionary.
This is substantially more polished than the clunky text oriented approach used by Ansible.
This makes them fairly easy to implement, but perhaps not as refined as Puppet&rsquo;s object oriented approach.</p>
<p>SaltStack&rsquo;s documentation is not as well refined as Ansible&rsquo;s.
While it still has excellent low level documentation, its high level documentation is not quite as refined.
I believe this combined with the less support for various modules than Ansible has hindered SaltStack&rsquo;s adoption.</p>
<h1 id=chef>Chef<a hidden class=anchor aria-hidden=true href=#chef>#</a></h1>
<p>Chef is the other prominently used configuration management tool.
Unlike SaltStack, Puppet, or Ansible, Chef uses nearly pure ruby to describe its configuration which it calls cookbooks.
This has the advantage of being flexible, but the disadvantage of being harder to learn to use well than the descriptive domain specific languages used by the other three.
Unfortunately of the four commonly used configuration management tools it is the one that I have the least experience with.
I have used each of other systems to manage several systems that I consider production, and I have only managed test systems with Chef.</p>
<p>Like Puppet and SaltStack, Chef uses a client-server architecture.
However, unlike Puppet and Chef getting started on new nodes is very easy because of the chef <code>knife</code> feature.
The <code>knife</code> tool allows you to easily bootstrap the chef agent on other machines making it almost as easy to get started as Ansible.
Additionally the <code>kitchen</code> tool allows you to create and manage virtual machines for the purposes of testing applied configurations.
This gives it a very compelling story form a getting started perspective.</p>
<p>Since chef supports nearly arbitrary ruby code in &ldquo;cookbooks&rdquo;, making supporting new configurations is easy, but perhaps not quite as clean as some of the other systems such as Ansible.
Chef like SaltStack has respectable and reasonably mature abstractions to make cross distribution development reasonable.</p>
<p>Creating new chef types is as simple as writing new ruby classes.
Since it uses nearly pure ruby, you can reach into the vast array of existing ruby libraries to build your modules.</p>
<p>Chef has ok documentation, but I find that it misses some of the high level documentation that really makes Ansible shine, however I would rate it above SaltStack.</p>
<h1 id=which-is-better>Which is Better?<a hidden class=anchor aria-hidden=true href=#which-is-better>#</a></h1>
<p>Before deciding on which system you should use, you should think about what requirements you have and why you have them.
I&rsquo;d also consider writing a small project in each when evaluating if it meets your needs.
Some things like ease of use are highly subjective, so don&rsquo;t take my word for them try them yourself.
I would recommend something simple like installing your dotfiles.</p>
<p>That brings an end to part 2 of this series. In the final part of this series, I&rsquo;ll offer some advise built on years of experience using configuration management systems.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/ansible.html>ansible</a></li>
<li><a href=http://robertu94.github.io/tags/chef.html>Chef</a></li>
<li><a href=http://robertu94.github.io/tags/puppet.html>Puppet</a></li>
<li><a href=http://robertu94.github.io/tags/saltstack.html>SaltStack</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2018/07/31/configuration-management-common-pitfalls.html>
<span class=title>« Prev</span>
<br>
<span>Configuration Management: Common Pitfalls</span>
</a>
<a class=next href=http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html>
<span class=title>Next »</span>
<br>
<span>Configuration Management: the Related Systems</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>