<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Configuration Management: the Related Systems | systems++</title>
<meta name=keywords content="Ansible,Chef,Puppet,SaltStack">
<meta name=description content="Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.">
<meta name=author content="Robert Underwood">
<link rel=canonical href=http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html>
<meta name=google-site-verification content="G-9KQE44SX6K">
<link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.baa4f2053c75d0009e9309aae8f8a8959f5e0372e88f80cdf2951a9533d71ce2.js integrity="sha256-uqTyBTx10ACekwmq6PiolZ9eA3Loj4DN8pUalTPXHOI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://robertu94.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://robertu94.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://robertu94.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://robertu94.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://robertu94.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9KQE44SX6K"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-9KQE44SX6K',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Configuration Management: the Related Systems">
<meta property="og:description" content="Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-07-31T08:00:00-05:00">
<meta property="article:modified_time" content="2018-07-31T08:00:00-05:00"><meta property="og:site_name" content="Systems++">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Configuration Management: the Related Systems">
<meta name=twitter:description content="Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Configuration Management: the Related Systems","item":"http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Configuration Management: the Related Systems","name":"Configuration Management: the Related Systems","description":"Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.","keywords":["Ansible","Chef","Puppet","SaltStack"],"articleBody":"Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines. But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started? This post is the first in a series of posts that will attempt to answer these questions.\nConfigurations Management systems enforce a software-defined policy against the running state of computer systems. I think this is best thought of in terms of some other important but different systems.\nShell Scripts Like shell scripts, Configuration management systems allow you to write a series of configuration steps into code that are executed on machines. However, unlike shell scripts, these systems strive for idempotency by default – actions are run if and only if they are needed. Additionally configuration management systems often manage the parallelism of running the configuration on a variety of different machines. Together idempotency potency and built-in parallelism make implementing scalable, repeatable systems substantially more pleasant.\nPackage Management Systems (dnf, apt, pacman, portage, etc…) Package managers can be used to install software files, configure users, network configurations, and more through the use of specially designed custom packages. However, using systems to manage things like users or network configurations can be tricky, because it is required to track all potential starting points of the systems and code to get them to the desired current state. Some package managers explicitly prohibit any changes to files owned by other packages. While this is good for ensuing a consistent file systems, it makes it hard if not impossible to manage files like /etc/hostname that are often owned by some base file system layout package using these mechanisms.\nFirstboot Management Systems (packer, cloudinit, kickstart, sytstemd, etc…) Packer is a software package that allows you to construct a distributable image your base system that can define things like your preferred dhcp configuration or ensure that your configuration management system agent is installed if required to bootstrap later management. Likewise the couldinit, kickstart, or systemd’s ConditionFirstBoot= option allow you to specify many of these initial configuration requirements required to bootstrap everything that comes after. However, since these operate on first boot only, they can’t effectively be used to manage on-going configuration management without making the base OS immutable which isn’t done that often outside of container environments that are designed to work in this manner.\nContainer Management Systems (docker, kubernetes) Container Management systems such as Docker and Kubernetes in many ways can stand in the place of Configuration Management systems. Often in container-oriented architectures, you have some resilient, distributed key store such as etcd that stores configuration for services running in the containers. Additionally, for state-ful services you have something like a PersistantStorageClaim that reserves some amount of storage on a possibly remote storage device or service (iSCSI, RDB, FiberChannel, etc…) or a separate database service. Then the container manager ensures that you have a sufficient number of replicas running at any given time. Some approaches like the one taken by Fedora-CoreOS (formally Fedora Project Atomic and Container Linux) operate by distributing an immutable image that is then first-booted every time and managed using the tools described above. In many cases, this can obviate the need for a configuration management system.\nHowever, there are some cases where configuration management systems are still useful. Managing the underlying services that support the container environment is often difficult because fundamentally these services are hard to contain: they often need direct, physical access to hardware; need to manage the container engine itself; or need privileges that you don’t want to provide to a container. A configuration management system can help fill this gap in managing the base infrastructure required: for example allocating new VMs or machines to join your kubernetes cluster, configuring the routers or switches so that they can be later managed by Kubernetes or Docker.\nThat concludes the first post in this series. Next time, I’ll cover some of the major systems that operate in this space, and the means by which I compare them.\n","wordCount":"688","inLanguage":"en","datePublished":"2018-07-31T08:00:00-05:00","dateModified":"2018-07-31T08:00:00-05:00","author":{"@type":"Person","name":"Robert Underwood"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://robertu94.github.io/2018/07/31/configuration-management-the-related-systems.html"},"publisher":{"@type":"Organization","name":"systems++","logo":{"@type":"ImageObject","url":"http://robertu94.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://robertu94.github.io/ accesskey=h title="systems++ (Alt + H)">systems++</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=http://robertu94.github.io/about.html title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/guides.html title=Guides>
<span>Guides</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/learning.html title="Learning To Learn">
<span>Learning To Learn</span>
</a>
</li>
<li>
<a href=http://robertu94.github.io/presentations.html title=Presentations>
<span>Presentations</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=http://robertu94.github.io/>Home</a></div>
<h1 class=post-title>
Configuration Management: the Related Systems
</h1>
<div class=post-meta><span title="2018-07-31 08:00:00 -0500 -0500">July 31, 2018</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;688 words&nbsp;·&nbsp;Robert Underwood
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><nav id=TableOfContents>
<ul>
<li><a href=#shell-scripts>Shell Scripts</a></li>
<li><a href=#package-management-systems-dnf-apt-pacman-portage-etc>Package Management Systems (dnf, apt, pacman, portage, etc&mldr;)</a></li>
<li><a href=#firstboot-management-systems-packer-cloudinit-kickstart-sytstemd-etc>Firstboot Management Systems (packer, cloudinit, kickstart, sytstemd, etc&mldr;)</a></li>
<li><a href=#container-management-systems-docker-kubernetes>Container Management Systems (docker, kubernetes)</a></li>
</ul>
</nav>
</div>
</details>
</div>
<div class=post-content><p>Configuration Management Systems like Ansible, Chef, Puppet, and SaltStack are in my opinion are nearly essential if you find yourself managing more than 5 machines.
But what exactly are they, which is better for my circumstances, do I still need them if I use a container based infrastructure, how do I get started?
This post is the first in a series of posts that will attempt to answer these questions.</p>
<p>Configurations Management systems enforce a software-defined policy against the running state of computer systems.
I think this is best thought of in terms of some other important but different systems.</p>
<h1 id=shell-scripts>Shell Scripts<a hidden class=anchor aria-hidden=true href=#shell-scripts>#</a></h1>
<p>Like shell scripts, Configuration management systems allow you to write a series of configuration steps into code that are executed on machines.
However, unlike shell scripts, these systems strive for idempotency by default &ndash; actions are run if and only if they are needed.
Additionally configuration management systems often manage the parallelism of running the configuration on a variety of different machines.
Together idempotency potency and built-in parallelism make implementing scalable, repeatable systems substantially more pleasant.</p>
<h1 id=package-management-systems-dnf-apt-pacman-portage-etc>Package Management Systems (dnf, apt, pacman, portage, etc&mldr;)<a hidden class=anchor aria-hidden=true href=#package-management-systems-dnf-apt-pacman-portage-etc>#</a></h1>
<p>Package managers can be used to install software files, configure users, network configurations, and more through the use of specially designed custom packages.
However, using systems to manage things like users or network configurations can be tricky, because it is required to track all potential starting points of the systems and code to get them to the desired current state.
Some package managers explicitly prohibit any changes to files owned by other packages.
While this is good for ensuing a consistent file systems, it makes it hard if not impossible to manage files like <code>/etc/hostname</code> that are often owned by some base file system layout package using these mechanisms.</p>
<h1 id=firstboot-management-systems-packer-cloudinit-kickstart-sytstemd-etc>Firstboot Management Systems (packer, cloudinit, kickstart, sytstemd, etc&mldr;)<a hidden class=anchor aria-hidden=true href=#firstboot-management-systems-packer-cloudinit-kickstart-sytstemd-etc>#</a></h1>
<p>Packer is a software package that allows you to construct a distributable image your base system that can define things like your preferred dhcp configuration or ensure that your configuration management system agent is installed if required to bootstrap later management.
Likewise the couldinit, kickstart, or systemd&rsquo;s <code>ConditionFirstBoot=</code> option allow you to specify many of these initial configuration requirements required to bootstrap everything that comes after.
However, since these operate on first boot only, they can&rsquo;t effectively be used to manage on-going configuration management without making the base OS immutable which isn&rsquo;t done that often outside of container environments that are designed to work in this manner.</p>
<h1 id=container-management-systems-docker-kubernetes>Container Management Systems (docker, kubernetes)<a hidden class=anchor aria-hidden=true href=#container-management-systems-docker-kubernetes>#</a></h1>
<p>Container Management systems such as Docker and Kubernetes in many ways can stand in the place of Configuration Management systems.
Often in container-oriented architectures, you have some resilient, distributed key store such as <code>etcd</code> that stores configuration for services running in the containers.
Additionally, for state-ful services you have something like a <code>PersistantStorageClaim</code> that reserves some amount of storage on a possibly remote storage device or service (iSCSI, RDB, FiberChannel, etc&mldr;) or a separate database service.
Then the container manager ensures that you have a sufficient number of replicas running at any given time.
Some approaches like the one taken by Fedora-CoreOS (formally Fedora Project Atomic and Container Linux) operate by distributing an immutable image that is then first-booted every time and managed using the tools described above.
In many cases, this can obviate the need for a configuration management system.</p>
<p>However, there are some cases where configuration management systems are still useful.
Managing the underlying services that support the container environment is often difficult because fundamentally these services are hard to contain: they often need direct, physical access to hardware; need to manage the container engine itself; or need privileges that you don&rsquo;t want to provide to a container.
A configuration management system can help fill this gap in managing the base infrastructure required: for example allocating new VMs or machines to join your kubernetes cluster, configuring the routers or switches so that they can be later managed by Kubernetes or Docker.</p>
<p>That concludes the first post in this series. Next time, I&rsquo;ll cover some of the major systems that operate in this space, and the means by which I compare them.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://robertu94.github.io/tags/ansible.html>ansible</a></li>
<li><a href=http://robertu94.github.io/tags/chef.html>Chef</a></li>
<li><a href=http://robertu94.github.io/tags/puppet.html>Puppet</a></li>
<li><a href=http://robertu94.github.io/tags/saltstack.html>SaltStack</a></li>
</ul>
<nav class=paginav>
<a class=prev href=http://robertu94.github.io/2018/07/31/configuration-management-the-battle-royal.html>
<span class=title>« Prev</span>
<br>
<span>Configuration Management: the Battle Royal</span>
</a>
<a class=next href=http://robertu94.github.io/2018/05/12/generic-cuda.html>
<span class=title>Next »</span>
<br>
<span>Generic Cuda</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=http://robertu94.github.io/>systems++</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>